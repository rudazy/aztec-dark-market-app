import { MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_CIPHERTEXT_LEN } from '@aztec/constants';
import { Fr } from '@aztec/foundation/fields';
import { TxHash } from '@aztec/stdlib/tx';
// This is used as a response for PXE's custom getPublicLogByTag oracle.
export class PublicLogWithTxData {
    logPayload;
    txHash;
    uniqueNoteHashesInTx;
    firstNullifierInTx;
    constructor(logPayload, txHash, uniqueNoteHashesInTx, firstNullifierInTx){
        this.logPayload = logPayload;
        this.txHash = txHash;
        this.uniqueNoteHashesInTx = uniqueNoteHashesInTx;
        this.firstNullifierInTx = firstNullifierInTx;
    }
}
// This is used as a response for PXE's custom getPrivateLogByTag oracle.
export class PrivateLogWithTxData {
    logPayload;
    txHash;
    uniqueNoteHashesInTx;
    firstNullifierInTx;
    constructor(logPayload, txHash, uniqueNoteHashesInTx, firstNullifierInTx){
        this.logPayload = logPayload;
        this.txHash = txHash;
        this.uniqueNoteHashesInTx = uniqueNoteHashesInTx;
        this.firstNullifierInTx = firstNullifierInTx;
    }
    toNoirSerialization() {
        return [
            ...toBoundedVecSerialization(this.logPayload, PRIVATE_LOG_CIPHERTEXT_LEN),
            this.txHash.hash,
            ...toBoundedVecSerialization(this.uniqueNoteHashesInTx, MAX_NOTE_HASHES_PER_TX),
            this.firstNullifierInTx
        ];
    }
    static noirSerializationOfEmpty() {
        return new PrivateLogWithTxData([], TxHash.zero(), [], new Fr(0)).toNoirSerialization();
    }
}
function toBoundedVecSerialization(array, maxLength) {
    if (array.length > maxLength) {
        throw new Error(`An array of length ${array.length} cannot be converted to a BoundedVec of max length ${maxLength}`);
    }
    return [
        array.concat(Array(maxLength - array.length).fill(new Fr(0))),
        new Fr(array.length)
    ];
}
