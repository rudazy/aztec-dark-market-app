import { Fr } from '@aztec/foundation/fields';
import { type ZodFor } from '@aztec/foundation/schemas';
import { BufferReader, FieldReader } from '@aztec/foundation/serialize';
import type { FieldsOf } from '@aztec/foundation/types';
import { inspect } from 'util';
import { CheckpointHeader } from '../rollup/checkpoint_header.js';
import { AppendOnlyTreeSnapshot } from '../trees/append_only_tree_snapshot.js';
import { BlockHeader, ContentCommitment, GlobalVariables, StateReference } from '../tx/index.js';
/**
 * TO BE DELETED
 *
 * A header of an L2 block combining the block header and the checkpoint header.
 * This is a temporary workaround to avoid changing too many things before building in chunks is properly implemented.
 * This works for now because we only have one block per checkpoint.
 *
 * @deprecated Use BlockHeader or CheckpointHeader instead.
 */
export declare class L2BlockHeader {
    /** Snapshot of archive before the block is applied. */
    lastArchive: AppendOnlyTreeSnapshot;
    /** Hash of the body of an L2 block. */
    contentCommitment: ContentCommitment;
    /** State reference. */
    state: StateReference;
    /** Global variables of an L2 block. */
    globalVariables: GlobalVariables;
    /** Total fees in the block, computed by the root rollup circuit */
    totalFees: Fr;
    /** Total mana used in the block, computed by the root rollup circuit */
    totalManaUsed: Fr;
    /** Hash of the sponge blob of the block. */
    spongeBlobHash: Fr;
    constructor(
    /** Snapshot of archive before the block is applied. */
    lastArchive: AppendOnlyTreeSnapshot, 
    /** Hash of the body of an L2 block. */
    contentCommitment: ContentCommitment, 
    /** State reference. */
    state: StateReference, 
    /** Global variables of an L2 block. */
    globalVariables: GlobalVariables, 
    /** Total fees in the block, computed by the root rollup circuit */
    totalFees: Fr, 
    /** Total mana used in the block, computed by the root rollup circuit */
    totalManaUsed: Fr, 
    /** Hash of the sponge blob of the block. */
    spongeBlobHash: Fr);
    static get schema(): ZodFor<L2BlockHeader>;
    static getFields(fields: FieldsOf<L2BlockHeader>): readonly [AppendOnlyTreeSnapshot, ContentCommitment, StateReference, GlobalVariables, Fr, Fr, Fr];
    static from(fields: FieldsOf<L2BlockHeader>): L2BlockHeader;
    getSlot(): bigint;
    getBlockNumber(): number;
    getSize(): number;
    toBuffer(): Buffer<ArrayBufferLike>;
    toFields(): Fr[];
    clone(): L2BlockHeader;
    static fromBuffer(buffer: Buffer | BufferReader): L2BlockHeader;
    static fromFields(fields: Fr[] | FieldReader): L2BlockHeader;
    static empty(fields?: Partial<FieldsOf<L2BlockHeader>>): L2BlockHeader;
    isEmpty(): boolean;
    /**
     * Serializes this instance into a string.
     * @returns Encoded string.
     */
    toString(): `0x${string}`;
    static fromString(str: string): L2BlockHeader;
    toCheckpointHeader(): CheckpointHeader;
    toBlockHeader(): BlockHeader;
    toInspect(): {
        lastArchive: `0x${string}`;
        contentCommitment: {
            blobsHash: `0x${string}`;
            inHash: `0x${string}`;
            outHash: `0x${string}`;
        };
        state: {
            l1ToL2MessageTree: `0x${string}`;
            noteHashTree: `0x${string}`;
            nullifierTree: `0x${string}`;
            publicDataTree: `0x${string}`;
        };
        globalVariables: {
            chainId: number;
            version: number;
            blockNumber: number;
            slotNumber: number;
            timestamp: bigint;
            coinbase: `0x${string}`;
            feeRecipient: `0x${string}`;
            feePerDaGas: number;
            feePerL2Gas: number;
        };
        totalFees: bigint;
        totalManaUsed: bigint;
        spongeBlobHash: `0x${string}`;
    };
    [inspect.custom](): string;
    equals(other: this): boolean;
}
//# sourceMappingURL=l2_block_header.d.ts.map