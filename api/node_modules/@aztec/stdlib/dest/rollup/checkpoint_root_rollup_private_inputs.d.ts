import { BlobAccumulator, FinalBlobBatchingChallenges } from '@aztec/blob-lib/types';
import { ARCHIVE_HEIGHT, BLOBS_PER_BLOCK } from '@aztec/constants';
import { BLS12Point, Fr } from '@aztec/foundation/fields';
import { BufferReader, type Tuple } from '@aztec/foundation/serialize';
import type { FieldsOf } from '@aztec/foundation/types';
import { type RollupHonkProofData } from '../proofs/proof_data.js';
import { BlockHeader } from '../tx/block_header.js';
import { BlockRollupPublicInputs } from './block_rollup_public_inputs.js';
export declare class CheckpointRootRollupHints {
    /**
     * The header of the previous block before this checkpoint.
     */
    previousBlockHeader: BlockHeader;
    /**
     * Hint for checking the hash of previous_block_header is the last leaf of the previous archive.
     */
    previousArchiveSiblingPath: Tuple<Fr, typeof ARCHIVE_HEIGHT>;
    /**
     * The current blob accumulation state across the epoch.
     */
    startBlobAccumulator: BlobAccumulator;
    /**
     * Finalized challenges z and gamma for performing blob batching. Shared value across the epoch.
     */
    finalBlobChallenges: FinalBlobBatchingChallenges;
    /**
     * Flat list of all tx effects which will be added to the blob.
     * Below line gives error 'Type instantiation is excessively deep and possibly infinite. ts(2589)'
     * Tuple<Fr, FIELDS_PER_BLOB * BLOBS_PER_BLOCK>
     */
    blobFields: Fr[];
    /**
     * KZG commitments representing the blob (precomputed in ts, injected to use inside circuit).
     */
    blobCommitments: Tuple<BLS12Point, typeof BLOBS_PER_BLOCK>;
    /**
     * The hash of eth blob hashes for this block
     * See yarn-project/foundation/src/blob/index.ts or body.ts for calculation
     */
    blobsHash: Fr;
    constructor(
    /**
     * The header of the previous block before this checkpoint.
     */
    previousBlockHeader: BlockHeader, 
    /**
     * Hint for checking the hash of previous_block_header is the last leaf of the previous archive.
     */
    previousArchiveSiblingPath: Tuple<Fr, typeof ARCHIVE_HEIGHT>, 
    /**
     * The current blob accumulation state across the epoch.
     */
    startBlobAccumulator: BlobAccumulator, 
    /**
     * Finalized challenges z and gamma for performing blob batching. Shared value across the epoch.
     */
    finalBlobChallenges: FinalBlobBatchingChallenges, 
    /**
     * Flat list of all tx effects which will be added to the blob.
     * Below line gives error 'Type instantiation is excessively deep and possibly infinite. ts(2589)'
     * Tuple<Fr, FIELDS_PER_BLOB * BLOBS_PER_BLOCK>
     */
    blobFields: Fr[], 
    /**
     * KZG commitments representing the blob (precomputed in ts, injected to use inside circuit).
     */
    blobCommitments: Tuple<BLS12Point, typeof BLOBS_PER_BLOCK>, 
    /**
     * The hash of eth blob hashes for this block
     * See yarn-project/foundation/src/blob/index.ts or body.ts for calculation
     */
    blobsHash: Fr);
    static from(fields: FieldsOf<CheckpointRootRollupHints>): CheckpointRootRollupHints;
    static getFields(fields: FieldsOf<CheckpointRootRollupHints>): readonly [BlockHeader, [Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr], BlobAccumulator, FinalBlobBatchingChallenges, Fr[], [BLS12Point, BLS12Point, BLS12Point], Fr];
    toBuffer(): Buffer<ArrayBufferLike>;
    static fromBuffer(buffer: Buffer | BufferReader): CheckpointRootRollupHints;
    toString(): `0x${string}`;
    static fromString(str: string): CheckpointRootRollupHints;
    toJSON(): Buffer<ArrayBufferLike>;
    static get schema(): import("zod").ZodType<CheckpointRootRollupHints, any, string>;
}
export declare class CheckpointRootRollupPrivateInputs {
    previousRollups: [
        RollupHonkProofData<BlockRollupPublicInputs>,
        RollupHonkProofData<BlockRollupPublicInputs>
    ];
    hints: CheckpointRootRollupHints;
    constructor(previousRollups: [
        RollupHonkProofData<BlockRollupPublicInputs>,
        RollupHonkProofData<BlockRollupPublicInputs>
    ], hints: CheckpointRootRollupHints);
    static from(fields: FieldsOf<CheckpointRootRollupPrivateInputs>): CheckpointRootRollupPrivateInputs;
    static getFields(fields: FieldsOf<CheckpointRootRollupPrivateInputs>): readonly [[RollupHonkProofData<BlockRollupPublicInputs>, RollupHonkProofData<BlockRollupPublicInputs>], CheckpointRootRollupHints];
    toBuffer(): Buffer<ArrayBufferLike>;
    static fromBuffer(buffer: Buffer | BufferReader): CheckpointRootRollupPrivateInputs;
    toString(): `0x${string}`;
    static fromString(str: string): CheckpointRootRollupPrivateInputs;
    toJSON(): Buffer<ArrayBufferLike>;
    static get schema(): import("zod").ZodType<CheckpointRootRollupPrivateInputs, any, string>;
}
export declare class CheckpointRootSingleBlockRollupPrivateInputs {
    previousRollup: RollupHonkProofData<BlockRollupPublicInputs>;
    hints: CheckpointRootRollupHints;
    constructor(previousRollup: RollupHonkProofData<BlockRollupPublicInputs>, hints: CheckpointRootRollupHints);
    static from(fields: FieldsOf<CheckpointRootSingleBlockRollupPrivateInputs>): CheckpointRootSingleBlockRollupPrivateInputs;
    static getFields(fields: FieldsOf<CheckpointRootSingleBlockRollupPrivateInputs>): readonly [RollupHonkProofData<BlockRollupPublicInputs>, CheckpointRootRollupHints];
    toBuffer(): Buffer<ArrayBufferLike>;
    static fromBuffer(buffer: Buffer | BufferReader): CheckpointRootSingleBlockRollupPrivateInputs;
    toString(): `0x${string}`;
    static fromString(str: string): CheckpointRootSingleBlockRollupPrivateInputs;
    toJSON(): Buffer<ArrayBufferLike>;
    static get schema(): import("zod").ZodType<CheckpointRootSingleBlockRollupPrivateInputs, any, string>;
}
export declare class CheckpointPaddingRollupPrivateInputs {
    constructor();
    toBuffer(): Buffer<ArrayBuffer>;
    static fromBuffer(_buffer: Buffer | BufferReader): CheckpointPaddingRollupPrivateInputs;
    toString(): `0x${string}`;
    static fromString(_str: string): CheckpointPaddingRollupPrivateInputs;
    toJSON(): Buffer<ArrayBuffer>;
    static get schema(): import("zod").ZodType<CheckpointPaddingRollupPrivateInputs, any, string>;
}
//# sourceMappingURL=checkpoint_root_rollup_private_inputs.d.ts.map