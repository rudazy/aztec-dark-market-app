import { SpongeBlob } from '@aztec/blob-lib/types';
import { ARCHIVE_HEIGHT, L1_TO_L2_MSG_SUBTREE_ROOT_SIBLING_PATH_LENGTH } from '@aztec/constants';
import { Fr } from '@aztec/foundation/fields';
import { BufferReader, type Tuple } from '@aztec/foundation/serialize';
import type { FieldsOf } from '@aztec/foundation/types';
import { ParityPublicInputs } from '../parity/parity_public_inputs.js';
import { type RollupHonkProofData, type UltraHonkProofData } from '../proofs/proof_data.js';
import { AppendOnlyTreeSnapshot } from '../trees/append_only_tree_snapshot.js';
import { StateReference } from '../tx/state_reference.js';
import type { UInt64 } from '../types/shared.js';
import { CheckpointConstantData } from './checkpoint_constant_data.js';
import { TxRollupPublicInputs } from './tx_rollup_public_inputs.js';
export declare class BlockRootFirstRollupPrivateInputs {
    /**
     * The original and converted roots of the L1 to L2 messages subtrees.
     */
    l1ToL2Roots: UltraHonkProofData<ParityPublicInputs>;
    /**
     * The previous rollup proof data from base or merge rollup circuits.
     */
    previousRollups: [RollupHonkProofData<TxRollupPublicInputs>, RollupHonkProofData<TxRollupPublicInputs>];
    /**
     * The l1 to l2 message tree snapshot immediately before this block.
     */
    previousL1ToL2: AppendOnlyTreeSnapshot;
    /**
     * Hint for inserting the new l1 to l2 message subtree root into `previousL1ToL2`.
     */
    newL1ToL2MessageSubtreeRootSiblingPath: Tuple<Fr, typeof L1_TO_L2_MSG_SUBTREE_ROOT_SIBLING_PATH_LENGTH>;
    /**
     * Hint for inserting the new block hash to the last archive.
     */
    newArchiveSiblingPath: Tuple<Fr, typeof ARCHIVE_HEIGHT>;
    constructor(
    /**
     * The original and converted roots of the L1 to L2 messages subtrees.
     */
    l1ToL2Roots: UltraHonkProofData<ParityPublicInputs>, 
    /**
     * The previous rollup proof data from base or merge rollup circuits.
     */
    previousRollups: [RollupHonkProofData<TxRollupPublicInputs>, RollupHonkProofData<TxRollupPublicInputs>], 
    /**
     * The l1 to l2 message tree snapshot immediately before this block.
     */
    previousL1ToL2: AppendOnlyTreeSnapshot, 
    /**
     * Hint for inserting the new l1 to l2 message subtree root into `previousL1ToL2`.
     */
    newL1ToL2MessageSubtreeRootSiblingPath: Tuple<Fr, typeof L1_TO_L2_MSG_SUBTREE_ROOT_SIBLING_PATH_LENGTH>, 
    /**
     * Hint for inserting the new block hash to the last archive.
     */
    newArchiveSiblingPath: Tuple<Fr, typeof ARCHIVE_HEIGHT>);
    static from(fields: FieldsOf<BlockRootFirstRollupPrivateInputs>): BlockRootFirstRollupPrivateInputs;
    static getFields(fields: FieldsOf<BlockRootFirstRollupPrivateInputs>): readonly [UltraHonkProofData<ParityPublicInputs>, [RollupHonkProofData<TxRollupPublicInputs>, RollupHonkProofData<TxRollupPublicInputs>], AppendOnlyTreeSnapshot, [Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr], [Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr]];
    toBuffer(): Buffer<ArrayBufferLike>;
    static fromBuffer(buffer: Buffer | BufferReader): BlockRootFirstRollupPrivateInputs;
    toJSON(): Buffer<ArrayBufferLike>;
    static get schema(): import("zod").ZodType<BlockRootFirstRollupPrivateInputs, any, string>;
}
export declare class BlockRootSingleTxFirstRollupPrivateInputs {
    /**
     * The original and converted roots of the L1 to L2 messages subtrees.
     */
    l1ToL2Roots: UltraHonkProofData<ParityPublicInputs>;
    /**
     * The previous rollup proof data from base or merge rollup circuits.
     */
    previousRollup: RollupHonkProofData<TxRollupPublicInputs>;
    /**
     * The l1 to l2 message tree snapshot immediately before this block.
     */
    previousL1ToL2: AppendOnlyTreeSnapshot;
    /**
     * Hint for inserting the new l1 to l2 message subtree root.
     */
    newL1ToL2MessageSubtreeRootSiblingPath: Tuple<Fr, typeof L1_TO_L2_MSG_SUBTREE_ROOT_SIBLING_PATH_LENGTH>;
    /**
     * Hint for inserting the new block hash to the last archive.
     */
    newArchiveSiblingPath: Tuple<Fr, typeof ARCHIVE_HEIGHT>;
    constructor(
    /**
     * The original and converted roots of the L1 to L2 messages subtrees.
     */
    l1ToL2Roots: UltraHonkProofData<ParityPublicInputs>, 
    /**
     * The previous rollup proof data from base or merge rollup circuits.
     */
    previousRollup: RollupHonkProofData<TxRollupPublicInputs>, 
    /**
     * The l1 to l2 message tree snapshot immediately before this block.
     */
    previousL1ToL2: AppendOnlyTreeSnapshot, 
    /**
     * Hint for inserting the new l1 to l2 message subtree root.
     */
    newL1ToL2MessageSubtreeRootSiblingPath: Tuple<Fr, typeof L1_TO_L2_MSG_SUBTREE_ROOT_SIBLING_PATH_LENGTH>, 
    /**
     * Hint for inserting the new block hash to the last archive.
     */
    newArchiveSiblingPath: Tuple<Fr, typeof ARCHIVE_HEIGHT>);
    static from(fields: FieldsOf<BlockRootSingleTxFirstRollupPrivateInputs>): BlockRootSingleTxFirstRollupPrivateInputs;
    static getFields(fields: FieldsOf<BlockRootSingleTxFirstRollupPrivateInputs>): readonly [UltraHonkProofData<ParityPublicInputs>, RollupHonkProofData<TxRollupPublicInputs>, AppendOnlyTreeSnapshot, [Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr], [Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr]];
    toBuffer(): Buffer<ArrayBufferLike>;
    static fromBuffer(buffer: Buffer | BufferReader): BlockRootSingleTxFirstRollupPrivateInputs;
    toJSON(): Buffer<ArrayBufferLike>;
    static get schema(): import("zod").ZodType<BlockRootSingleTxFirstRollupPrivateInputs, any, string>;
}
export declare class BlockRootEmptyTxFirstRollupPrivateInputs {
    /**
     * The original and converted roots of the L1 to L2 messages subtrees.
     */
    l1ToL2Roots: UltraHonkProofData<ParityPublicInputs>;
    /**
     * The archive after applying the previous block.
     */
    previousArchive: AppendOnlyTreeSnapshot;
    /**
     * The state reference of the previous block.
     */
    previousState: StateReference;
    /**
     * The constants of the checkpoint.
     */
    constants: CheckpointConstantData;
    /**
     * The start sponge blob of this block. No data has been absorbed into it yet, since it's the first block. But the
     * number of expected fields must be set to the total number of fields in the entire checkpoint.
     */
    startSpongeBlob: SpongeBlob;
    /**
     * The timestamp of this block.
     */
    timestamp: UInt64;
    /**
     * Hint for inserting the new l1 to l2 message subtree root.
     */
    newL1ToL2MessageSubtreeRootSiblingPath: Tuple<Fr, typeof L1_TO_L2_MSG_SUBTREE_ROOT_SIBLING_PATH_LENGTH>;
    /**
     * Hint for inserting the new block hash to the last archive.
     */
    newArchiveSiblingPath: Tuple<Fr, typeof ARCHIVE_HEIGHT>;
    constructor(
    /**
     * The original and converted roots of the L1 to L2 messages subtrees.
     */
    l1ToL2Roots: UltraHonkProofData<ParityPublicInputs>, 
    /**
     * The archive after applying the previous block.
     */
    previousArchive: AppendOnlyTreeSnapshot, 
    /**
     * The state reference of the previous block.
     */
    previousState: StateReference, 
    /**
     * The constants of the checkpoint.
     */
    constants: CheckpointConstantData, 
    /**
     * The start sponge blob of this block. No data has been absorbed into it yet, since it's the first block. But the
     * number of expected fields must be set to the total number of fields in the entire checkpoint.
     */
    startSpongeBlob: SpongeBlob, 
    /**
     * The timestamp of this block.
     */
    timestamp: UInt64, 
    /**
     * Hint for inserting the new l1 to l2 message subtree root.
     */
    newL1ToL2MessageSubtreeRootSiblingPath: Tuple<Fr, typeof L1_TO_L2_MSG_SUBTREE_ROOT_SIBLING_PATH_LENGTH>, 
    /**
     * Hint for inserting the new block hash to the last archive.
     */
    newArchiveSiblingPath: Tuple<Fr, typeof ARCHIVE_HEIGHT>);
    static from(fields: FieldsOf<BlockRootEmptyTxFirstRollupPrivateInputs>): BlockRootEmptyTxFirstRollupPrivateInputs;
    static getFields(fields: FieldsOf<BlockRootEmptyTxFirstRollupPrivateInputs>): readonly [UltraHonkProofData<ParityPublicInputs>, AppendOnlyTreeSnapshot, StateReference, CheckpointConstantData, SpongeBlob, bigint, [Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr], [Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr]];
    toBuffer(): Buffer<ArrayBufferLike>;
    static fromBuffer(buffer: Buffer | BufferReader): BlockRootEmptyTxFirstRollupPrivateInputs;
    toJSON(): Buffer<ArrayBufferLike>;
    static get schema(): import("zod").ZodType<BlockRootEmptyTxFirstRollupPrivateInputs, any, string>;
}
export declare class BlockRootRollupPrivateInputs {
    /**
     * The previous rollup proof data from base or merge rollup circuits.
     */
    previousRollups: [RollupHonkProofData<TxRollupPublicInputs>, RollupHonkProofData<TxRollupPublicInputs>];
    /**
     * Hint for inserting the new block hash to the last archive.
     */
    newArchiveSiblingPath: Tuple<Fr, typeof ARCHIVE_HEIGHT>;
    constructor(
    /**
     * The previous rollup proof data from base or merge rollup circuits.
     */
    previousRollups: [RollupHonkProofData<TxRollupPublicInputs>, RollupHonkProofData<TxRollupPublicInputs>], 
    /**
     * Hint for inserting the new block hash to the last archive.
     */
    newArchiveSiblingPath: Tuple<Fr, typeof ARCHIVE_HEIGHT>);
    static from(fields: FieldsOf<BlockRootRollupPrivateInputs>): BlockRootRollupPrivateInputs;
    static getFields(fields: FieldsOf<BlockRootRollupPrivateInputs>): readonly [[RollupHonkProofData<TxRollupPublicInputs>, RollupHonkProofData<TxRollupPublicInputs>], [Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr]];
    toBuffer(): Buffer<ArrayBufferLike>;
    static fromBuffer(buffer: Buffer | BufferReader): BlockRootRollupPrivateInputs;
    toJSON(): Buffer<ArrayBufferLike>;
    static get schema(): import("zod").ZodType<BlockRootRollupPrivateInputs, any, string>;
}
export declare class BlockRootSingleTxRollupPrivateInputs {
    /**
     * The previous rollup proof data from base or merge rollup circuits.
     */
    previousRollup: RollupHonkProofData<TxRollupPublicInputs>;
    /**
     * Hint for inserting the new block hash to the last archive.
     */
    newArchiveSiblingPath: Tuple<Fr, typeof ARCHIVE_HEIGHT>;
    constructor(
    /**
     * The previous rollup proof data from base or merge rollup circuits.
     */
    previousRollup: RollupHonkProofData<TxRollupPublicInputs>, 
    /**
     * Hint for inserting the new block hash to the last archive.
     */
    newArchiveSiblingPath: Tuple<Fr, typeof ARCHIVE_HEIGHT>);
    static from(fields: FieldsOf<BlockRootSingleTxRollupPrivateInputs>): BlockRootSingleTxRollupPrivateInputs;
    static getFields(fields: FieldsOf<BlockRootSingleTxRollupPrivateInputs>): readonly [RollupHonkProofData<TxRollupPublicInputs>, [Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr]];
    toBuffer(): Buffer<ArrayBufferLike>;
    static fromBuffer(buffer: Buffer | BufferReader): BlockRootSingleTxRollupPrivateInputs;
    toJSON(): Buffer<ArrayBufferLike>;
    static get schema(): import("zod").ZodType<BlockRootSingleTxRollupPrivateInputs, any, string>;
}
//# sourceMappingURL=block_root_rollup_private_inputs.d.ts.map