import { BlobAccumulator, FinalBlobBatchingChallenges } from '@aztec/blob-lib/types';
import { AZTEC_MAX_EPOCH_DURATION } from '@aztec/constants';
import { EthAddress } from '@aztec/foundation/eth-address';
import { Fr } from '@aztec/foundation/fields';
import { BufferReader, type Tuple } from '@aztec/foundation/serialize';
import type { FieldsOf } from '@aztec/foundation/types';
import { AppendOnlyTreeSnapshot } from '../trees/append_only_tree_snapshot.js';
import { EpochConstantData } from './epoch_constant_data.js';
/**
 * Output of the checkpoint root and checkpoint merge rollup circuits.
 */
export declare class CheckpointRollupPublicInputs {
    /**
     * Constants for the entire epoch.
     */
    constants: EpochConstantData;
    /**
     * Archive tree immediately before this checkpoint range.
     */
    previousArchive: AppendOnlyTreeSnapshot;
    /**
     * Archive tree after adding this checkpoint range.
     */
    newArchive: AppendOnlyTreeSnapshot;
    /**
     * The hashes of the headers of the constituent checkpoints.
     */
    checkpointHeaderHashes: Tuple<Fr, typeof AZTEC_MAX_EPOCH_DURATION>;
    /**
     * The summed transaction fees and recipients of the constituent checkpoints.
     */
    fees: Tuple<FeeRecipient, typeof AZTEC_MAX_EPOCH_DURATION>;
    /**
     * Accumulated opening proofs for all blobs before this checkpoint range.
     */
    startBlobAccumulator: BlobAccumulator;
    /**
     * Accumulated opening proofs for all blobs after applying this checkpoint range.
     */
    endBlobAccumulator: BlobAccumulator;
    /**
     * Final values z and gamma, shared across the epoch.
     */
    finalBlobChallenges: FinalBlobBatchingChallenges;
    constructor(
    /**
     * Constants for the entire epoch.
     */
    constants: EpochConstantData, 
    /**
     * Archive tree immediately before this checkpoint range.
     */
    previousArchive: AppendOnlyTreeSnapshot, 
    /**
     * Archive tree after adding this checkpoint range.
     */
    newArchive: AppendOnlyTreeSnapshot, 
    /**
     * The hashes of the headers of the constituent checkpoints.
     */
    checkpointHeaderHashes: Tuple<Fr, typeof AZTEC_MAX_EPOCH_DURATION>, 
    /**
     * The summed transaction fees and recipients of the constituent checkpoints.
     */
    fees: Tuple<FeeRecipient, typeof AZTEC_MAX_EPOCH_DURATION>, 
    /**
     * Accumulated opening proofs for all blobs before this checkpoint range.
     */
    startBlobAccumulator: BlobAccumulator, 
    /**
     * Accumulated opening proofs for all blobs after applying this checkpoint range.
     */
    endBlobAccumulator: BlobAccumulator, 
    /**
     * Final values z and gamma, shared across the epoch.
     */
    finalBlobChallenges: FinalBlobBatchingChallenges);
    static fromBuffer(buffer: Buffer | BufferReader): CheckpointRollupPublicInputs;
    toBuffer(): Buffer<ArrayBufferLike>;
    toString(): `0x${string}`;
    static fromString(str: string): CheckpointRollupPublicInputs;
    /** Returns a buffer representation for JSON serialization. */
    toJSON(): Buffer<ArrayBufferLike>;
    /** Creates an instance from a hex string. */
    static get schema(): import("zod").ZodType<CheckpointRollupPublicInputs, any, string>;
}
export declare class FeeRecipient {
    recipient: EthAddress;
    value: Fr;
    constructor(recipient: EthAddress, value: Fr);
    static fromBuffer(buffer: Buffer | BufferReader): FeeRecipient;
    toBuffer(): Buffer<ArrayBufferLike>;
    static getFields(fields: FieldsOf<FeeRecipient>): readonly [EthAddress, Fr];
    toFields(): Fr[];
    static empty(): FeeRecipient;
    isEmpty(): boolean;
    toFriendlyJSON(): {
        recipient?: undefined;
        value?: undefined;
    } | {
        recipient: `0x${string}`;
        value: `0x${string}`;
    };
    static random(): FeeRecipient;
}
//# sourceMappingURL=checkpoint_rollup_public_inputs.d.ts.map