import { createLogger } from '@aztec/foundation/log';
import { makeBackoff, retry } from '@aztec/foundation/retry';
import axios from 'axios';
import { createWriteStream } from 'fs';
import { mkdir } from 'fs/promises';
import { dirname } from 'path';
import { finished } from 'stream/promises';
export class HttpFileStore {
    baseUrl;
    log;
    axiosInstance;
    fetch;
    constructor(baseUrl, log = createLogger('stdlib:http-file-store')){
        this.baseUrl = baseUrl;
        this.log = log;
        this.axiosInstance = axios.create();
        this.fetch = async (config)=>{
            return await retry(()=>this.axiosInstance.request(config), `Fetching ${config.url}`, makeBackoff([
                1,
                1,
                3
            ]), this.log, /*failSilently=*/ true);
        };
    }
    async read(pathOrUrl) {
        const url = this.getUrl(pathOrUrl);
        try {
            const response = await this.fetch({
                url,
                method: 'GET',
                responseType: 'arraybuffer'
            });
            return Buffer.from(response.data);
        } catch (error) {
            throw new Error(`Error fetching file from ${url}: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    async download(pathOrUrl, destPath) {
        const url = this.getUrl(pathOrUrl);
        try {
            const response = await this.fetch({
                url,
                method: 'GET',
                responseType: 'stream'
            });
            await mkdir(dirname(destPath), {
                recursive: true
            });
            await finished(response.data.pipe(createWriteStream(destPath)));
        } catch (error) {
            throw new Error(`Error fetching file from ${url}: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    async exists(pathOrUrl) {
        const url = this.getUrl(pathOrUrl);
        try {
            await this.fetch({
                url,
                method: 'HEAD'
            });
            return true;
        } catch  {
            return false;
        }
    }
    getUrl(path) {
        return URL.canParse(path) ? path : `${this.baseUrl.replace(/\/$/, '')}/${path}`;
    }
}
