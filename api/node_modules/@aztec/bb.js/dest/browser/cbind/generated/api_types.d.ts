export type Fq = Uint8Array;
export type Fr = Uint8Array;
export type Secp256k1Fr = Uint8Array;
export type Secp256r1Fr = Uint8Array;
export type Uint256T = Uint8Array;
export interface AesDecrypt {
    ciphertext: Uint8Array;
    iv: Uint8Array;
    key: Uint8Array;
    length: number;
}
interface MsgpackAesDecrypt {
    ciphertext: Uint8Array;
    iv: Uint8Array;
    key: Uint8Array;
    length: number;
}
export interface AesDecryptResponse {
    plaintext: Uint8Array;
}
interface MsgpackAesDecryptResponse {
    plaintext: Uint8Array;
}
export interface AesEncrypt {
    plaintext: Uint8Array;
    iv: Uint8Array;
    key: Uint8Array;
    length: number;
}
interface MsgpackAesEncrypt {
    plaintext: Uint8Array;
    iv: Uint8Array;
    key: Uint8Array;
    length: number;
}
export interface AesEncryptResponse {
    ciphertext: Uint8Array;
}
interface MsgpackAesEncryptResponse {
    ciphertext: Uint8Array;
}
export interface AffineElement {
    x: Fr;
    y: Fr;
}
interface MsgpackAffineElement {
    x: Uint8Array;
    y: Uint8Array;
}
export interface Blake2s {
    data: Uint8Array;
}
interface MsgpackBlake2s {
    data: Uint8Array;
}
export interface Blake2sResponse {
    hash: Uint8Array;
}
interface MsgpackBlake2sResponse {
    hash: Uint8Array;
}
export interface Blake2sToField {
    data: Uint8Array;
}
interface MsgpackBlake2sToField {
    data: Uint8Array;
}
export interface Blake2sToFieldResponse {
    field: Fr;
}
interface MsgpackBlake2sToFieldResponse {
    field: Uint8Array;
}
export interface Bn254FrSqrt {
    input: Fr;
}
interface MsgpackBn254FrSqrt {
    input: Uint8Array;
}
export interface Bn254FrSqrtResponse {
    isSquareRoot: boolean;
    value: Fr;
}
interface MsgpackBn254FrSqrtResponse {
    is_square_root: boolean;
    value: Uint8Array;
}
export interface CircuitComputeVk {
    circuit: CircuitInputNoVK;
    settings: ProofSystemSettings;
}
interface MsgpackCircuitComputeVk {
    circuit: MsgpackCircuitInputNoVK;
    settings: MsgpackProofSystemSettings;
}
export interface CircuitComputeVkResponse {
    bytes: Uint8Array;
    fields: Uint256T[];
    hash: Uint8Array;
}
interface MsgpackCircuitComputeVkResponse {
    bytes: Uint8Array;
    fields: Uint8Array[];
    hash: Uint8Array;
}
export interface CircuitInfoResponse {
    numGates: number;
    numGatesDyadic: number;
    numAcirOpcodes: number;
    gatesPerOpcode: number[];
}
interface MsgpackCircuitInfoResponse {
    num_gates: number;
    num_gates_dyadic: number;
    num_acir_opcodes: number;
    gates_per_opcode: number[];
}
export interface CircuitInput {
    name: string;
    bytecode: Uint8Array;
    verificationKey: Uint8Array;
}
interface MsgpackCircuitInput {
    name: string;
    bytecode: Uint8Array;
    verification_key: Uint8Array;
}
export interface CircuitInputNoVK {
    name: string;
    bytecode: Uint8Array;
}
interface MsgpackCircuitInputNoVK {
    name: string;
    bytecode: Uint8Array;
}
export interface CircuitProve {
    circuit: CircuitInput;
    witness: Uint8Array;
    settings: ProofSystemSettings;
}
interface MsgpackCircuitProve {
    circuit: MsgpackCircuitInput;
    witness: Uint8Array;
    settings: MsgpackProofSystemSettings;
}
export interface CircuitProveResponse {
    publicInputs: Uint256T[];
    proof: Uint256T[];
    vk: CircuitComputeVkResponse;
}
interface MsgpackCircuitProveResponse {
    public_inputs: Uint8Array[];
    proof: Uint8Array[];
    vk: MsgpackCircuitComputeVkResponse;
}
export interface CircuitStats {
    circuit: CircuitInput;
    includeGatesPerOpcode: boolean;
    settings: ProofSystemSettings;
}
interface MsgpackCircuitStats {
    circuit: MsgpackCircuitInput;
    include_gates_per_opcode: boolean;
    settings: MsgpackProofSystemSettings;
}
export interface CircuitVerify {
    verificationKey: Uint8Array;
    publicInputs: Uint256T[];
    proof: Uint256T[];
    settings: ProofSystemSettings;
}
interface MsgpackCircuitVerify {
    verification_key: Uint8Array;
    public_inputs: Uint8Array[];
    proof: Uint8Array[];
    settings: MsgpackProofSystemSettings;
}
export interface CircuitVerifyResponse {
    verified: boolean;
}
interface MsgpackCircuitVerifyResponse {
    verified: boolean;
}
export interface CircuitWriteSolidityVerifier {
    verificationKey: Uint8Array;
    settings: ProofSystemSettings;
}
interface MsgpackCircuitWriteSolidityVerifier {
    verification_key: Uint8Array;
    settings: MsgpackProofSystemSettings;
}
export interface CircuitWriteSolidityVerifierResponse {
    solidityCode: string;
}
interface MsgpackCircuitWriteSolidityVerifierResponse {
    solidity_code: string;
}
export interface ClientIvcAccumulate {
    witness: Uint8Array;
}
interface MsgpackClientIvcAccumulate {
    witness: Uint8Array;
}
export interface ClientIvcAccumulateResponse {
}
interface MsgpackClientIvcAccumulateResponse {
}
export interface ClientIvcCheckPrecomputedVk {
    circuit: CircuitInput;
}
interface MsgpackClientIvcCheckPrecomputedVk {
    circuit: MsgpackCircuitInput;
}
export interface ClientIvcCheckPrecomputedVkResponse {
    valid: boolean;
    actualVk: Uint8Array;
}
interface MsgpackClientIvcCheckPrecomputedVkResponse {
    valid: boolean;
    actual_vk: Uint8Array;
}
export interface ClientIvcComputeIvcVk {
    circuit: CircuitInputNoVK;
}
interface MsgpackClientIvcComputeIvcVk {
    circuit: MsgpackCircuitInputNoVK;
}
export interface ClientIvcComputeIvcVkResponse {
    bytes: Uint8Array;
}
interface MsgpackClientIvcComputeIvcVkResponse {
    bytes: Uint8Array;
}
export interface ClientIvcComputeStandaloneVk {
    circuit: CircuitInputNoVK;
}
interface MsgpackClientIvcComputeStandaloneVk {
    circuit: MsgpackCircuitInputNoVK;
}
export interface ClientIvcComputeStandaloneVkResponse {
    bytes: Uint8Array;
    fields: Fr[];
}
interface MsgpackClientIvcComputeStandaloneVkResponse {
    bytes: Uint8Array;
    fields: Uint8Array[];
}
export interface ClientIvcLoad {
    circuit: CircuitInput;
}
interface MsgpackClientIvcLoad {
    circuit: MsgpackCircuitInput;
}
export interface ClientIvcLoadResponse {
}
interface MsgpackClientIvcLoadResponse {
}
export interface ClientIVCProof {
    megaProof: Fr[];
    goblinProof: GoblinProof;
}
interface MsgpackClientIVCProof {
    mega_proof: Uint8Array[];
    goblin_proof: MsgpackGoblinProof;
}
export interface ClientIvcProve {
}
interface MsgpackClientIvcProve {
}
export interface ClientIvcProveResponse {
    proof: ClientIVCProof;
}
interface MsgpackClientIvcProveResponse {
    proof: MsgpackClientIVCProof;
}
export interface ClientIvcStart {
    numCircuits: number;
}
interface MsgpackClientIvcStart {
    num_circuits: number;
}
export interface ClientIvcStartResponse {
}
interface MsgpackClientIvcStartResponse {
}
export interface ClientIvcStats {
    circuit: CircuitInputNoVK;
    includeGatesPerOpcode: boolean;
}
interface MsgpackClientIvcStats {
    circuit: MsgpackCircuitInputNoVK;
    include_gates_per_opcode: boolean;
}
export interface ClientIvcStatsResponse {
    acirOpcodes: number;
    circuitSize: number;
    gatesPerOpcode: number[];
}
interface MsgpackClientIvcStatsResponse {
    acir_opcodes: number;
    circuit_size: number;
    gates_per_opcode: number[];
}
export interface ClientIvcVerify {
    proof: ClientIVCProof;
    vk: Uint8Array;
}
interface MsgpackClientIvcVerify {
    proof: MsgpackClientIVCProof;
    vk: Uint8Array;
}
export interface ClientIvcVerifyResponse {
    valid: boolean;
}
interface MsgpackClientIvcVerifyResponse {
    valid: boolean;
}
export interface ECCVMProof {
    preIpaProof: Fr[];
    ipaProof: Fr[];
}
interface MsgpackECCVMProof {
    pre_ipa_proof: Uint8Array[];
    ipa_proof: Uint8Array[];
}
export interface EcdsaSecp256k1ComputePublicKey {
    privateKey: Secp256k1Fr;
}
interface MsgpackEcdsaSecp256k1ComputePublicKey {
    private_key: Uint8Array;
}
export interface EcdsaSecp256k1ComputePublicKeyResponse {
    publicKey: AffineElement;
}
interface MsgpackEcdsaSecp256k1ComputePublicKeyResponse {
    public_key: MsgpackAffineElement;
}
export interface EcdsaSecp256k1ConstructSignature {
    message: Uint8Array;
    privateKey: Secp256k1Fr;
}
interface MsgpackEcdsaSecp256k1ConstructSignature {
    message: Uint8Array;
    private_key: Uint8Array;
}
export interface EcdsaSecp256k1ConstructSignatureResponse {
    r: Uint8Array;
    s: Uint8Array;
    v: number;
}
interface MsgpackEcdsaSecp256k1ConstructSignatureResponse {
    r: Uint8Array;
    s: Uint8Array;
    v: number;
}
export interface EcdsaSecp256k1RecoverPublicKey {
    message: Uint8Array;
    r: Uint8Array;
    s: Uint8Array;
    v: number;
}
interface MsgpackEcdsaSecp256k1RecoverPublicKey {
    message: Uint8Array;
    r: Uint8Array;
    s: Uint8Array;
    v: number;
}
export interface EcdsaSecp256k1RecoverPublicKeyResponse {
    publicKey: AffineElement;
}
interface MsgpackEcdsaSecp256k1RecoverPublicKeyResponse {
    public_key: MsgpackAffineElement;
}
export interface EcdsaSecp256k1VerifySignature {
    message: Uint8Array;
    publicKey: AffineElement;
    r: Uint8Array;
    s: Uint8Array;
    v: number;
}
interface MsgpackEcdsaSecp256k1VerifySignature {
    message: Uint8Array;
    public_key: MsgpackAffineElement;
    r: Uint8Array;
    s: Uint8Array;
    v: number;
}
export interface EcdsaSecp256k1VerifySignatureResponse {
    verified: boolean;
}
interface MsgpackEcdsaSecp256k1VerifySignatureResponse {
    verified: boolean;
}
export interface EcdsaSecp256r1ComputePublicKey {
    privateKey: Secp256r1Fr;
}
interface MsgpackEcdsaSecp256r1ComputePublicKey {
    private_key: Uint8Array;
}
export interface EcdsaSecp256r1ComputePublicKeyResponse {
    publicKey: AffineElement;
}
interface MsgpackEcdsaSecp256r1ComputePublicKeyResponse {
    public_key: MsgpackAffineElement;
}
export interface EcdsaSecp256r1ConstructSignature {
    message: Uint8Array;
    privateKey: Secp256r1Fr;
}
interface MsgpackEcdsaSecp256r1ConstructSignature {
    message: Uint8Array;
    private_key: Uint8Array;
}
export interface EcdsaSecp256r1ConstructSignatureResponse {
    r: Uint8Array;
    s: Uint8Array;
    v: number;
}
interface MsgpackEcdsaSecp256r1ConstructSignatureResponse {
    r: Uint8Array;
    s: Uint8Array;
    v: number;
}
export interface EcdsaSecp256r1RecoverPublicKey {
    message: Uint8Array;
    r: Uint8Array;
    s: Uint8Array;
    v: number;
}
interface MsgpackEcdsaSecp256r1RecoverPublicKey {
    message: Uint8Array;
    r: Uint8Array;
    s: Uint8Array;
    v: number;
}
export interface EcdsaSecp256r1RecoverPublicKeyResponse {
    publicKey: AffineElement;
}
interface MsgpackEcdsaSecp256r1RecoverPublicKeyResponse {
    public_key: MsgpackAffineElement;
}
export interface EcdsaSecp256r1VerifySignature {
    message: Uint8Array;
    publicKey: AffineElement;
    r: Uint8Array;
    s: Uint8Array;
    v: number;
}
interface MsgpackEcdsaSecp256r1VerifySignature {
    message: Uint8Array;
    public_key: MsgpackAffineElement;
    r: Uint8Array;
    s: Uint8Array;
    v: number;
}
export interface EcdsaSecp256r1VerifySignatureResponse {
    verified: boolean;
}
interface MsgpackEcdsaSecp256r1VerifySignatureResponse {
    verified: boolean;
}
export interface GoblinProof {
    mergeProof: Fr[];
    eccvmProof: ECCVMProof;
    translatorProof: Fr[];
}
interface MsgpackGoblinProof {
    merge_proof: Uint8Array[];
    eccvm_proof: MsgpackECCVMProof;
    translator_proof: Uint8Array[];
}
export interface GrumpkinAdd {
    pointA: AffineElement;
    pointB: AffineElement;
}
interface MsgpackGrumpkinAdd {
    point_a: MsgpackAffineElement;
    point_b: MsgpackAffineElement;
}
export interface GrumpkinAddResponse {
    point: AffineElement;
}
interface MsgpackGrumpkinAddResponse {
    point: MsgpackAffineElement;
}
export interface GrumpkinBatchMul {
    points: AffineElement[];
    scalar: Fq;
}
interface MsgpackGrumpkinBatchMul {
    points: MsgpackAffineElement[];
    scalar: Uint8Array;
}
export interface GrumpkinBatchMulResponse {
    points: AffineElement[];
}
interface MsgpackGrumpkinBatchMulResponse {
    points: MsgpackAffineElement[];
}
export interface GrumpkinGetRandomFr {
    dummy: number;
}
interface MsgpackGrumpkinGetRandomFr {
    dummy: number;
}
export interface GrumpkinGetRandomFrResponse {
    value: Fr;
}
interface MsgpackGrumpkinGetRandomFrResponse {
    value: Uint8Array;
}
export interface GrumpkinMul {
    point: AffineElement;
    scalar: Fq;
}
interface MsgpackGrumpkinMul {
    point: MsgpackAffineElement;
    scalar: Uint8Array;
}
export interface GrumpkinMulResponse {
    point: AffineElement;
}
interface MsgpackGrumpkinMulResponse {
    point: MsgpackAffineElement;
}
export interface GrumpkinReduce512 {
    input: Uint8Array;
}
interface MsgpackGrumpkinReduce512 {
    input: Uint8Array;
}
export interface GrumpkinReduce512Response {
    value: Fr;
}
interface MsgpackGrumpkinReduce512Response {
    value: Uint8Array;
}
export interface MegaVkAsFields {
    verificationKey: Uint8Array;
}
interface MsgpackMegaVkAsFields {
    verification_key: Uint8Array;
}
export interface MegaVkAsFieldsResponse {
    fields: Fr[];
}
interface MsgpackMegaVkAsFieldsResponse {
    fields: Uint8Array[];
}
export interface PedersenCommit {
    inputs: Fr[];
    hashIndex: number;
}
interface MsgpackPedersenCommit {
    inputs: Uint8Array[];
    hash_index: number;
}
export interface PedersenCommitResponse {
    point: AffineElement;
}
interface MsgpackPedersenCommitResponse {
    point: MsgpackAffineElement;
}
export interface PedersenHash {
    inputs: Fr[];
    hashIndex: number;
}
interface MsgpackPedersenHash {
    inputs: Uint8Array[];
    hash_index: number;
}
export interface PedersenHashBuffer {
    input: Uint8Array;
    hashIndex: number;
}
interface MsgpackPedersenHashBuffer {
    input: Uint8Array;
    hash_index: number;
}
export interface PedersenHashBufferResponse {
    hash: Fr;
}
interface MsgpackPedersenHashBufferResponse {
    hash: Uint8Array;
}
export interface PedersenHashResponse {
    hash: Fr;
}
interface MsgpackPedersenHashResponse {
    hash: Uint8Array;
}
export interface Poseidon2Hash {
    inputs: Fr[];
}
interface MsgpackPoseidon2Hash {
    inputs: Uint8Array[];
}
export interface Poseidon2HashAccumulate {
    inputs: Fr[];
}
interface MsgpackPoseidon2HashAccumulate {
    inputs: Uint8Array[];
}
export interface Poseidon2HashAccumulateResponse {
    hash: Fr;
}
interface MsgpackPoseidon2HashAccumulateResponse {
    hash: Uint8Array;
}
export interface Poseidon2HashResponse {
    hash: Fr;
}
interface MsgpackPoseidon2HashResponse {
    hash: Uint8Array;
}
export interface Poseidon2Permutation {
    inputs: Fr[];
}
interface MsgpackPoseidon2Permutation {
    inputs: Uint8Array[];
}
export interface Poseidon2PermutationResponse {
    outputs: Fr[];
}
interface MsgpackPoseidon2PermutationResponse {
    outputs: Uint8Array[];
}
export interface ProofSystemSettings {
    ipaAccumulation: boolean;
    oracleHashType: string;
    disableZk: boolean;
    optimizedSolidityVerifier: boolean;
}
interface MsgpackProofSystemSettings {
    ipa_accumulation: boolean;
    oracle_hash_type: string;
    disable_zk: boolean;
    optimized_solidity_verifier: boolean;
}
export interface SchnorrComputePublicKey {
    privateKey: Fq;
}
interface MsgpackSchnorrComputePublicKey {
    private_key: Uint8Array;
}
export interface SchnorrComputePublicKeyResponse {
    publicKey: AffineElement;
}
interface MsgpackSchnorrComputePublicKeyResponse {
    public_key: MsgpackAffineElement;
}
export interface SchnorrConstructSignature {
    message: Uint8Array;
    privateKey: Fq;
}
interface MsgpackSchnorrConstructSignature {
    message: Uint8Array;
    private_key: Uint8Array;
}
export interface SchnorrConstructSignatureResponse {
    s: Uint8Array;
    e: Uint8Array;
}
interface MsgpackSchnorrConstructSignatureResponse {
    s: Uint8Array;
    e: Uint8Array;
}
export interface SchnorrVerifySignature {
    message: Uint8Array;
    publicKey: AffineElement;
    s: Uint8Array;
    e: Uint8Array;
}
interface MsgpackSchnorrVerifySignature {
    message: Uint8Array;
    public_key: MsgpackAffineElement;
    s: Uint8Array;
    e: Uint8Array;
}
export interface SchnorrVerifySignatureResponse {
    verified: boolean;
}
interface MsgpackSchnorrVerifySignatureResponse {
    verified: boolean;
}
export interface Secp256k1GetRandomFr {
    dummy: number;
}
interface MsgpackSecp256k1GetRandomFr {
    dummy: number;
}
export interface Secp256k1GetRandomFrResponse {
    value: Secp256k1Fr;
}
interface MsgpackSecp256k1GetRandomFrResponse {
    value: Uint8Array;
}
export interface Secp256k1Mul {
    point: AffineElement;
    scalar: Secp256k1Fr;
}
interface MsgpackSecp256k1Mul {
    point: MsgpackAffineElement;
    scalar: Uint8Array;
}
export interface Secp256k1MulResponse {
    point: AffineElement;
}
interface MsgpackSecp256k1MulResponse {
    point: MsgpackAffineElement;
}
export interface Secp256k1Reduce512 {
    input: Uint8Array;
}
interface MsgpackSecp256k1Reduce512 {
    input: Uint8Array;
}
export interface Secp256k1Reduce512Response {
    value: Secp256k1Fr;
}
interface MsgpackSecp256k1Reduce512Response {
    value: Uint8Array;
}
export interface Shutdown {
}
interface MsgpackShutdown {
}
export interface ShutdownResponse {
}
interface MsgpackShutdownResponse {
}
export interface SrsInitGrumpkinSrs {
    pointsBuf: Uint8Array;
    numPoints: number;
}
interface MsgpackSrsInitGrumpkinSrs {
    points_buf: Uint8Array;
    num_points: number;
}
export interface SrsInitGrumpkinSrsResponse {
    dummy: number;
}
interface MsgpackSrsInitGrumpkinSrsResponse {
    dummy: number;
}
export interface SrsInitSrs {
    pointsBuf: Uint8Array;
    numPoints: number;
    g2Point: Uint8Array;
}
interface MsgpackSrsInitSrs {
    points_buf: Uint8Array;
    num_points: number;
    g2_point: Uint8Array;
}
export interface SrsInitSrsResponse {
    dummy: number;
}
interface MsgpackSrsInitSrsResponse {
    dummy: number;
}
export interface VkAsFields {
    verificationKey: Uint8Array;
}
interface MsgpackVkAsFields {
    verification_key: Uint8Array;
}
export interface VkAsFieldsResponse {
    fields: Fr[];
}
interface MsgpackVkAsFieldsResponse {
    fields: Uint8Array[];
}
export interface AesDecrypt {
    ciphertext: Uint8Array;
    iv: Uint8Array;
    key: Uint8Array;
    length: number;
}
interface MsgpackAesDecrypt {
    ciphertext: Uint8Array;
    iv: Uint8Array;
    key: Uint8Array;
    length: number;
}
export interface AesDecryptResponse {
    plaintext: Uint8Array;
}
interface MsgpackAesDecryptResponse {
    plaintext: Uint8Array;
}
export interface AesEncrypt {
    plaintext: Uint8Array;
    iv: Uint8Array;
    key: Uint8Array;
    length: number;
}
interface MsgpackAesEncrypt {
    plaintext: Uint8Array;
    iv: Uint8Array;
    key: Uint8Array;
    length: number;
}
export interface AesEncryptResponse {
    ciphertext: Uint8Array;
}
interface MsgpackAesEncryptResponse {
    ciphertext: Uint8Array;
}
export interface AffineElement {
    x: Fr;
    y: Fr;
}
interface MsgpackAffineElement {
    x: Uint8Array;
    y: Uint8Array;
}
export interface Blake2s {
    data: Uint8Array;
}
interface MsgpackBlake2s {
    data: Uint8Array;
}
export interface Blake2sResponse {
    hash: Uint8Array;
}
interface MsgpackBlake2sResponse {
    hash: Uint8Array;
}
export interface Blake2sToField {
    data: Uint8Array;
}
interface MsgpackBlake2sToField {
    data: Uint8Array;
}
export interface Blake2sToFieldResponse {
    field: Fr;
}
interface MsgpackBlake2sToFieldResponse {
    field: Uint8Array;
}
export interface Bn254FrSqrt {
    input: Fr;
}
interface MsgpackBn254FrSqrt {
    input: Uint8Array;
}
export interface Bn254FrSqrtResponse {
    isSquareRoot: boolean;
    value: Fr;
}
interface MsgpackBn254FrSqrtResponse {
    is_square_root: boolean;
    value: Uint8Array;
}
export interface CircuitComputeVk {
    circuit: CircuitInputNoVK;
    settings: ProofSystemSettings;
}
interface MsgpackCircuitComputeVk {
    circuit: MsgpackCircuitInputNoVK;
    settings: MsgpackProofSystemSettings;
}
export interface CircuitComputeVkResponse {
    bytes: Uint8Array;
    fields: Uint256T[];
    hash: Uint8Array;
}
interface MsgpackCircuitComputeVkResponse {
    bytes: Uint8Array;
    fields: Uint8Array[];
    hash: Uint8Array;
}
export interface CircuitInfoResponse {
    numGates: number;
    numGatesDyadic: number;
    numAcirOpcodes: number;
    gatesPerOpcode: number[];
}
interface MsgpackCircuitInfoResponse {
    num_gates: number;
    num_gates_dyadic: number;
    num_acir_opcodes: number;
    gates_per_opcode: number[];
}
export interface CircuitInput {
    name: string;
    bytecode: Uint8Array;
    verificationKey: Uint8Array;
}
interface MsgpackCircuitInput {
    name: string;
    bytecode: Uint8Array;
    verification_key: Uint8Array;
}
export interface CircuitInputNoVK {
    name: string;
    bytecode: Uint8Array;
}
interface MsgpackCircuitInputNoVK {
    name: string;
    bytecode: Uint8Array;
}
export interface CircuitProve {
    circuit: CircuitInput;
    witness: Uint8Array;
    settings: ProofSystemSettings;
}
interface MsgpackCircuitProve {
    circuit: MsgpackCircuitInput;
    witness: Uint8Array;
    settings: MsgpackProofSystemSettings;
}
export interface CircuitProveResponse {
    publicInputs: Uint256T[];
    proof: Uint256T[];
    vk: CircuitComputeVkResponse;
}
interface MsgpackCircuitProveResponse {
    public_inputs: Uint8Array[];
    proof: Uint8Array[];
    vk: MsgpackCircuitComputeVkResponse;
}
export interface CircuitStats {
    circuit: CircuitInput;
    includeGatesPerOpcode: boolean;
    settings: ProofSystemSettings;
}
interface MsgpackCircuitStats {
    circuit: MsgpackCircuitInput;
    include_gates_per_opcode: boolean;
    settings: MsgpackProofSystemSettings;
}
export interface CircuitVerify {
    verificationKey: Uint8Array;
    publicInputs: Uint256T[];
    proof: Uint256T[];
    settings: ProofSystemSettings;
}
interface MsgpackCircuitVerify {
    verification_key: Uint8Array;
    public_inputs: Uint8Array[];
    proof: Uint8Array[];
    settings: MsgpackProofSystemSettings;
}
export interface CircuitVerifyResponse {
    verified: boolean;
}
interface MsgpackCircuitVerifyResponse {
    verified: boolean;
}
export interface CircuitWriteSolidityVerifier {
    verificationKey: Uint8Array;
    settings: ProofSystemSettings;
}
interface MsgpackCircuitWriteSolidityVerifier {
    verification_key: Uint8Array;
    settings: MsgpackProofSystemSettings;
}
export interface CircuitWriteSolidityVerifierResponse {
    solidityCode: string;
}
interface MsgpackCircuitWriteSolidityVerifierResponse {
    solidity_code: string;
}
export interface ClientIvcAccumulate {
    witness: Uint8Array;
}
interface MsgpackClientIvcAccumulate {
    witness: Uint8Array;
}
export interface ClientIvcAccumulateResponse {
}
interface MsgpackClientIvcAccumulateResponse {
}
export interface ClientIvcCheckPrecomputedVk {
    circuit: CircuitInput;
}
interface MsgpackClientIvcCheckPrecomputedVk {
    circuit: MsgpackCircuitInput;
}
export interface ClientIvcCheckPrecomputedVkResponse {
    valid: boolean;
    actualVk: Uint8Array;
}
interface MsgpackClientIvcCheckPrecomputedVkResponse {
    valid: boolean;
    actual_vk: Uint8Array;
}
export interface ClientIvcComputeIvcVk {
    circuit: CircuitInputNoVK;
}
interface MsgpackClientIvcComputeIvcVk {
    circuit: MsgpackCircuitInputNoVK;
}
export interface ClientIvcComputeIvcVkResponse {
    bytes: Uint8Array;
}
interface MsgpackClientIvcComputeIvcVkResponse {
    bytes: Uint8Array;
}
export interface ClientIvcComputeStandaloneVk {
    circuit: CircuitInputNoVK;
}
interface MsgpackClientIvcComputeStandaloneVk {
    circuit: MsgpackCircuitInputNoVK;
}
export interface ClientIvcComputeStandaloneVkResponse {
    bytes: Uint8Array;
    fields: Fr[];
}
interface MsgpackClientIvcComputeStandaloneVkResponse {
    bytes: Uint8Array;
    fields: Uint8Array[];
}
export interface ClientIvcLoad {
    circuit: CircuitInput;
}
interface MsgpackClientIvcLoad {
    circuit: MsgpackCircuitInput;
}
export interface ClientIvcLoadResponse {
}
interface MsgpackClientIvcLoadResponse {
}
export interface ClientIVCProof {
    megaProof: Fr[];
    goblinProof: GoblinProof;
}
interface MsgpackClientIVCProof {
    mega_proof: Uint8Array[];
    goblin_proof: MsgpackGoblinProof;
}
export interface ClientIvcProve {
}
interface MsgpackClientIvcProve {
}
export interface ClientIvcProveResponse {
    proof: ClientIVCProof;
}
interface MsgpackClientIvcProveResponse {
    proof: MsgpackClientIVCProof;
}
export interface ClientIvcStart {
    numCircuits: number;
}
interface MsgpackClientIvcStart {
    num_circuits: number;
}
export interface ClientIvcStartResponse {
}
interface MsgpackClientIvcStartResponse {
}
export interface ClientIvcStats {
    circuit: CircuitInputNoVK;
    includeGatesPerOpcode: boolean;
}
interface MsgpackClientIvcStats {
    circuit: MsgpackCircuitInputNoVK;
    include_gates_per_opcode: boolean;
}
export interface ClientIvcStatsResponse {
    acirOpcodes: number;
    circuitSize: number;
    gatesPerOpcode: number[];
}
interface MsgpackClientIvcStatsResponse {
    acir_opcodes: number;
    circuit_size: number;
    gates_per_opcode: number[];
}
export interface ClientIvcVerify {
    proof: ClientIVCProof;
    vk: Uint8Array;
}
interface MsgpackClientIvcVerify {
    proof: MsgpackClientIVCProof;
    vk: Uint8Array;
}
export interface ClientIvcVerifyResponse {
    valid: boolean;
}
interface MsgpackClientIvcVerifyResponse {
    valid: boolean;
}
export interface ECCVMProof {
    preIpaProof: Fr[];
    ipaProof: Fr[];
}
interface MsgpackECCVMProof {
    pre_ipa_proof: Uint8Array[];
    ipa_proof: Uint8Array[];
}
export interface EcdsaSecp256k1ComputePublicKey {
    privateKey: Secp256k1Fr;
}
interface MsgpackEcdsaSecp256k1ComputePublicKey {
    private_key: Uint8Array;
}
export interface EcdsaSecp256k1ComputePublicKeyResponse {
    publicKey: AffineElement;
}
interface MsgpackEcdsaSecp256k1ComputePublicKeyResponse {
    public_key: MsgpackAffineElement;
}
export interface EcdsaSecp256k1ConstructSignature {
    message: Uint8Array;
    privateKey: Secp256k1Fr;
}
interface MsgpackEcdsaSecp256k1ConstructSignature {
    message: Uint8Array;
    private_key: Uint8Array;
}
export interface EcdsaSecp256k1ConstructSignatureResponse {
    r: Uint8Array;
    s: Uint8Array;
    v: number;
}
interface MsgpackEcdsaSecp256k1ConstructSignatureResponse {
    r: Uint8Array;
    s: Uint8Array;
    v: number;
}
export interface EcdsaSecp256k1RecoverPublicKey {
    message: Uint8Array;
    r: Uint8Array;
    s: Uint8Array;
    v: number;
}
interface MsgpackEcdsaSecp256k1RecoverPublicKey {
    message: Uint8Array;
    r: Uint8Array;
    s: Uint8Array;
    v: number;
}
export interface EcdsaSecp256k1RecoverPublicKeyResponse {
    publicKey: AffineElement;
}
interface MsgpackEcdsaSecp256k1RecoverPublicKeyResponse {
    public_key: MsgpackAffineElement;
}
export interface EcdsaSecp256k1VerifySignature {
    message: Uint8Array;
    publicKey: AffineElement;
    r: Uint8Array;
    s: Uint8Array;
    v: number;
}
interface MsgpackEcdsaSecp256k1VerifySignature {
    message: Uint8Array;
    public_key: MsgpackAffineElement;
    r: Uint8Array;
    s: Uint8Array;
    v: number;
}
export interface EcdsaSecp256k1VerifySignatureResponse {
    verified: boolean;
}
interface MsgpackEcdsaSecp256k1VerifySignatureResponse {
    verified: boolean;
}
export interface EcdsaSecp256r1ComputePublicKey {
    privateKey: Secp256r1Fr;
}
interface MsgpackEcdsaSecp256r1ComputePublicKey {
    private_key: Uint8Array;
}
export interface EcdsaSecp256r1ComputePublicKeyResponse {
    publicKey: AffineElement;
}
interface MsgpackEcdsaSecp256r1ComputePublicKeyResponse {
    public_key: MsgpackAffineElement;
}
export interface EcdsaSecp256r1ConstructSignature {
    message: Uint8Array;
    privateKey: Secp256r1Fr;
}
interface MsgpackEcdsaSecp256r1ConstructSignature {
    message: Uint8Array;
    private_key: Uint8Array;
}
export interface EcdsaSecp256r1ConstructSignatureResponse {
    r: Uint8Array;
    s: Uint8Array;
    v: number;
}
interface MsgpackEcdsaSecp256r1ConstructSignatureResponse {
    r: Uint8Array;
    s: Uint8Array;
    v: number;
}
export interface EcdsaSecp256r1RecoverPublicKey {
    message: Uint8Array;
    r: Uint8Array;
    s: Uint8Array;
    v: number;
}
interface MsgpackEcdsaSecp256r1RecoverPublicKey {
    message: Uint8Array;
    r: Uint8Array;
    s: Uint8Array;
    v: number;
}
export interface EcdsaSecp256r1RecoverPublicKeyResponse {
    publicKey: AffineElement;
}
interface MsgpackEcdsaSecp256r1RecoverPublicKeyResponse {
    public_key: MsgpackAffineElement;
}
export interface EcdsaSecp256r1VerifySignature {
    message: Uint8Array;
    publicKey: AffineElement;
    r: Uint8Array;
    s: Uint8Array;
    v: number;
}
interface MsgpackEcdsaSecp256r1VerifySignature {
    message: Uint8Array;
    public_key: MsgpackAffineElement;
    r: Uint8Array;
    s: Uint8Array;
    v: number;
}
export interface EcdsaSecp256r1VerifySignatureResponse {
    verified: boolean;
}
interface MsgpackEcdsaSecp256r1VerifySignatureResponse {
    verified: boolean;
}
export interface GoblinProof {
    mergeProof: Fr[];
    eccvmProof: ECCVMProof;
    translatorProof: Fr[];
}
interface MsgpackGoblinProof {
    merge_proof: Uint8Array[];
    eccvm_proof: MsgpackECCVMProof;
    translator_proof: Uint8Array[];
}
export interface GrumpkinAdd {
    pointA: AffineElement;
    pointB: AffineElement;
}
interface MsgpackGrumpkinAdd {
    point_a: MsgpackAffineElement;
    point_b: MsgpackAffineElement;
}
export interface GrumpkinAddResponse {
    point: AffineElement;
}
interface MsgpackGrumpkinAddResponse {
    point: MsgpackAffineElement;
}
export interface GrumpkinBatchMul {
    points: AffineElement[];
    scalar: Fq;
}
interface MsgpackGrumpkinBatchMul {
    points: MsgpackAffineElement[];
    scalar: Uint8Array;
}
export interface GrumpkinBatchMulResponse {
    points: AffineElement[];
}
interface MsgpackGrumpkinBatchMulResponse {
    points: MsgpackAffineElement[];
}
export interface GrumpkinGetRandomFr {
    dummy: number;
}
interface MsgpackGrumpkinGetRandomFr {
    dummy: number;
}
export interface GrumpkinGetRandomFrResponse {
    value: Fr;
}
interface MsgpackGrumpkinGetRandomFrResponse {
    value: Uint8Array;
}
export interface GrumpkinMul {
    point: AffineElement;
    scalar: Fq;
}
interface MsgpackGrumpkinMul {
    point: MsgpackAffineElement;
    scalar: Uint8Array;
}
export interface GrumpkinMulResponse {
    point: AffineElement;
}
interface MsgpackGrumpkinMulResponse {
    point: MsgpackAffineElement;
}
export interface GrumpkinReduce512 {
    input: Uint8Array;
}
interface MsgpackGrumpkinReduce512 {
    input: Uint8Array;
}
export interface GrumpkinReduce512Response {
    value: Fr;
}
interface MsgpackGrumpkinReduce512Response {
    value: Uint8Array;
}
export interface MegaVkAsFields {
    verificationKey: Uint8Array;
}
interface MsgpackMegaVkAsFields {
    verification_key: Uint8Array;
}
export interface MegaVkAsFieldsResponse {
    fields: Fr[];
}
interface MsgpackMegaVkAsFieldsResponse {
    fields: Uint8Array[];
}
export interface PedersenCommit {
    inputs: Fr[];
    hashIndex: number;
}
interface MsgpackPedersenCommit {
    inputs: Uint8Array[];
    hash_index: number;
}
export interface PedersenCommitResponse {
    point: AffineElement;
}
interface MsgpackPedersenCommitResponse {
    point: MsgpackAffineElement;
}
export interface PedersenHash {
    inputs: Fr[];
    hashIndex: number;
}
interface MsgpackPedersenHash {
    inputs: Uint8Array[];
    hash_index: number;
}
export interface PedersenHashBuffer {
    input: Uint8Array;
    hashIndex: number;
}
interface MsgpackPedersenHashBuffer {
    input: Uint8Array;
    hash_index: number;
}
export interface PedersenHashBufferResponse {
    hash: Fr;
}
interface MsgpackPedersenHashBufferResponse {
    hash: Uint8Array;
}
export interface PedersenHashResponse {
    hash: Fr;
}
interface MsgpackPedersenHashResponse {
    hash: Uint8Array;
}
export interface Poseidon2Hash {
    inputs: Fr[];
}
interface MsgpackPoseidon2Hash {
    inputs: Uint8Array[];
}
export interface Poseidon2HashAccumulate {
    inputs: Fr[];
}
interface MsgpackPoseidon2HashAccumulate {
    inputs: Uint8Array[];
}
export interface Poseidon2HashAccumulateResponse {
    hash: Fr;
}
interface MsgpackPoseidon2HashAccumulateResponse {
    hash: Uint8Array;
}
export interface Poseidon2HashResponse {
    hash: Fr;
}
interface MsgpackPoseidon2HashResponse {
    hash: Uint8Array;
}
export interface Poseidon2Permutation {
    inputs: Fr[];
}
interface MsgpackPoseidon2Permutation {
    inputs: Uint8Array[];
}
export interface Poseidon2PermutationResponse {
    outputs: Fr[];
}
interface MsgpackPoseidon2PermutationResponse {
    outputs: Uint8Array[];
}
export interface ProofSystemSettings {
    ipaAccumulation: boolean;
    oracleHashType: string;
    disableZk: boolean;
    optimizedSolidityVerifier: boolean;
}
interface MsgpackProofSystemSettings {
    ipa_accumulation: boolean;
    oracle_hash_type: string;
    disable_zk: boolean;
    optimized_solidity_verifier: boolean;
}
export interface SchnorrComputePublicKey {
    privateKey: Fq;
}
interface MsgpackSchnorrComputePublicKey {
    private_key: Uint8Array;
}
export interface SchnorrComputePublicKeyResponse {
    publicKey: AffineElement;
}
interface MsgpackSchnorrComputePublicKeyResponse {
    public_key: MsgpackAffineElement;
}
export interface SchnorrConstructSignature {
    message: Uint8Array;
    privateKey: Fq;
}
interface MsgpackSchnorrConstructSignature {
    message: Uint8Array;
    private_key: Uint8Array;
}
export interface SchnorrConstructSignatureResponse {
    s: Uint8Array;
    e: Uint8Array;
}
interface MsgpackSchnorrConstructSignatureResponse {
    s: Uint8Array;
    e: Uint8Array;
}
export interface SchnorrVerifySignature {
    message: Uint8Array;
    publicKey: AffineElement;
    s: Uint8Array;
    e: Uint8Array;
}
interface MsgpackSchnorrVerifySignature {
    message: Uint8Array;
    public_key: MsgpackAffineElement;
    s: Uint8Array;
    e: Uint8Array;
}
export interface SchnorrVerifySignatureResponse {
    verified: boolean;
}
interface MsgpackSchnorrVerifySignatureResponse {
    verified: boolean;
}
export interface Secp256k1GetRandomFr {
    dummy: number;
}
interface MsgpackSecp256k1GetRandomFr {
    dummy: number;
}
export interface Secp256k1GetRandomFrResponse {
    value: Secp256k1Fr;
}
interface MsgpackSecp256k1GetRandomFrResponse {
    value: Uint8Array;
}
export interface Secp256k1Mul {
    point: AffineElement;
    scalar: Secp256k1Fr;
}
interface MsgpackSecp256k1Mul {
    point: MsgpackAffineElement;
    scalar: Uint8Array;
}
export interface Secp256k1MulResponse {
    point: AffineElement;
}
interface MsgpackSecp256k1MulResponse {
    point: MsgpackAffineElement;
}
export interface Secp256k1Reduce512 {
    input: Uint8Array;
}
interface MsgpackSecp256k1Reduce512 {
    input: Uint8Array;
}
export interface Secp256k1Reduce512Response {
    value: Secp256k1Fr;
}
interface MsgpackSecp256k1Reduce512Response {
    value: Uint8Array;
}
export interface Shutdown {
}
interface MsgpackShutdown {
}
export interface ShutdownResponse {
}
interface MsgpackShutdownResponse {
}
export interface SrsInitGrumpkinSrs {
    pointsBuf: Uint8Array;
    numPoints: number;
}
interface MsgpackSrsInitGrumpkinSrs {
    points_buf: Uint8Array;
    num_points: number;
}
export interface SrsInitGrumpkinSrsResponse {
    dummy: number;
}
interface MsgpackSrsInitGrumpkinSrsResponse {
    dummy: number;
}
export interface SrsInitSrs {
    pointsBuf: Uint8Array;
    numPoints: number;
    g2Point: Uint8Array;
}
interface MsgpackSrsInitSrs {
    points_buf: Uint8Array;
    num_points: number;
    g2_point: Uint8Array;
}
export interface SrsInitSrsResponse {
    dummy: number;
}
interface MsgpackSrsInitSrsResponse {
    dummy: number;
}
export interface VkAsFields {
    verificationKey: Uint8Array;
}
interface MsgpackVkAsFields {
    verification_key: Uint8Array;
}
export interface VkAsFieldsResponse {
    fields: Fr[];
}
interface MsgpackVkAsFieldsResponse {
    fields: Uint8Array[];
}
export declare function toAesDecrypt(o: MsgpackAesDecrypt): AesDecrypt;
export declare function fromAesDecrypt(o: AesDecrypt): MsgpackAesDecrypt;
export declare function toAesDecryptResponse(o: MsgpackAesDecryptResponse): AesDecryptResponse;
export declare function fromAesDecryptResponse(o: AesDecryptResponse): MsgpackAesDecryptResponse;
export declare function toAesEncrypt(o: MsgpackAesEncrypt): AesEncrypt;
export declare function fromAesEncrypt(o: AesEncrypt): MsgpackAesEncrypt;
export declare function toAesEncryptResponse(o: MsgpackAesEncryptResponse): AesEncryptResponse;
export declare function fromAesEncryptResponse(o: AesEncryptResponse): MsgpackAesEncryptResponse;
export declare function toAffineElement(o: MsgpackAffineElement): AffineElement;
export declare function fromAffineElement(o: AffineElement): MsgpackAffineElement;
export declare function toBlake2s(o: MsgpackBlake2s): Blake2s;
export declare function fromBlake2s(o: Blake2s): MsgpackBlake2s;
export declare function toBlake2sResponse(o: MsgpackBlake2sResponse): Blake2sResponse;
export declare function fromBlake2sResponse(o: Blake2sResponse): MsgpackBlake2sResponse;
export declare function toBlake2sToField(o: MsgpackBlake2sToField): Blake2sToField;
export declare function fromBlake2sToField(o: Blake2sToField): MsgpackBlake2sToField;
export declare function toBlake2sToFieldResponse(o: MsgpackBlake2sToFieldResponse): Blake2sToFieldResponse;
export declare function fromBlake2sToFieldResponse(o: Blake2sToFieldResponse): MsgpackBlake2sToFieldResponse;
export declare function toBn254FrSqrt(o: MsgpackBn254FrSqrt): Bn254FrSqrt;
export declare function fromBn254FrSqrt(o: Bn254FrSqrt): MsgpackBn254FrSqrt;
export declare function toBn254FrSqrtResponse(o: MsgpackBn254FrSqrtResponse): Bn254FrSqrtResponse;
export declare function fromBn254FrSqrtResponse(o: Bn254FrSqrtResponse): MsgpackBn254FrSqrtResponse;
export declare function toCircuitComputeVk(o: MsgpackCircuitComputeVk): CircuitComputeVk;
export declare function fromCircuitComputeVk(o: CircuitComputeVk): MsgpackCircuitComputeVk;
export declare function toCircuitComputeVkResponse(o: MsgpackCircuitComputeVkResponse): CircuitComputeVkResponse;
export declare function fromCircuitComputeVkResponse(o: CircuitComputeVkResponse): MsgpackCircuitComputeVkResponse;
export declare function toCircuitInfoResponse(o: MsgpackCircuitInfoResponse): CircuitInfoResponse;
export declare function fromCircuitInfoResponse(o: CircuitInfoResponse): MsgpackCircuitInfoResponse;
export declare function toCircuitInput(o: MsgpackCircuitInput): CircuitInput;
export declare function fromCircuitInput(o: CircuitInput): MsgpackCircuitInput;
export declare function toCircuitInputNoVK(o: MsgpackCircuitInputNoVK): CircuitInputNoVK;
export declare function fromCircuitInputNoVK(o: CircuitInputNoVK): MsgpackCircuitInputNoVK;
export declare function toCircuitProve(o: MsgpackCircuitProve): CircuitProve;
export declare function fromCircuitProve(o: CircuitProve): MsgpackCircuitProve;
export declare function toCircuitProveResponse(o: MsgpackCircuitProveResponse): CircuitProveResponse;
export declare function fromCircuitProveResponse(o: CircuitProveResponse): MsgpackCircuitProveResponse;
export declare function toCircuitStats(o: MsgpackCircuitStats): CircuitStats;
export declare function fromCircuitStats(o: CircuitStats): MsgpackCircuitStats;
export declare function toCircuitVerify(o: MsgpackCircuitVerify): CircuitVerify;
export declare function fromCircuitVerify(o: CircuitVerify): MsgpackCircuitVerify;
export declare function toCircuitVerifyResponse(o: MsgpackCircuitVerifyResponse): CircuitVerifyResponse;
export declare function fromCircuitVerifyResponse(o: CircuitVerifyResponse): MsgpackCircuitVerifyResponse;
export declare function toCircuitWriteSolidityVerifier(o: MsgpackCircuitWriteSolidityVerifier): CircuitWriteSolidityVerifier;
export declare function fromCircuitWriteSolidityVerifier(o: CircuitWriteSolidityVerifier): MsgpackCircuitWriteSolidityVerifier;
export declare function toCircuitWriteSolidityVerifierResponse(o: MsgpackCircuitWriteSolidityVerifierResponse): CircuitWriteSolidityVerifierResponse;
export declare function fromCircuitWriteSolidityVerifierResponse(o: CircuitWriteSolidityVerifierResponse): MsgpackCircuitWriteSolidityVerifierResponse;
export declare function toClientIvcAccumulate(o: MsgpackClientIvcAccumulate): ClientIvcAccumulate;
export declare function fromClientIvcAccumulate(o: ClientIvcAccumulate): MsgpackClientIvcAccumulate;
export declare function toClientIvcAccumulateResponse(o: MsgpackClientIvcAccumulateResponse): ClientIvcAccumulateResponse;
export declare function fromClientIvcAccumulateResponse(o: ClientIvcAccumulateResponse): MsgpackClientIvcAccumulateResponse;
export declare function toClientIvcCheckPrecomputedVk(o: MsgpackClientIvcCheckPrecomputedVk): ClientIvcCheckPrecomputedVk;
export declare function fromClientIvcCheckPrecomputedVk(o: ClientIvcCheckPrecomputedVk): MsgpackClientIvcCheckPrecomputedVk;
export declare function toClientIvcCheckPrecomputedVkResponse(o: MsgpackClientIvcCheckPrecomputedVkResponse): ClientIvcCheckPrecomputedVkResponse;
export declare function fromClientIvcCheckPrecomputedVkResponse(o: ClientIvcCheckPrecomputedVkResponse): MsgpackClientIvcCheckPrecomputedVkResponse;
export declare function toClientIvcComputeIvcVk(o: MsgpackClientIvcComputeIvcVk): ClientIvcComputeIvcVk;
export declare function fromClientIvcComputeIvcVk(o: ClientIvcComputeIvcVk): MsgpackClientIvcComputeIvcVk;
export declare function toClientIvcComputeIvcVkResponse(o: MsgpackClientIvcComputeIvcVkResponse): ClientIvcComputeIvcVkResponse;
export declare function fromClientIvcComputeIvcVkResponse(o: ClientIvcComputeIvcVkResponse): MsgpackClientIvcComputeIvcVkResponse;
export declare function toClientIvcComputeStandaloneVk(o: MsgpackClientIvcComputeStandaloneVk): ClientIvcComputeStandaloneVk;
export declare function fromClientIvcComputeStandaloneVk(o: ClientIvcComputeStandaloneVk): MsgpackClientIvcComputeStandaloneVk;
export declare function toClientIvcComputeStandaloneVkResponse(o: MsgpackClientIvcComputeStandaloneVkResponse): ClientIvcComputeStandaloneVkResponse;
export declare function fromClientIvcComputeStandaloneVkResponse(o: ClientIvcComputeStandaloneVkResponse): MsgpackClientIvcComputeStandaloneVkResponse;
export declare function toClientIvcLoad(o: MsgpackClientIvcLoad): ClientIvcLoad;
export declare function fromClientIvcLoad(o: ClientIvcLoad): MsgpackClientIvcLoad;
export declare function toClientIvcLoadResponse(o: MsgpackClientIvcLoadResponse): ClientIvcLoadResponse;
export declare function fromClientIvcLoadResponse(o: ClientIvcLoadResponse): MsgpackClientIvcLoadResponse;
export declare function toClientIVCProof(o: MsgpackClientIVCProof): ClientIVCProof;
export declare function fromClientIVCProof(o: ClientIVCProof): MsgpackClientIVCProof;
export declare function toClientIvcProve(o: MsgpackClientIvcProve): ClientIvcProve;
export declare function fromClientIvcProve(o: ClientIvcProve): MsgpackClientIvcProve;
export declare function toClientIvcProveResponse(o: MsgpackClientIvcProveResponse): ClientIvcProveResponse;
export declare function fromClientIvcProveResponse(o: ClientIvcProveResponse): MsgpackClientIvcProveResponse;
export declare function toClientIvcStart(o: MsgpackClientIvcStart): ClientIvcStart;
export declare function fromClientIvcStart(o: ClientIvcStart): MsgpackClientIvcStart;
export declare function toClientIvcStartResponse(o: MsgpackClientIvcStartResponse): ClientIvcStartResponse;
export declare function fromClientIvcStartResponse(o: ClientIvcStartResponse): MsgpackClientIvcStartResponse;
export declare function toClientIvcStats(o: MsgpackClientIvcStats): ClientIvcStats;
export declare function fromClientIvcStats(o: ClientIvcStats): MsgpackClientIvcStats;
export declare function toClientIvcStatsResponse(o: MsgpackClientIvcStatsResponse): ClientIvcStatsResponse;
export declare function fromClientIvcStatsResponse(o: ClientIvcStatsResponse): MsgpackClientIvcStatsResponse;
export declare function toClientIvcVerify(o: MsgpackClientIvcVerify): ClientIvcVerify;
export declare function fromClientIvcVerify(o: ClientIvcVerify): MsgpackClientIvcVerify;
export declare function toClientIvcVerifyResponse(o: MsgpackClientIvcVerifyResponse): ClientIvcVerifyResponse;
export declare function fromClientIvcVerifyResponse(o: ClientIvcVerifyResponse): MsgpackClientIvcVerifyResponse;
export declare function toECCVMProof(o: MsgpackECCVMProof): ECCVMProof;
export declare function fromECCVMProof(o: ECCVMProof): MsgpackECCVMProof;
export declare function toEcdsaSecp256k1ComputePublicKey(o: MsgpackEcdsaSecp256k1ComputePublicKey): EcdsaSecp256k1ComputePublicKey;
export declare function fromEcdsaSecp256k1ComputePublicKey(o: EcdsaSecp256k1ComputePublicKey): MsgpackEcdsaSecp256k1ComputePublicKey;
export declare function toEcdsaSecp256k1ComputePublicKeyResponse(o: MsgpackEcdsaSecp256k1ComputePublicKeyResponse): EcdsaSecp256k1ComputePublicKeyResponse;
export declare function fromEcdsaSecp256k1ComputePublicKeyResponse(o: EcdsaSecp256k1ComputePublicKeyResponse): MsgpackEcdsaSecp256k1ComputePublicKeyResponse;
export declare function toEcdsaSecp256k1ConstructSignature(o: MsgpackEcdsaSecp256k1ConstructSignature): EcdsaSecp256k1ConstructSignature;
export declare function fromEcdsaSecp256k1ConstructSignature(o: EcdsaSecp256k1ConstructSignature): MsgpackEcdsaSecp256k1ConstructSignature;
export declare function toEcdsaSecp256k1ConstructSignatureResponse(o: MsgpackEcdsaSecp256k1ConstructSignatureResponse): EcdsaSecp256k1ConstructSignatureResponse;
export declare function fromEcdsaSecp256k1ConstructSignatureResponse(o: EcdsaSecp256k1ConstructSignatureResponse): MsgpackEcdsaSecp256k1ConstructSignatureResponse;
export declare function toEcdsaSecp256k1RecoverPublicKey(o: MsgpackEcdsaSecp256k1RecoverPublicKey): EcdsaSecp256k1RecoverPublicKey;
export declare function fromEcdsaSecp256k1RecoverPublicKey(o: EcdsaSecp256k1RecoverPublicKey): MsgpackEcdsaSecp256k1RecoverPublicKey;
export declare function toEcdsaSecp256k1RecoverPublicKeyResponse(o: MsgpackEcdsaSecp256k1RecoverPublicKeyResponse): EcdsaSecp256k1RecoverPublicKeyResponse;
export declare function fromEcdsaSecp256k1RecoverPublicKeyResponse(o: EcdsaSecp256k1RecoverPublicKeyResponse): MsgpackEcdsaSecp256k1RecoverPublicKeyResponse;
export declare function toEcdsaSecp256k1VerifySignature(o: MsgpackEcdsaSecp256k1VerifySignature): EcdsaSecp256k1VerifySignature;
export declare function fromEcdsaSecp256k1VerifySignature(o: EcdsaSecp256k1VerifySignature): MsgpackEcdsaSecp256k1VerifySignature;
export declare function toEcdsaSecp256k1VerifySignatureResponse(o: MsgpackEcdsaSecp256k1VerifySignatureResponse): EcdsaSecp256k1VerifySignatureResponse;
export declare function fromEcdsaSecp256k1VerifySignatureResponse(o: EcdsaSecp256k1VerifySignatureResponse): MsgpackEcdsaSecp256k1VerifySignatureResponse;
export declare function toEcdsaSecp256r1ComputePublicKey(o: MsgpackEcdsaSecp256r1ComputePublicKey): EcdsaSecp256r1ComputePublicKey;
export declare function fromEcdsaSecp256r1ComputePublicKey(o: EcdsaSecp256r1ComputePublicKey): MsgpackEcdsaSecp256r1ComputePublicKey;
export declare function toEcdsaSecp256r1ComputePublicKeyResponse(o: MsgpackEcdsaSecp256r1ComputePublicKeyResponse): EcdsaSecp256r1ComputePublicKeyResponse;
export declare function fromEcdsaSecp256r1ComputePublicKeyResponse(o: EcdsaSecp256r1ComputePublicKeyResponse): MsgpackEcdsaSecp256r1ComputePublicKeyResponse;
export declare function toEcdsaSecp256r1ConstructSignature(o: MsgpackEcdsaSecp256r1ConstructSignature): EcdsaSecp256r1ConstructSignature;
export declare function fromEcdsaSecp256r1ConstructSignature(o: EcdsaSecp256r1ConstructSignature): MsgpackEcdsaSecp256r1ConstructSignature;
export declare function toEcdsaSecp256r1ConstructSignatureResponse(o: MsgpackEcdsaSecp256r1ConstructSignatureResponse): EcdsaSecp256r1ConstructSignatureResponse;
export declare function fromEcdsaSecp256r1ConstructSignatureResponse(o: EcdsaSecp256r1ConstructSignatureResponse): MsgpackEcdsaSecp256r1ConstructSignatureResponse;
export declare function toEcdsaSecp256r1RecoverPublicKey(o: MsgpackEcdsaSecp256r1RecoverPublicKey): EcdsaSecp256r1RecoverPublicKey;
export declare function fromEcdsaSecp256r1RecoverPublicKey(o: EcdsaSecp256r1RecoverPublicKey): MsgpackEcdsaSecp256r1RecoverPublicKey;
export declare function toEcdsaSecp256r1RecoverPublicKeyResponse(o: MsgpackEcdsaSecp256r1RecoverPublicKeyResponse): EcdsaSecp256r1RecoverPublicKeyResponse;
export declare function fromEcdsaSecp256r1RecoverPublicKeyResponse(o: EcdsaSecp256r1RecoverPublicKeyResponse): MsgpackEcdsaSecp256r1RecoverPublicKeyResponse;
export declare function toEcdsaSecp256r1VerifySignature(o: MsgpackEcdsaSecp256r1VerifySignature): EcdsaSecp256r1VerifySignature;
export declare function fromEcdsaSecp256r1VerifySignature(o: EcdsaSecp256r1VerifySignature): MsgpackEcdsaSecp256r1VerifySignature;
export declare function toEcdsaSecp256r1VerifySignatureResponse(o: MsgpackEcdsaSecp256r1VerifySignatureResponse): EcdsaSecp256r1VerifySignatureResponse;
export declare function fromEcdsaSecp256r1VerifySignatureResponse(o: EcdsaSecp256r1VerifySignatureResponse): MsgpackEcdsaSecp256r1VerifySignatureResponse;
export declare function toGoblinProof(o: MsgpackGoblinProof): GoblinProof;
export declare function fromGoblinProof(o: GoblinProof): MsgpackGoblinProof;
export declare function toGrumpkinAdd(o: MsgpackGrumpkinAdd): GrumpkinAdd;
export declare function fromGrumpkinAdd(o: GrumpkinAdd): MsgpackGrumpkinAdd;
export declare function toGrumpkinAddResponse(o: MsgpackGrumpkinAddResponse): GrumpkinAddResponse;
export declare function fromGrumpkinAddResponse(o: GrumpkinAddResponse): MsgpackGrumpkinAddResponse;
export declare function toGrumpkinBatchMul(o: MsgpackGrumpkinBatchMul): GrumpkinBatchMul;
export declare function fromGrumpkinBatchMul(o: GrumpkinBatchMul): MsgpackGrumpkinBatchMul;
export declare function toGrumpkinBatchMulResponse(o: MsgpackGrumpkinBatchMulResponse): GrumpkinBatchMulResponse;
export declare function fromGrumpkinBatchMulResponse(o: GrumpkinBatchMulResponse): MsgpackGrumpkinBatchMulResponse;
export declare function toGrumpkinGetRandomFr(o: MsgpackGrumpkinGetRandomFr): GrumpkinGetRandomFr;
export declare function fromGrumpkinGetRandomFr(o: GrumpkinGetRandomFr): MsgpackGrumpkinGetRandomFr;
export declare function toGrumpkinGetRandomFrResponse(o: MsgpackGrumpkinGetRandomFrResponse): GrumpkinGetRandomFrResponse;
export declare function fromGrumpkinGetRandomFrResponse(o: GrumpkinGetRandomFrResponse): MsgpackGrumpkinGetRandomFrResponse;
export declare function toGrumpkinMul(o: MsgpackGrumpkinMul): GrumpkinMul;
export declare function fromGrumpkinMul(o: GrumpkinMul): MsgpackGrumpkinMul;
export declare function toGrumpkinMulResponse(o: MsgpackGrumpkinMulResponse): GrumpkinMulResponse;
export declare function fromGrumpkinMulResponse(o: GrumpkinMulResponse): MsgpackGrumpkinMulResponse;
export declare function toGrumpkinReduce512(o: MsgpackGrumpkinReduce512): GrumpkinReduce512;
export declare function fromGrumpkinReduce512(o: GrumpkinReduce512): MsgpackGrumpkinReduce512;
export declare function toGrumpkinReduce512Response(o: MsgpackGrumpkinReduce512Response): GrumpkinReduce512Response;
export declare function fromGrumpkinReduce512Response(o: GrumpkinReduce512Response): MsgpackGrumpkinReduce512Response;
export declare function toMegaVkAsFields(o: MsgpackMegaVkAsFields): MegaVkAsFields;
export declare function fromMegaVkAsFields(o: MegaVkAsFields): MsgpackMegaVkAsFields;
export declare function toMegaVkAsFieldsResponse(o: MsgpackMegaVkAsFieldsResponse): MegaVkAsFieldsResponse;
export declare function fromMegaVkAsFieldsResponse(o: MegaVkAsFieldsResponse): MsgpackMegaVkAsFieldsResponse;
export declare function toPedersenCommit(o: MsgpackPedersenCommit): PedersenCommit;
export declare function fromPedersenCommit(o: PedersenCommit): MsgpackPedersenCommit;
export declare function toPedersenCommitResponse(o: MsgpackPedersenCommitResponse): PedersenCommitResponse;
export declare function fromPedersenCommitResponse(o: PedersenCommitResponse): MsgpackPedersenCommitResponse;
export declare function toPedersenHash(o: MsgpackPedersenHash): PedersenHash;
export declare function fromPedersenHash(o: PedersenHash): MsgpackPedersenHash;
export declare function toPedersenHashBuffer(o: MsgpackPedersenHashBuffer): PedersenHashBuffer;
export declare function fromPedersenHashBuffer(o: PedersenHashBuffer): MsgpackPedersenHashBuffer;
export declare function toPedersenHashBufferResponse(o: MsgpackPedersenHashBufferResponse): PedersenHashBufferResponse;
export declare function fromPedersenHashBufferResponse(o: PedersenHashBufferResponse): MsgpackPedersenHashBufferResponse;
export declare function toPedersenHashResponse(o: MsgpackPedersenHashResponse): PedersenHashResponse;
export declare function fromPedersenHashResponse(o: PedersenHashResponse): MsgpackPedersenHashResponse;
export declare function toPoseidon2Hash(o: MsgpackPoseidon2Hash): Poseidon2Hash;
export declare function fromPoseidon2Hash(o: Poseidon2Hash): MsgpackPoseidon2Hash;
export declare function toPoseidon2HashAccumulate(o: MsgpackPoseidon2HashAccumulate): Poseidon2HashAccumulate;
export declare function fromPoseidon2HashAccumulate(o: Poseidon2HashAccumulate): MsgpackPoseidon2HashAccumulate;
export declare function toPoseidon2HashAccumulateResponse(o: MsgpackPoseidon2HashAccumulateResponse): Poseidon2HashAccumulateResponse;
export declare function fromPoseidon2HashAccumulateResponse(o: Poseidon2HashAccumulateResponse): MsgpackPoseidon2HashAccumulateResponse;
export declare function toPoseidon2HashResponse(o: MsgpackPoseidon2HashResponse): Poseidon2HashResponse;
export declare function fromPoseidon2HashResponse(o: Poseidon2HashResponse): MsgpackPoseidon2HashResponse;
export declare function toPoseidon2Permutation(o: MsgpackPoseidon2Permutation): Poseidon2Permutation;
export declare function fromPoseidon2Permutation(o: Poseidon2Permutation): MsgpackPoseidon2Permutation;
export declare function toPoseidon2PermutationResponse(o: MsgpackPoseidon2PermutationResponse): Poseidon2PermutationResponse;
export declare function fromPoseidon2PermutationResponse(o: Poseidon2PermutationResponse): MsgpackPoseidon2PermutationResponse;
export declare function toProofSystemSettings(o: MsgpackProofSystemSettings): ProofSystemSettings;
export declare function fromProofSystemSettings(o: ProofSystemSettings): MsgpackProofSystemSettings;
export declare function toSchnorrComputePublicKey(o: MsgpackSchnorrComputePublicKey): SchnorrComputePublicKey;
export declare function fromSchnorrComputePublicKey(o: SchnorrComputePublicKey): MsgpackSchnorrComputePublicKey;
export declare function toSchnorrComputePublicKeyResponse(o: MsgpackSchnorrComputePublicKeyResponse): SchnorrComputePublicKeyResponse;
export declare function fromSchnorrComputePublicKeyResponse(o: SchnorrComputePublicKeyResponse): MsgpackSchnorrComputePublicKeyResponse;
export declare function toSchnorrConstructSignature(o: MsgpackSchnorrConstructSignature): SchnorrConstructSignature;
export declare function fromSchnorrConstructSignature(o: SchnorrConstructSignature): MsgpackSchnorrConstructSignature;
export declare function toSchnorrConstructSignatureResponse(o: MsgpackSchnorrConstructSignatureResponse): SchnorrConstructSignatureResponse;
export declare function fromSchnorrConstructSignatureResponse(o: SchnorrConstructSignatureResponse): MsgpackSchnorrConstructSignatureResponse;
export declare function toSchnorrVerifySignature(o: MsgpackSchnorrVerifySignature): SchnorrVerifySignature;
export declare function fromSchnorrVerifySignature(o: SchnorrVerifySignature): MsgpackSchnorrVerifySignature;
export declare function toSchnorrVerifySignatureResponse(o: MsgpackSchnorrVerifySignatureResponse): SchnorrVerifySignatureResponse;
export declare function fromSchnorrVerifySignatureResponse(o: SchnorrVerifySignatureResponse): MsgpackSchnorrVerifySignatureResponse;
export declare function toSecp256k1GetRandomFr(o: MsgpackSecp256k1GetRandomFr): Secp256k1GetRandomFr;
export declare function fromSecp256k1GetRandomFr(o: Secp256k1GetRandomFr): MsgpackSecp256k1GetRandomFr;
export declare function toSecp256k1GetRandomFrResponse(o: MsgpackSecp256k1GetRandomFrResponse): Secp256k1GetRandomFrResponse;
export declare function fromSecp256k1GetRandomFrResponse(o: Secp256k1GetRandomFrResponse): MsgpackSecp256k1GetRandomFrResponse;
export declare function toSecp256k1Mul(o: MsgpackSecp256k1Mul): Secp256k1Mul;
export declare function fromSecp256k1Mul(o: Secp256k1Mul): MsgpackSecp256k1Mul;
export declare function toSecp256k1MulResponse(o: MsgpackSecp256k1MulResponse): Secp256k1MulResponse;
export declare function fromSecp256k1MulResponse(o: Secp256k1MulResponse): MsgpackSecp256k1MulResponse;
export declare function toSecp256k1Reduce512(o: MsgpackSecp256k1Reduce512): Secp256k1Reduce512;
export declare function fromSecp256k1Reduce512(o: Secp256k1Reduce512): MsgpackSecp256k1Reduce512;
export declare function toSecp256k1Reduce512Response(o: MsgpackSecp256k1Reduce512Response): Secp256k1Reduce512Response;
export declare function fromSecp256k1Reduce512Response(o: Secp256k1Reduce512Response): MsgpackSecp256k1Reduce512Response;
export declare function toShutdown(o: MsgpackShutdown): Shutdown;
export declare function fromShutdown(o: Shutdown): MsgpackShutdown;
export declare function toShutdownResponse(o: MsgpackShutdownResponse): ShutdownResponse;
export declare function fromShutdownResponse(o: ShutdownResponse): MsgpackShutdownResponse;
export declare function toSrsInitGrumpkinSrs(o: MsgpackSrsInitGrumpkinSrs): SrsInitGrumpkinSrs;
export declare function fromSrsInitGrumpkinSrs(o: SrsInitGrumpkinSrs): MsgpackSrsInitGrumpkinSrs;
export declare function toSrsInitGrumpkinSrsResponse(o: MsgpackSrsInitGrumpkinSrsResponse): SrsInitGrumpkinSrsResponse;
export declare function fromSrsInitGrumpkinSrsResponse(o: SrsInitGrumpkinSrsResponse): MsgpackSrsInitGrumpkinSrsResponse;
export declare function toSrsInitSrs(o: MsgpackSrsInitSrs): SrsInitSrs;
export declare function fromSrsInitSrs(o: SrsInitSrs): MsgpackSrsInitSrs;
export declare function toSrsInitSrsResponse(o: MsgpackSrsInitSrsResponse): SrsInitSrsResponse;
export declare function fromSrsInitSrsResponse(o: SrsInitSrsResponse): MsgpackSrsInitSrsResponse;
export declare function toVkAsFields(o: MsgpackVkAsFields): VkAsFields;
export declare function fromVkAsFields(o: VkAsFields): MsgpackVkAsFields;
export declare function toVkAsFieldsResponse(o: MsgpackVkAsFieldsResponse): VkAsFieldsResponse;
export declare function fromVkAsFieldsResponse(o: VkAsFieldsResponse): MsgpackVkAsFieldsResponse;
export interface BbApiBase {
    circuitProve(command: CircuitProve): Promise<CircuitProveResponse>;
    circuitComputeVk(command: CircuitComputeVk): Promise<CircuitComputeVkResponse>;
    circuitStats(command: CircuitStats): Promise<CircuitInfoResponse>;
    circuitVerify(command: CircuitVerify): Promise<CircuitVerifyResponse>;
    clientIvcComputeStandaloneVk(command: ClientIvcComputeStandaloneVk): Promise<ClientIvcComputeStandaloneVkResponse>;
    clientIvcComputeIvcVk(command: ClientIvcComputeIvcVk): Promise<ClientIvcComputeIvcVkResponse>;
    clientIvcStart(command: ClientIvcStart): Promise<ClientIvcStartResponse>;
    clientIvcLoad(command: ClientIvcLoad): Promise<ClientIvcLoadResponse>;
    clientIvcAccumulate(command: ClientIvcAccumulate): Promise<ClientIvcAccumulateResponse>;
    clientIvcProve(command: ClientIvcProve): Promise<ClientIvcProveResponse>;
    clientIvcVerify(command: ClientIvcVerify): Promise<ClientIvcVerifyResponse>;
    vkAsFields(command: VkAsFields): Promise<VkAsFieldsResponse>;
    megaVkAsFields(command: MegaVkAsFields): Promise<MegaVkAsFieldsResponse>;
    circuitWriteSolidityVerifier(command: CircuitWriteSolidityVerifier): Promise<CircuitWriteSolidityVerifierResponse>;
    clientIvcCheckPrecomputedVk(command: ClientIvcCheckPrecomputedVk): Promise<ClientIvcCheckPrecomputedVkResponse>;
    clientIvcStats(command: ClientIvcStats): Promise<ClientIvcStatsResponse>;
    poseidon2Hash(command: Poseidon2Hash): Promise<Poseidon2HashResponse>;
    poseidon2Permutation(command: Poseidon2Permutation): Promise<Poseidon2PermutationResponse>;
    poseidon2HashAccumulate(command: Poseidon2HashAccumulate): Promise<Poseidon2HashAccumulateResponse>;
    pedersenCommit(command: PedersenCommit): Promise<PedersenCommitResponse>;
    pedersenHash(command: PedersenHash): Promise<PedersenHashResponse>;
    pedersenHashBuffer(command: PedersenHashBuffer): Promise<PedersenHashBufferResponse>;
    blake2s(command: Blake2s): Promise<Blake2sResponse>;
    blake2sToField(command: Blake2sToField): Promise<Blake2sToFieldResponse>;
    aesEncrypt(command: AesEncrypt): Promise<AesEncryptResponse>;
    aesDecrypt(command: AesDecrypt): Promise<AesDecryptResponse>;
    grumpkinMul(command: GrumpkinMul): Promise<GrumpkinMulResponse>;
    grumpkinAdd(command: GrumpkinAdd): Promise<GrumpkinAddResponse>;
    grumpkinBatchMul(command: GrumpkinBatchMul): Promise<GrumpkinBatchMulResponse>;
    grumpkinGetRandomFr(command: GrumpkinGetRandomFr): Promise<GrumpkinGetRandomFrResponse>;
    grumpkinReduce512(command: GrumpkinReduce512): Promise<GrumpkinReduce512Response>;
    secp256k1Mul(command: Secp256k1Mul): Promise<Secp256k1MulResponse>;
    secp256k1GetRandomFr(command: Secp256k1GetRandomFr): Promise<Secp256k1GetRandomFrResponse>;
    secp256k1Reduce512(command: Secp256k1Reduce512): Promise<Secp256k1Reduce512Response>;
    bn254FrSqrt(command: Bn254FrSqrt): Promise<Bn254FrSqrtResponse>;
    schnorrComputePublicKey(command: SchnorrComputePublicKey): Promise<SchnorrComputePublicKeyResponse>;
    schnorrConstructSignature(command: SchnorrConstructSignature): Promise<SchnorrConstructSignatureResponse>;
    schnorrVerifySignature(command: SchnorrVerifySignature): Promise<SchnorrVerifySignatureResponse>;
    ecdsaSecp256k1ComputePublicKey(command: EcdsaSecp256k1ComputePublicKey): Promise<EcdsaSecp256k1ComputePublicKeyResponse>;
    ecdsaSecp256r1ComputePublicKey(command: EcdsaSecp256r1ComputePublicKey): Promise<EcdsaSecp256r1ComputePublicKeyResponse>;
    ecdsaSecp256k1ConstructSignature(command: EcdsaSecp256k1ConstructSignature): Promise<EcdsaSecp256k1ConstructSignatureResponse>;
    ecdsaSecp256r1ConstructSignature(command: EcdsaSecp256r1ConstructSignature): Promise<EcdsaSecp256r1ConstructSignatureResponse>;
    ecdsaSecp256k1RecoverPublicKey(command: EcdsaSecp256k1RecoverPublicKey): Promise<EcdsaSecp256k1RecoverPublicKeyResponse>;
    ecdsaSecp256r1RecoverPublicKey(command: EcdsaSecp256r1RecoverPublicKey): Promise<EcdsaSecp256r1RecoverPublicKeyResponse>;
    ecdsaSecp256k1VerifySignature(command: EcdsaSecp256k1VerifySignature): Promise<EcdsaSecp256k1VerifySignatureResponse>;
    ecdsaSecp256r1VerifySignature(command: EcdsaSecp256r1VerifySignature): Promise<EcdsaSecp256r1VerifySignatureResponse>;
    srsInitSrs(command: SrsInitSrs): Promise<SrsInitSrsResponse>;
    srsInitGrumpkinSrs(command: SrsInitGrumpkinSrs): Promise<SrsInitGrumpkinSrsResponse>;
    shutdown(command: Shutdown): Promise<ShutdownResponse>;
    destroy(): Promise<void>;
}
export {};
//# sourceMappingURL=api_types.d.ts.map