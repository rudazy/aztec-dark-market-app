/**
 * Adapter that wraps a synchronous backend to provide an async interface.
 * The sync backend's blocking calls are simply wrapped in Promise.resolve().
 *
 * This is useful for backends like shared memory where the call is actually
 * synchronous but we want to use it with the async API.
 */
export class SyncToAsyncAdapter {
    constructor(syncBackend) {
        this.syncBackend = syncBackend;
    }
    async call(inputBuffer) {
        // The sync backend blocks until complete, so just wrap in a resolved promise
        return Promise.resolve(this.syncBackend.call(inputBuffer));
    }
    async destroy() {
        this.syncBackend.destroy();
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3luY190b19hc3luY19hZGFwdGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2JiX2JhY2tlbmRzL3N5bmNfdG9fYXN5bmNfYWRhcHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQTs7Ozs7O0dBTUc7QUFDSCxNQUFNLE9BQU8sa0JBQWtCO0lBQzdCLFlBQW9CLFdBQWdDO1FBQWhDLGdCQUFXLEdBQVgsV0FBVyxDQUFxQjtJQUFHLENBQUM7SUFFeEQsS0FBSyxDQUFDLElBQUksQ0FBQyxXQUF1QjtRQUNoQyw2RUFBNkU7UUFDN0UsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7SUFDN0QsQ0FBQztJQUVELEtBQUssQ0FBQyxPQUFPO1FBQ1gsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUM3QixDQUFDO0NBQ0YifQ==