"use strict";
/**
 * Unified schema compiler with integrated strategies
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchemaCompiler = void 0;
exports.createSharedTypesCompiler = createSharedTypesCompiler;
exports.createSyncApiCompiler = createSyncApiCompiler;
exports.createAsyncApiCompiler = createAsyncApiCompiler;
// Helper functions
function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.substring(1);
}
function camelCase(s) {
    return s
        .split('_')
        .map((part, index) => (index === 0 ? part.charAt(0).toLowerCase() + part.substring(1) : capitalize(part)))
        .join('');
}
function pascalCase(s) {
    return s.split('_').map(capitalize).join('');
}
class SchemaCompiler {
    constructor(config) {
        this.config = config;
        this.typeCache = new Map();
        this.functionMetadata = [];
        // WORKTODO(bbapi): AI slop fixup - redundant with typeCache, remove
        this.referencedTypes = new Set();
    }
    /**
     * Process API schema and extract function metadata
     */
    processApiSchema(commandsSchema, responsesSchema) {
        // Process types
        this.processSchema(commandsSchema);
        this.processSchema(responsesSchema);
        // Extract function metadata from named unions
        if (!Array.isArray(commandsSchema) ||
            commandsSchema[0] !== 'named_union' ||
            !Array.isArray(responsesSchema) ||
            responsesSchema[0] !== 'named_union') {
            throw new Error('Expected named_union schema format');
        }
        const commands = commandsSchema[1];
        const responses = responsesSchema[1];
        for (let i = 0; i < commands.length; i++) {
            const [commandName] = commands[i];
            const [responseName] = responses[i];
            this.functionMetadata.push({
                name: camelCase(commandName),
                commandType: pascalCase(commandName),
                responseType: pascalCase(responseName),
            });
        }
    }
    /**
     * Process a schema and populate type cache
     */
    processSchema(schema) {
        const key = this.getSchemaKey(schema);
        if (this.typeCache.has(key)) {
            const ret = this.typeCache.get(key);
            if (ret.typeName === 'unknown') {
                throw new Error(`Recursive schema detected at ${key}, please check your schema for circular references.`);
            }
            return ret;
        }
        this.typeCache.set(key, { typeName: 'unknown', msgpackTypeName: '' });
        const typeInfo = this.generateTypeInfo(schema);
        this.typeCache.set(key, typeInfo);
        return typeInfo;
    }
    /**
     * Generate the complete output
     */
    compile() {
        const parts = ['// AUTOGENERATED FILE - DO NOT EDIT', ''];
        // Generate imports
        parts.push(...this.generateImports());
        parts.push('');
        // Generate type declarations only for 'types' mode
        if (this.config.mode === 'types') {
            const sortedTypes = Array.from(this.typeCache.values())
                .filter(t => t.declaration)
                .sort((a, b) => a.typeName.localeCompare(b.typeName));
            // Group declarations
            const typeAliases = sortedTypes.filter(t => t.declaration?.startsWith('export type') && !t.declaration?.includes('interface'));
            const publicInterfaces = sortedTypes.filter(t => t.declaration?.includes('export interface'));
            const privateInterfaces = sortedTypes.filter(t => t.declaration?.includes('interface Msgpack'));
            // Add type aliases if needed
            if (typeAliases.length > 0) {
                parts.push('// Type aliases');
                for (const type of typeAliases) {
                    parts.push(type.declaration);
                }
                parts.push('');
            }
            // Add tuple helper if needed
            if (this.needsTupleHelper()) {
                parts.push('// Tuple type for fixed-size arrays', 'type Tuple<T, N extends number> = N extends N ? (number extends N ? T[] : _TupleOf<T, N, []>) : never;', "type _TupleOf<T, N extends number, R extends unknown[]> = R['length'] extends N ? R : _TupleOf<T, N, [T, ...R]>;", '', '// Helper functions', 'function mapTuple<T, S, N extends number>(tuple: Tuple<T, N>, fn: (item: T) => S): Tuple<S, N> {', '  return tuple.map(fn) as Tuple<S, N>;', '}', '');
            }
            // Add public interfaces
            if (publicInterfaces.length > 0) {
                parts.push('// Public interfaces (exported)');
                for (const type of publicInterfaces) {
                    parts.push(type.declaration, '');
                }
            }
            // Add private interfaces
            if (privateInterfaces.length > 0) {
                parts.push('// Private Msgpack interfaces (not exported)');
                for (const type of privateInterfaces) {
                    parts.push(type.declaration, '');
                }
            }
            // Add conversion functions (only for api_types.ts)
            const conversions = sortedTypes.filter(t => t.toMethod || t.fromMethod);
            if (conversions.length > 0) {
                parts.push('// Conversion functions (exported)');
                for (const type of conversions) {
                    if (type.toMethod) {
                        parts.push('export ' + type.toMethod, '');
                    }
                    if (type.fromMethod) {
                        parts.push('export ' + type.fromMethod, '');
                    }
                }
            }
            // Add BbApiBase interface
            if (this.functionMetadata.length > 0) {
                parts.push('', '// Base API interface');
                parts.push(this.generateBbApiBaseInterface());
            }
        }
        // Add API class for non-types modes
        if (this.config.mode !== 'types' && this.functionMetadata.length > 0) {
            parts.push(this.generateApiClass());
        }
        return parts.join('\n') + '\n';
    }
    getSchemaKey(schema) {
        if (typeof schema === 'string')
            return schema;
        if (Array.isArray(schema))
            return JSON.stringify(schema);
        if (typeof schema === 'object')
            return schema.__typename || JSON.stringify(schema);
        return String(schema);
    }
    needsTupleHelper() {
        return Array.from(this.typeCache.values()).some(t => t.typeName.includes('Tuple<'));
    }
    trackTypeUsage(typeName) {
        // Only track for API modes
        if (this.config.mode === 'types')
            return;
        // Extract base types from complex types
        const baseTypes = this.extractBaseTypes(typeName);
        for (const type of baseTypes) {
            // Skip built-in types
            if (['string', 'number', 'boolean', 'Uint8Array'].includes(type)) {
                continue;
            }
            this.referencedTypes.add(type);
        }
    }
    extractBaseTypes(typeName) {
        const types = [];
        // Handle arrays
        const arrayMatch = typeName.match(/^(.+)\[\]$/);
        if (arrayMatch) {
            types.push(...this.extractBaseTypes(arrayMatch[1]));
            return types;
        }
        // Handle Tuple
        const tupleMatch = typeName.match(/^Tuple<(.+),\s*\d+>$/);
        if (tupleMatch) {
            types.push(...this.extractBaseTypes(tupleMatch[1]));
            return types;
        }
        // Handle Record
        const recordMatch = typeName.match(/^Record<(.+),\s*(.+)>$/);
        if (recordMatch) {
            types.push(...this.extractBaseTypes(recordMatch[1]));
            types.push(...this.extractBaseTypes(recordMatch[2]));
            return types;
        }
        // Handle union types
        if (typeName.includes(' | ')) {
            const parts = typeName.split(' | ');
            for (const part of parts) {
                types.push(...this.extractBaseTypes(part.trim()));
            }
            return types;
        }
        // Base case - simple type
        types.push(typeName);
        return types;
    }
    generateTypeInfo(schema) {
        if (Array.isArray(schema)) {
            return this.processArraySchema(schema);
        }
        else if (typeof schema === 'string') {
            return this.processPrimitiveSchema(schema);
        }
        else if (typeof schema === 'object') {
            return this.processObjectSchema(schema);
        }
        throw new Error(`Unsupported schema type: ${schema}`);
    }
    processArraySchema(schema) {
        const [type, ...args] = schema;
        switch (type) {
            case 'array': {
                const [subtype, size] = args[0];
                // Special case: byte arrays should be Uint8Array
                if (subtype === 'unsigned char') {
                    return { typeName: 'Uint8Array' };
                }
                // For other types, use T[] - idiomatic TypeScript for fixed-length homogeneous arrays
                const subtypeInfo = this.processSchema(subtype);
                return {
                    typeName: `${subtypeInfo.typeName}[]`,
                    msgpackTypeName: `${subtypeInfo.msgpackTypeName || subtypeInfo.typeName}[]`,
                };
            }
            case 'variant': {
                const variants = args[0];
                const variantInfos = variants.map(v => this.processSchema(v));
                const typeName = variantInfos.map(v => v.typeName).join(' | ');
                const msgpackUnion = variantInfos.map(v => v.msgpackTypeName || v.typeName).join(' | ');
                return {
                    typeName,
                    msgpackTypeName: `[number, ${msgpackUnion}]`,
                };
            }
            case 'named_union': {
                const namedTypes = args[0];
                const tupleTypes = [];
                for (const [name, schemaOrName] of namedTypes) {
                    let typeInfo = this.processSchema(schemaOrName);
                    // Track usage of the type
                    this.trackTypeUsage(typeInfo.typeName);
                    tupleTypes.push(`["${name}", ${typeInfo.typeName}]`);
                }
                return {
                    typeName: tupleTypes.join(' | '),
                    msgpackTypeName: tupleTypes.join(' | '),
                };
            }
            case 'vector': {
                const [subtype] = args[0];
                if (subtype === 'unsigned char') {
                    return { typeName: 'Uint8Array' };
                }
                const subtypeInfo = this.processSchema(subtype);
                return {
                    typeName: `${subtypeInfo.typeName}[]`,
                    msgpackTypeName: `${subtypeInfo.msgpackTypeName || subtypeInfo.typeName}[]`,
                };
            }
            case 'alias': {
                const [rawTypeName, msgpackName] = args[0];
                const typeName = pascalCase(rawTypeName);
                let targetType;
                if (msgpackName.startsWith('bin')) {
                    targetType = 'Uint8Array';
                }
                else if (['int', 'unsigned int', 'unsigned short'].includes(msgpackName)) {
                    targetType = 'number';
                }
                else {
                    throw new Error(`Unsupported alias type: ${msgpackName}`);
                }
                // Create a proper type alias declaration
                return {
                    typeName,
                    msgpackTypeName: targetType,
                    declaration: `export type ${typeName} = ${targetType};`,
                };
            }
            case 'shared_ptr': {
                const [subtype] = args[0];
                return this.processSchema(subtype);
            }
            case 'map': {
                const [keyType, valueType] = args[0];
                const keyInfo = this.processSchema(keyType);
                const valueInfo = this.processSchema(valueType);
                return {
                    typeName: `Record<${keyInfo.typeName}, ${valueInfo.typeName}>`,
                    msgpackTypeName: `Record<${keyInfo.msgpackTypeName || keyInfo.typeName}, ${valueInfo.msgpackTypeName || valueInfo.typeName}>`,
                };
            }
            default:
                throw new Error(`Unsupported array schema type: ${type}`);
        }
    }
    processPrimitiveSchema(schema) {
        switch (schema) {
            case 'bool':
                return { typeName: 'boolean' };
            case 'int':
            case 'unsigned int':
            case 'unsigned short':
            case 'unsigned long':
            case 'unsigned char':
            case 'double':
                return { typeName: 'number' };
            case 'string':
                return { typeName: 'string' };
            case 'bin32':
                return { typeName: 'Uint8Array' };
            default:
                return { typeName: pascalCase(schema) };
        }
    }
    processObjectSchema(schema) {
        const typeName = pascalCase(schema.__typename);
        const msgpackTypeName = 'Msgpack' + typeName;
        const declaration = this.generateInterfaces(typeName, schema);
        const toMethod = this.generateToMethod(typeName, schema);
        const fromMethod = this.generateFromMethod(typeName, schema);
        return {
            typeName,
            msgpackTypeName,
            declaration,
            toMethod,
            fromMethod,
        };
    }
    getOrCreateEmptyType(typeName) {
        const key = `empty_${typeName}`;
        if (this.typeCache.has(key)) {
            return this.typeCache.get(key);
        }
        const typeInfo = {
            typeName,
            msgpackTypeName: 'Msgpack' + typeName,
            declaration: `export interface ${typeName} {}\n\ninterface Msgpack${typeName} {}`,
            toMethod: `function to${typeName}(o: Msgpack${typeName}): ${typeName} {\n  return {};\n}`,
            fromMethod: `function from${typeName}(o: ${typeName}): Msgpack${typeName} {\n  return {};\n}`,
        };
        this.typeCache.set(key, typeInfo);
        return typeInfo;
    }
    generateInterfaces(name, schema) {
        const publicInterface = this.generatePublicInterface(name, schema);
        const msgpackInterface = this.generateMsgpackInterface(name, schema);
        return publicInterface + '\n\n' + msgpackInterface;
    }
    generatePublicInterface(name, schema) {
        let result = `export interface ${name} {\n`;
        for (const [key, value] of Object.entries(schema)) {
            if (key === '__typename')
                continue;
            const typeInfo = this.processSchema(value);
            // Track type usage
            this.trackTypeUsage(typeInfo.typeName);
            result += `  ${camelCase(key)}: ${typeInfo.typeName};\n`;
        }
        result += '}';
        return result;
    }
    generateMsgpackInterface(name, schema) {
        let result = `interface Msgpack${name} {\n`;
        for (const [key, value] of Object.entries(schema)) {
            if (key === '__typename')
                continue;
            const typeInfo = this.processSchema(value);
            result += `  ${key}: ${typeInfo.msgpackTypeName || typeInfo.typeName};\n`;
        }
        result += '}';
        return result;
    }
    generateToMethod(name, schema) {
        const fields = Object.entries(schema).filter(([key]) => key !== '__typename');
        if (fields.length === 0) {
            return `function to${name}(o: Msgpack${name}): ${name} {\n  return {};\n}`;
        }
        const checks = fields
            .map(([key]) => `  if (o.${key} === undefined) { throw new Error("Expected ${key} in ${name} deserialization"); }`)
            .join('\n');
        const conversions = fields
            .map(([key, value]) => {
            const typeInfo = this.processSchema(value);
            const converter = this.generateConverter(typeInfo, `o.${key}`, 'to');
            return `    ${camelCase(key)}: ${converter},`;
        })
            .join('\n');
        return `function to${name}(o: Msgpack${name}): ${name} {
${checks};
  return {
${conversions}
  };
}`;
    }
    generateFromMethod(name, schema) {
        const fields = Object.entries(schema).filter(([key]) => key !== '__typename');
        if (fields.length === 0) {
            return `function from${name}(o: ${name}): Msgpack${name} {\n  return {};\n}`;
        }
        const checks = fields
            .map(([key]) => `  if (o.${camelCase(key)} === undefined) { throw new Error("Expected ${camelCase(key)} in ${name} serialization"); }`)
            .join('\n');
        const conversions = fields
            .map(([key, value]) => {
            const typeInfo = this.processSchema(value);
            const converter = this.generateConverter(typeInfo, `o.${camelCase(key)}`, 'from');
            return `  ${key}: ${converter},`;
        })
            .join('\n');
        return `function from${name}(o: ${name}): Msgpack${name} {
${checks};
  return {
${conversions}
  };
}`;
    }
    generateConverter(typeInfo, value, direction) {
        // Handle arrays/tuples
        if (typeInfo.typeName.includes('[]') || typeInfo.typeName.includes('Tuple<')) {
            const elementType = typeInfo.typeName.match(/^(.+)\[\]$/) || typeInfo.typeName.match(/^Tuple<(.+),/);
            if (elementType) {
                const isTuple = typeInfo.typeName.includes('Tuple<');
                const mapFn = isTuple ? 'mapTuple' : 'map';
                return `${value}.${mapFn}((v: any) => v)`; // Simplified for now
            }
        }
        // Handle custom types that have conversion methods (not just type aliases)
        if (typeInfo.toMethod || typeInfo.fromMethod) {
            return `${direction}${typeInfo.typeName}(${value})`;
        }
        return value;
    }
    generateImports() {
        const imports = [];
        // Base imports
        if (this.config.imports) {
            imports.push(...this.config.imports);
        }
        // For API modes, import from api_types
        if (this.config.mode !== 'types') {
            const neededImports = new Set();
            // Add types and conversion functions from function metadata
            for (const metadata of this.functionMetadata) {
                neededImports.add(metadata.commandType);
                neededImports.add(metadata.responseType);
                neededImports.add(`from${metadata.commandType}`);
                neededImports.add(`to${metadata.responseType}`);
            }
            // Add referenced types
            for (const type of this.referencedTypes) {
                neededImports.add(type);
            }
            // Add BbApiBase interface
            neededImports.add('BbApiBase');
            if (neededImports.size > 0) {
                const sortedImports = Array.from(neededImports).sort();
                // Remove duplicates
                const uniqueImports = sortedImports.filter((item, index) => sortedImports.indexOf(item) === index);
                imports.push(`import { ${uniqueImports.join(', ')} } from './api_types.js';`);
            }
        }
        return imports;
    }
    generateBbApiBaseInterface() {
        const methods = this.functionMetadata
            .map(m => `  ${m.name}(command: ${m.commandType}): Promise<${m.responseType}>;`)
            .join('\n');
        return `export interface BbApiBase {
${methods}
  destroy(): Promise<void>;
}`;
    }
    generateApiClass() {
        const className = this.getApiClassName();
        const methods = this.functionMetadata.map(m => this.generateApiMethod(m)).join('\n\n');
        // For sync API, don't implement BbApiBase since methods are synchronous
        const implementsClause = this.config.mode === 'sync' ? '' : ' implements BbApiBase';
        // For tracing all calls to bb.
        // const msgpackCallHelper =
        //   `${this.config.mode === 'async' ? 'async ' : ''}function msgpackCall(backend: ${this.getBackendType()}, input: any[]) {\n` +
        //   `  const commandName = input[0]?.[0] || 'unknown';\n` +
        //   `  process.stderr.write(\`[BB MSGPACK ${this.config.mode === 'async' ? 'ASYNC' : 'SYNC'}] \${commandName}\\n\`);\n` +
        //   `  const inputBuffer = new Encoder({ useRecords: false }).pack(input);\n` +
        //   `  const encodedResult = ${this.config.mode === 'async' ? 'await ' : ''}backend.call(inputBuffer);\n` +
        //   `  const result = new Decoder({ useRecords: false }).unpack(encodedResult);\n` +
        //   `  process.stderr.write(\`[BB MSGPACK ${this.config.mode === 'async' ? 'ASYNC' : 'SYNC'}] \${commandName} => completed\\n\`);\n` +
        //   `  return result;\n` +
        //   `}\n`;
        const msgpackCallHelper = `${this.config.mode === 'async' ? 'async ' : ''}function msgpackCall(backend: ${this.getBackendType()}, input: any[]) {` +
            `  const inputBuffer = new Encoder({ useRecords: false }).pack(input);` +
            `  const encodedResult = ${this.config.mode === 'async' ? 'await ' : ''}backend.call(inputBuffer);` +
            `  return new Decoder({ useRecords: false }).unpack(encodedResult);` +
            `}\n`;
        const destroyMethod = this.config.mode === 'sync'
            ? `  destroy(): void {
    if (this.backend.destroy) this.backend.destroy();
  }`
            : `  destroy(): Promise<void> {
    return this.backend.destroy ? this.backend.destroy() : Promise.resolve();
  }`;
        return (msgpackCallHelper +
            `export class ${className}${implementsClause} {
  constructor(protected backend: ${this.getBackendType()}) {}

${methods}

${destroyMethod}
}`);
    }
    getApiClassName() {
        switch (this.config.mode) {
            case 'sync':
                return 'SyncApi';
            case 'async':
                return 'AsyncApi';
            default:
                throw new Error(`Invalid mode: ${this.config.mode}`);
        }
    }
    getBackendType() {
        switch (this.config.mode) {
            case 'sync':
                return 'IMsgpackBackendSync';
            case 'async':
                return 'IMsgpackBackendAsync';
            default:
                return '';
        }
    }
    generateApiMethod(metadata) {
        const { name, commandType, responseType } = metadata;
        // For async mode, queue immediately and return promise
        if (this.config.mode === 'async') {
            return `  ${name}(command: ${commandType}): Promise<${responseType}> {
    const msgpackCommand = from${commandType}(command);
    return msgpackCall(this.backend, [["${capitalize(name)}", msgpackCommand]]).then(([variantName, result]: [string, any]) => {
      if (variantName !== '${responseType}') {
        throw new Error(\`Expected variant name '${responseType}' but got '\${variantName}'\`);
      }
      return to${responseType}(result);
    });
  }`;
        }
        // For sync mode, keep the synchronous behavior
        return `  ${name}(command: ${commandType}): ${responseType} {
    const msgpackCommand = from${commandType}(command);
    const [variantName, result] = msgpackCall(this.backend, [["${capitalize(name)}", msgpackCommand]]);
    if (variantName !== '${responseType}') {
      throw new Error(\`Expected variant name '${responseType}' but got '\${variantName}'\`);
    }
    return to${responseType}(result);
  }`;
    }
}
exports.SchemaCompiler = SchemaCompiler;
// Factory methods for creating configured compilers
function createSharedTypesCompiler() {
    return new SchemaCompiler({
        mode: 'types',
        imports: [],
    });
}
function createSyncApiCompiler() {
    return new SchemaCompiler({
        mode: 'sync',
        imports: [
            `import { IMsgpackBackendSync } from '../../bb_backends/interface.js';`,
            `import { Decoder, Encoder } from 'msgpackr';`,
        ],
    });
}
function createAsyncApiCompiler() {
    return new SchemaCompiler({
        mode: 'async',
        imports: [
            `import { IMsgpackBackendAsync } from '../../bb_backends/interface.js';`,
            `import { Decoder, Encoder } from 'msgpackr';`,
        ],
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NoZW1hX2NvbXBpbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NiaW5kL3NjaGVtYV9jb21waWxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7OztBQXVyQkgsOERBS0M7QUFFRCxzREFRQztBQUVELHdEQVFDO0FBenFCRCxtQkFBbUI7QUFDbkIsU0FBUyxVQUFVLENBQUMsQ0FBUztJQUMzQixPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLEdBQUcsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNwRCxDQUFDO0FBRUQsU0FBUyxTQUFTLENBQUMsQ0FBUztJQUMxQixPQUFPLENBQUM7U0FDTCxLQUFLLENBQUMsR0FBRyxDQUFDO1NBQ1YsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQyxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQ3pHLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUNkLENBQUM7QUFFRCxTQUFTLFVBQVUsQ0FBQyxDQUFTO0lBQzNCLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQy9DLENBQUM7QUFFRCxNQUFhLGNBQWM7SUFNekIsWUFBb0IsTUFBc0I7UUFBdEIsV0FBTSxHQUFOLE1BQU0sQ0FBZ0I7UUFMbEMsY0FBUyxHQUFHLElBQUksR0FBRyxFQUFvQixDQUFDO1FBQ3hDLHFCQUFnQixHQUF1QixFQUFFLENB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