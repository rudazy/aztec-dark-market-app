import { Barretenberg } from './index.js';
import { uint8ArrayToHex, hexToUint8Array } from '../proof/index.js';
import { fromClientIVCProof, toClientIVCProof } from '../cbind/generated/api_types.js';
import { ungzip } from 'pako';
import { Buffer } from 'buffer';
import { Decoder, Encoder } from 'msgpackr';
export class AztecClientBackendError extends Error {
    constructor(message) {
        super(message);
    }
}
function getProofSettingsFromOptions(options) {
    return {
        ipaAccumulation: false,
        oracleHashType: options?.keccak || options?.keccakZK
            ? 'keccak'
            : options?.starknet || options?.starknetZK
                ? 'starknet'
                : 'poseidon2',
        // TODO no current way to target non-zk poseidon2 hash
        disableZk: options?.keccak || options?.starknet ? true : false,
        optimizedSolidityVerifier: false,
    };
}
export class UltraHonkVerifierBackend {
    constructor(backendOptions = { threads: 1 }, circuitOptions = { recursive: false }) {
        this.backendOptions = backendOptions;
        this.circuitOptions = circuitOptions;
    }
    /** @ignore */
    async instantiate() {
        if (!this.api) {
            const api = await Barretenberg.new(this.backendOptions);
            const honkRecursion = true;
            await api.initSRSForCircuitSize(0);
            this.api = api;
        }
    }
    async verifyProof(proofData, options) {
        await this.instantiate();
        const proofFrs = [];
        for (let i = 0; i < proofData.proof.length; i += 32) {
            proofFrs.push(proofData.proof.slice(i, i + 32));
        }
        const { verified } = await this.api.circuitVerify({
            verificationKey: proofData.verificationKey,
            publicInputs: proofData.publicInputs.map(hexToUint8Array),
            proof: proofFrs,
            settings: getProofSettingsFromOptions(options),
        });
        return verified;
    }
    destroy() {
        if (!this.api) {
            return Promise.resolve();
        }
        return this.api.destroy();
    }
}
export class UltraHonkBackend {
    constructor(acirBytecode, backendOptions = { threads: 1 }, circuitOptions = { recursive: false }) {
        this.backendOptions = backendOptions;
        this.circuitOptions = circuitOptions;
        this.acirUncompressedBytecode = acirToUint8Array(acirBytecode);
    }
    /** @ignore */
    async instantiate() {
        if (!this.api) {
            const api = await Barretenberg.new(this.backendOptions);
            const honkRecursion = true;
            await api.acirInitSRS(this.acirUncompressedBytecode, this.circuitOptions.recursive, honkRecursion);
            this.api = api;
        }
    }
    async generateProof(compressedWitness, options) {
        await this.instantiate();
        const witness = ungzip(compressedWitness);
        const { proof, publicInputs } = await this.api.circuitProve({
            witness,
            circuit: {
                name: 'circuit',
                bytecode: Buffer.from(this.acirUncompressedBytecode),
                verificationKey: Buffer.from([]), // Empty VK - lower performance.
            },
            settings: getProofSettingsFromOptions(options),
        });
        console.log(`Generated proof for circuit with ${publicInputs.length} public inputs and ${proof.length} fields.`);
        // We return ProofData as a flat buffer and an array of strings to match the current ProofData class.
        const flatProof = new Uint8Array(proof.length * 32);
        proof.forEach((fr, i) => {
            flatProof.set(fr, i * 32);
        });
        return { proof: flatProof, publicInputs: publicInputs.map(uint8ArrayToHex) };
    }
    async verifyProof(proofData, options) {
        await this.instantiate();
        const proofFrs = [];
        for (let i = 0; i < proofData.proof.length; i += 32) {
            proofFrs.push(proofData.proof.slice(i, i + 32));
        }
        // TODO reconsider API - computing the VK at this point is not optimal
        const vkResult = await this.api.circuitComputeVk({
            circuit: {
                name: 'circuit',
                bytecode: this.acirUncompressedBytecode,
            },
            settings: getProofSettingsFromOptions(options),
        });
        const { verified } = await this.api.circuitVerify({
            verificationKey: vkResult.bytes,
            publicInputs: proofData.publicInputs.map(hexToUint8Array),
            proof: proofFrs,
            settings: getProofSettingsFromOptions(options),
        });
        return verified;
    }
    async getVerificationKey(options) {
        await this.instantiate();
        const vkResult = await this.api.circuitComputeVk({
            circuit: {
                name: 'circuit',
                bytecode: Buffer.from(this.acirUncompressedBytecode),
            },
            settings: getProofSettingsFromOptions(options),
        });
        return vkResult.bytes;
    }
    /** @description Returns a solidity verifier */
    async getSolidityVerifier(vk, options) {
        await this.instantiate();
        const result = await this.api.circuitWriteSolidityVerifier({
            verificationKey: vk,
            settings: getProofSettingsFromOptions(options),
        });
        return result.solidityCode;
    }
    // TODO(https://github.com/noir-lang/noir/issues/5661): Update this to handle Honk recursive aggregation in the browser once it is ready in the backend itself
    async generateRecursiveProofArtifacts(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _proof, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _numOfPublicInputs) {
        await this.instantiate();
        // TODO(https://github.com/noir-lang/noir/issues/5661): This needs to be updated to handle recursive aggregation.
        // There is still a proofAsFields method but we could consider getting rid of it as the proof itself
        // is a list of field elements.
        // UltraHonk also does not have public inputs directly prepended to the proof and they are still instead
        // inserted at an offset.
        // const proof = reconstructProofWithPublicInputs(proofData);
        // const proofAsFields = (await this.api.acirProofAsFieldsUltraHonk(proof)).slice(numOfPublicInputs);
        // TODO: perhaps we should put this in the init function. Need to benchmark
        // TODO how long it takes.
        const vkResult = await this.api.circuitComputeVk({
            circuit: {
                name: 'circuit',
                bytecode: Buffer.from(this.acirUncompressedBytecode),
            },
            settings: getProofSettingsFromOptions({}),
        });
        // Convert VK bytes to field elements (32-byte chunks)
        const vkAsFields = [];
        for (let i = 0; i < vkResult.bytes.length; i += 32) {
            const chunk = vkResult.bytes.slice(i, i + 32);
            vkAsFields.push(uint8ArrayToHex(chunk));
        }
        return {
            // TODO(https://github.com/noir-lang/noir/issues/5661)
            proofAsFields: [],
            vkAsFields,
            // We use an empty string for the vk hash here as it is unneeded as part of the recursive artifacts
            // The user can be expected to hash the vk inside their circuit to check whether the vk is the circuit
            // they expect
            vkHash: uint8ArrayToHex(vkResult.hash),
        };
    }
    async destroy() {
        if (!this.api) {
            return;
        }
        await this.api.destroy();
    }
}
export class AztecClientBackend {
    constructor(acirBuf, options = { threads: 1 }) {
        this.acirBuf = acirBuf;
        this.options = options;
    }
    /** @ignore */
    async instantiate() {
        if (!this.api) {
            const api = await Barretenberg.new(this.options);
            await api.initSRSClientIVC();
            this.api = api;
        }
    }
    async prove(witnessBuf, vksBuf = []) {
        if (vksBuf.length !== 0 && this.acirBuf.length !== witnessBuf.length) {
            throw new AztecClientBackendError('Witness and bytecodes must have the same stack depth!');
        }
        if (vksBuf.length !== 0 && vksBuf.length !== witnessBuf.length) {
            // NOTE: we allow 0 as an explicit 'I have no VKs'. This is a deprecated feature.
            throw new AztecClientBackendError('Witness and VKs must have the same stack depth!');
        }
        await this.instantiate();
        // Queue IVC start with the number of circuits
        this.api.clientIvcStart({ numCircuits: this.acirBuf.length });
        // Queue load and accumulate for each circuit
        for (let i = 0; i < this.acirBuf.length; i++) {
            const bytecode = this.acirBuf[i];
            const witness = witnessBuf[i] || Buffer.from([]);
            const vk = vksBuf[i] || Buffer.from([]);
            const functionName = `unknown_wasm_${i}`;
            // Load the circuit
            this.api.clientIvcLoad({
                circuit: {
                    name: functionName,
                    bytecode: Buffer.from(bytecode),
                    verificationKey: Buffer.from(vk),
                },
            });
            // Accumulate with witness
            this.api.clientIvcAccumulate({
                witness: Buffer.from(witness),
            });
        }
        // Generate the proof (and wait for all previous steps to finish)
        const proveResult = await this.api.clientIvcProve({});
        // The API currently expects a msgpack-encoded API.
        const proof = new Encoder({ useRecords: false }).encode(fromClientIVCProof(proveResult.proof));
        // Generate the VK
        const vkResult = await this.api.clientIvcComputeIvcVk({
            circuit: {
                name: 'hiding',
                bytecode: this.acirBuf[this.acirBuf.length - 1],
            },
        });
        const proofFields = [
            proveResult.proof.megaProof,
            proveResult.proof.goblinProof.mergeProof,
            proveResult.proof.goblinProof.eccvmProof.preIpaProof,
            proveResult.proof.goblinProof.eccvmProof.ipaProof,
            proveResult.proof.goblinProof.translatorProof,
        ].flat();
        // Note: Verification may not work correctly until we properly serialize the proof
        if (!(await this.verify(proof, vkResult.bytes))) {
            throw new AztecClientBackendError('Failed to verify the private (ClientIVC) transaction proof!');
        }
        return [proofFields, proof, vkResult.bytes];
    }
    async verify(proof, vk) {
        await this.instantiate();
        const result = await this.api.clientIvcVerify({
            proof: toClientIVCProof(new Decoder({ useRecords: false }).decode(proof)),
            vk: Buffer.from(vk),
        });
        return result.valid;
    }
    async gates() {
        await this.instantiate();
        const circuitSizes = [];
        for (const buf of this.acirBuf) {
            const gates = await this.api.clientIvcStats({
                circuit: {
                    name: 'circuit',
                    bytecode: buf,
                },
                includeGatesPerOpcode: false,
            });
            circuitSizes.push(gates.circuitSize);
        }
        return circuitSizes;
    }
    async destroy() {
        if (!this.api) {
            return;
        }
        await this.api.destroy();
    }
}
// Converts bytecode from a base64 string to a Uint8Array
function acirToUint8Array(base64EncodedBytecode) {
    const compressedByteCode = base64Decode(base64EncodedBytecode);
    return ungzip(compressedByteCode);
}
// Since this is a simple function, we can use feature detection to
// see if we are in the nodeJs environment or the browser environment.
function base64Decode(input) {
    if (typeof Buffer !== 'undefined') {
        // Node.js environment
        const b = Buffer.from(input, 'base64');
        return new Uint8Array(b.buffer, b.byteOffset, b.byteLength);
    }
    else if (typeof atob === 'function') {
        // Browser environment
        return Uint8Array.from(atob(input), c => c.charCodeAt(0));
    }
    else {
        throw new Error('No implementation found for base64 decoding.');
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja2VuZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9iYXJyZXRlbmJlcmcvYmFja2VuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQWtCLFlBQVksRUFBa0IsTUFBTSxZQUFZLENBQUM7QUFDMUUsT0FBTyxFQUFhLGVBQWUsRUFBRSxlQUFlLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNoRixPQUFPLEVBQUUsa0JBQWtCLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUN2RixPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzlCLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFDaEMsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFFNUMsTUFBTSxPQUFPLHVCQUF3QixTQUFRLEtBQUs7SUFDaEQsWUFBWSxPQUFlO1FBQ3pCLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNqQixDQUFDO0NBQ0Y7QUE0QkQsU0FBUywyQkFBMkIsQ0FBQyxPQUFpQztJQU1wRSxPQUFPO1FBQ0wsZUFBZSxFQUFFLEtBQUs7UUFDdEIsY0FBYyxFQUNaLE9BQU8sRUFBRSxNQUFNLElBQUksT0FBTyxFQUFFLFFBQVE7WUFDbEMsQ0FBQyxDQUFDLFFBQVE7WUFDVixDQUFDLENBQUMsT0FBTyxFQUFFLFFBQVEsSUFBSSxPQUFPLEVBQUUsVUFBVTtnQkFDeEMsQ0FBQyxDQUFDLFVBQVU7Z0JBQ1osQ0FBQyxDQUFDLFdBQVc7UUFDbkIsc0RBQXNEO1FBQ3RELFNBQVMsRUFBRSxPQUFPLEVBQUUsTUFBTSxJQUFJLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSztRQUM5RCx5QkFBeUIsRUFBRSxLQUFLO0tBQ2pDLENBQUM7QUFDSixDQUFDO0FBRUQsTUFBTSxPQUFPLHdCQUF3QjtJ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