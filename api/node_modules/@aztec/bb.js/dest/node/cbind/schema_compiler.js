/**
 * Unified schema compiler with integrated strategies
 */
// Helper functions
function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.substring(1);
}
function camelCase(s) {
    return s
        .split('_')
        .map((part, index) => (index === 0 ? part.charAt(0).toLowerCase() + part.substring(1) : capitalize(part)))
        .join('');
}
function pascalCase(s) {
    return s.split('_').map(capitalize).join('');
}
export class SchemaCompiler {
    constructor(config) {
        this.config = config;
        this.typeCache = new Map();
        this.functionMetadata = [];
        // WORKTODO(bbapi): AI slop fixup - redundant with typeCache, remove
        this.referencedTypes = new Set();
    }
    /**
     * Process API schema and extract function metadata
     */
    processApiSchema(commandsSchema, responsesSchema) {
        // Process types
        this.processSchema(commandsSchema);
        this.processSchema(responsesSchema);
        // Extract function metadata from named unions
        if (!Array.isArray(commandsSchema) ||
            commandsSchema[0] !== 'named_union' ||
            !Array.isArray(responsesSchema) ||
            responsesSchema[0] !== 'named_union') {
            throw new Error('Expected named_union schema format');
        }
        const commands = commandsSchema[1];
        const responses = responsesSchema[1];
        for (let i = 0; i < commands.length; i++) {
            const [commandName] = commands[i];
            const [responseName] = responses[i];
            this.functionMetadata.push({
                name: camelCase(commandName),
                commandType: pascalCase(commandName),
                responseType: pascalCase(responseName),
            });
        }
    }
    /**
     * Process a schema and populate type cache
     */
    processSchema(schema) {
        const key = this.getSchemaKey(schema);
        if (this.typeCache.has(key)) {
            const ret = this.typeCache.get(key);
            if (ret.typeName === 'unknown') {
                throw new Error(`Recursive schema detected at ${key}, please check your schema for circular references.`);
            }
            return ret;
        }
        this.typeCache.set(key, { typeName: 'unknown', msgpackTypeName: '' });
        const typeInfo = this.generateTypeInfo(schema);
        this.typeCache.set(key, typeInfo);
        return typeInfo;
    }
    /**
     * Generate the complete output
     */
    compile() {
        const parts = ['// AUTOGENERATED FILE - DO NOT EDIT', ''];
        // Generate imports
        parts.push(...this.generateImports());
        parts.push('');
        // Generate type declarations only for 'types' mode
        if (this.config.mode === 'types') {
            const sortedTypes = Array.from(this.typeCache.values())
                .filter(t => t.declaration)
                .sort((a, b) => a.typeName.localeCompare(b.typeName));
            // Group declarations
            const typeAliases = sortedTypes.filter(t => t.declaration?.startsWith('export type') && !t.declaration?.includes('interface'));
            const publicInterfaces = sortedTypes.filter(t => t.declaration?.includes('export interface'));
            const privateInterfaces = sortedTypes.filter(t => t.declaration?.includes('interface Msgpack'));
            // Add type aliases if needed
            if (typeAliases.length > 0) {
                parts.push('// Type aliases');
                for (const type of typeAliases) {
                    parts.push(type.declaration);
                }
                parts.push('');
            }
            // Add tuple helper if needed
            if (this.needsTupleHelper()) {
                parts.push('// Tuple type for fixed-size arrays', 'type Tuple<T, N extends number> = N extends N ? (number extends N ? T[] : _TupleOf<T, N, []>) : never;', "type _TupleOf<T, N extends number, R extends unknown[]> = R['length'] extends N ? R : _TupleOf<T, N, [T, ...R]>;", '', '// Helper functions', 'function mapTuple<T, S, N extends number>(tuple: Tuple<T, N>, fn: (item: T) => S): Tuple<S, N> {', '  return tuple.map(fn) as Tuple<S, N>;', '}', '');
            }
            // Add public interfaces
            if (publicInterfaces.length > 0) {
                parts.push('// Public interfaces (exported)');
                for (const type of publicInterfaces) {
                    parts.push(type.declaration, '');
                }
            }
            // Add private interfaces
            if (privateInterfaces.length > 0) {
                parts.push('// Private Msgpack interfaces (not exported)');
                for (const type of privateInterfaces) {
                    parts.push(type.declaration, '');
                }
            }
            // Add conversion functions (only for api_types.ts)
            const conversions = sortedTypes.filter(t => t.toMethod || t.fromMethod);
            if (conversions.length > 0) {
                parts.push('// Conversion functions (exported)');
                for (const type of conversions) {
                    if (type.toMethod) {
                        parts.push('export ' + type.toMethod, '');
                    }
                    if (type.fromMethod) {
                        parts.push('export ' + type.fromMethod, '');
                    }
                }
            }
            // Add BbApiBase interface
            if (this.functionMetadata.length > 0) {
                parts.push('', '// Base API interface');
                parts.push(this.generateBbApiBaseInterface());
            }
        }
        // Add API class for non-types modes
        if (this.config.mode !== 'types' && this.functionMetadata.length > 0) {
            parts.push(this.generateApiClass());
        }
        return parts.join('\n') + '\n';
    }
    getSchemaKey(schema) {
        if (typeof schema === 'string')
            return schema;
        if (Array.isArray(schema))
            return JSON.stringify(schema);
        if (typeof schema === 'object')
            return schema.__typename || JSON.stringify(schema);
        return String(schema);
    }
    needsTupleHelper() {
        return Array.from(this.typeCache.values()).some(t => t.typeName.includes('Tuple<'));
    }
    trackTypeUsage(typeName) {
        // Only track for API modes
        if (this.config.mode === 'types')
            return;
        // Extract base types from complex types
        const baseTypes = this.extractBaseTypes(typeName);
        for (const type of baseTypes) {
            // Skip built-in types
            if (['string', 'number', 'boolean', 'Uint8Array'].includes(type)) {
                continue;
            }
            this.referencedTypes.add(type);
        }
    }
    extractBaseTypes(typeName) {
        const types = [];
        // Handle arrays
        const arrayMatch = typeName.match(/^(.+)\[\]$/);
        if (arrayMatch) {
            types.push(...this.extractBaseTypes(arrayMatch[1]));
            return types;
        }
        // Handle Tuple
        const tupleMatch = typeName.match(/^Tuple<(.+),\s*\d+>$/);
        if (tupleMatch) {
            types.push(...this.extractBaseTypes(tupleMatch[1]));
            return types;
        }
        // Handle Record
        const recordMatch = typeName.match(/^Record<(.+),\s*(.+)>$/);
        if (recordMatch) {
            types.push(...this.extractBaseTypes(recordMatch[1]));
            types.push(...this.extractBaseTypes(recordMatch[2]));
            return types;
        }
        // Handle union types
        if (typeName.includes(' | ')) {
            const parts = typeName.split(' | ');
            for (const part of parts) {
                types.push(...this.extractBaseTypes(part.trim()));
            }
            return types;
        }
        // Base case - simple type
        types.push(typeName);
        return types;
    }
    generateTypeInfo(schema) {
        if (Array.isArray(schema)) {
            return this.processArraySchema(schema);
        }
        else if (typeof schema === 'string') {
            return this.processPrimitiveSchema(schema);
        }
        else if (typeof schema === 'object') {
            return this.processObjectSchema(schema);
        }
        throw new Error(`Unsupported schema type: ${schema}`);
    }
    processArraySchema(schema) {
        const [type, ...args] = schema;
        switch (type) {
            case 'array': {
                const [subtype, size] = args[0];
                // Special case: byte arrays should be Uint8Array
                if (subtype === 'unsigned char') {
                    return { typeName: 'Uint8Array' };
                }
                // For other types, use T[] - idiomatic TypeScript for fixed-length homogeneous arrays
                const subtypeInfo = this.processSchema(subtype);
                return {
                    typeName: `${subtypeInfo.typeName}[]`,
                    msgpackTypeName: `${subtypeInfo.msgpackTypeName || subtypeInfo.typeName}[]`,
                };
            }
            case 'variant': {
                const variants = args[0];
                const variantInfos = variants.map(v => this.processSchema(v));
                const typeName = variantInfos.map(v => v.typeName).join(' | ');
                const msgpackUnion = variantInfos.map(v => v.msgpackTypeName || v.typeName).join(' | ');
                return {
                    typeName,
                    msgpackTypeName: `[number, ${msgpackUnion}]`,
                };
            }
            case 'named_union': {
                const namedTypes = args[0];
                const tupleTypes = [];
                for (const [name, schemaOrName] of namedTypes) {
                    let typeInfo = this.processSchema(schemaOrName);
                    // Track usage of the type
                    this.trackTypeUsage(typeInfo.typeName);
                    tupleTypes.push(`["${name}", ${typeInfo.typeName}]`);
                }
                return {
                    typeName: tupleTypes.join(' | '),
                    msgpackTypeName: tupleTypes.join(' | '),
                };
            }
            case 'vector': {
                const [subtype] = args[0];
                if (subtype === 'unsigned char') {
                    return { typeName: 'Uint8Array' };
                }
                const subtypeInfo = this.processSchema(subtype);
                return {
                    typeName: `${subtypeInfo.typeName}[]`,
                    msgpackTypeName: `${subtypeInfo.msgpackTypeName || subtypeInfo.typeName}[]`,
                };
            }
            case 'alias': {
                const [rawTypeName, msgpackName] = args[0];
                const typeName = pascalCase(rawTypeName);
                let targetType;
                if (msgpackName.startsWith('bin')) {
                    targetType = 'Uint8Array';
                }
                else if (['int', 'unsigned int', 'unsigned short'].includes(msgpackName)) {
                    targetType = 'number';
                }
                else {
                    throw new Error(`Unsupported alias type: ${msgpackName}`);
                }
                // Create a proper type alias declaration
                return {
                    typeName,
                    msgpackTypeName: targetType,
                    declaration: `export type ${typeName} = ${targetType};`,
                };
            }
            case 'shared_ptr': {
                const [subtype] = args[0];
                return this.processSchema(subtype);
            }
            case 'map': {
                const [keyType, valueType] = args[0];
                const keyInfo = this.processSchema(keyType);
                const valueInfo = this.processSchema(valueType);
                return {
                    typeName: `Record<${keyInfo.typeName}, ${valueInfo.typeName}>`,
                    msgpackTypeName: `Record<${keyInfo.msgpackTypeName || keyInfo.typeName}, ${valueInfo.msgpackTypeName || valueInfo.typeName}>`,
                };
            }
            default:
                throw new Error(`Unsupported array schema type: ${type}`);
        }
    }
    processPrimitiveSchema(schema) {
        switch (schema) {
            case 'bool':
                return { typeName: 'boolean' };
            case 'int':
            case 'unsigned int':
            case 'unsigned short':
            case 'unsigned long':
            case 'unsigned char':
            case 'double':
                return { typeName: 'number' };
            case 'string':
                return { typeName: 'string' };
            case 'bin32':
                return { typeName: 'Uint8Array' };
            default:
                return { typeName: pascalCase(schema) };
        }
    }
    processObjectSchema(schema) {
        const typeName = pascalCase(schema.__typename);
        const msgpackTypeName = 'Msgpack' + typeName;
        const declaration = this.generateInterfaces(typeName, schema);
        const toMethod = this.generateToMethod(typeName, schema);
        const fromMethod = this.generateFromMethod(typeName, schema);
        return {
            typeName,
            msgpackTypeName,
            declaration,
            toMethod,
            fromMethod,
        };
    }
    getOrCreateEmptyType(typeName) {
        const key = `empty_${typeName}`;
        if (this.typeCache.has(key)) {
            return this.typeCache.get(key);
        }
        const typeInfo = {
            typeName,
            msgpackTypeName: 'Msgpack' + typeName,
            declaration: `export interface ${typeName} {}\n\ninterface Msgpack${typeName} {}`,
            toMethod: `function to${typeName}(o: Msgpack${typeName}): ${typeName} {\n  return {};\n}`,
            fromMethod: `function from${typeName}(o: ${typeName}): Msgpack${typeName} {\n  return {};\n}`,
        };
        this.typeCache.set(key, typeInfo);
        return typeInfo;
    }
    generateInterfaces(name, schema) {
        const publicInterface = this.generatePublicInterface(name, schema);
        const msgpackInterface = this.generateMsgpackInterface(name, schema);
        return publicInterface + '\n\n' + msgpackInterface;
    }
    generatePublicInterface(name, schema) {
        let result = `export interface ${name} {\n`;
        for (const [key, value] of Object.entries(schema)) {
            if (key === '__typename')
                continue;
            const typeInfo = this.processSchema(value);
            // Track type usage
            this.trackTypeUsage(typeInfo.typeName);
            result += `  ${camelCase(key)}: ${typeInfo.typeName};\n`;
        }
        result += '}';
        return result;
    }
    generateMsgpackInterface(name, schema) {
        let result = `interface Msgpack${name} {\n`;
        for (const [key, value] of Object.entries(schema)) {
            if (key === '__typename')
                continue;
            const typeInfo = this.processSchema(value);
            result += `  ${key}: ${typeInfo.msgpackTypeName || typeInfo.typeName};\n`;
        }
        result += '}';
        return result;
    }
    generateToMethod(name, schema) {
        const fields = Object.entries(schema).filter(([key]) => key !== '__typename');
        if (fields.length === 0) {
            return `function to${name}(o: Msgpack${name}): ${name} {\n  return {};\n}`;
        }
        const checks = fields
            .map(([key]) => `  if (o.${key} === undefined) { throw new Error("Expected ${key} in ${name} deserialization"); }`)
            .join('\n');
        const conversions = fields
            .map(([key, value]) => {
            const typeInfo = this.processSchema(value);
            const converter = this.generateConverter(typeInfo, `o.${key}`, 'to');
            return `    ${camelCase(key)}: ${converter},`;
        })
            .join('\n');
        return `function to${name}(o: Msgpack${name}): ${name} {
${checks};
  return {
${conversions}
  };
}`;
    }
    generateFromMethod(name, schema) {
        const fields = Object.entries(schema).filter(([key]) => key !== '__typename');
        if (fields.length === 0) {
            return `function from${name}(o: ${name}): Msgpack${name} {\n  return {};\n}`;
        }
        const checks = fields
            .map(([key]) => `  if (o.${camelCase(key)} === undefined) { throw new Error("Expected ${camelCase(key)} in ${name} serialization"); }`)
            .join('\n');
        const conversions = fields
            .map(([key, value]) => {
            const typeInfo = this.processSchema(value);
            const converter = this.generateConverter(typeInfo, `o.${camelCase(key)}`, 'from');
            return `  ${key}: ${converter},`;
        })
            .join('\n');
        return `function from${name}(o: ${name}): Msgpack${name} {
${checks};
  return {
${conversions}
  };
}`;
    }
    generateConverter(typeInfo, value, direction) {
        // Handle arrays/tuples
        if (typeInfo.typeName.includes('[]') || typeInfo.typeName.includes('Tuple<')) {
            const elementType = typeInfo.typeName.match(/^(.+)\[\]$/) || typeInfo.typeName.match(/^Tuple<(.+),/);
            if (elementType) {
                const isTuple = typeInfo.typeName.includes('Tuple<');
                const mapFn = isTuple ? 'mapTuple' : 'map';
                return `${value}.${mapFn}((v: any) => v)`; // Simplified for now
            }
        }
        // Handle custom types that have conversion methods (not just type aliases)
        if (typeInfo.toMethod || typeInfo.fromMethod) {
            return `${direction}${typeInfo.typeName}(${value})`;
        }
        return value;
    }
    generateImports() {
        const imports = [];
        // Base imports
        if (this.config.imports) {
            imports.push(...this.config.imports);
        }
        // For API modes, import from api_types
        if (this.config.mode !== 'types') {
            const neededImports = new Set();
            // Add types and conversion functions from function metadata
            for (const metadata of this.functionMetadata) {
                neededImports.add(metadata.commandType);
                neededImports.add(metadata.responseType);
                neededImports.add(`from${metadata.commandType}`);
                neededImports.add(`to${metadata.responseType}`);
            }
            // Add referenced types
            for (const type of this.referencedTypes) {
                neededImports.add(type);
            }
            // Add BbApiBase interface
            neededImports.add('BbApiBase');
            if (neededImports.size > 0) {
                const sortedImports = Array.from(neededImports).sort();
                // Remove duplicates
                const uniqueImports = sortedImports.filter((item, index) => sortedImports.indexOf(item) === index);
                imports.push(`import { ${uniqueImports.join(', ')} } from './api_types.js';`);
            }
        }
        return imports;
    }
    generateBbApiBaseInterface() {
        const methods = this.functionMetadata
            .map(m => `  ${m.name}(command: ${m.commandType}): Promise<${m.responseType}>;`)
            .join('\n');
        return `export interface BbApiBase {
${methods}
  destroy(): Promise<void>;
}`;
    }
    generateApiClass() {
        const className = this.getApiClassName();
        const methods = this.functionMetadata.map(m => this.generateApiMethod(m)).join('\n\n');
        // For sync API, don't implement BbApiBase since methods are synchronous
        const implementsClause = this.config.mode === 'sync' ? '' : ' implements BbApiBase';
        // For tracing all calls to bb.
        // const msgpackCallHelper =
        //   `${this.config.mode === 'async' ? 'async ' : ''}function msgpackCall(backend: ${this.getBackendType()}, input: any[]) {\n` +
        //   `  const commandName = input[0]?.[0] || 'unknown';\n` +
        //   `  process.stderr.write(\`[BB MSGPACK ${this.config.mode === 'async' ? 'ASYNC' : 'SYNC'}] \${commandName}\\n\`);\n` +
        //   `  const inputBuffer = new Encoder({ useRecords: false }).pack(input);\n` +
        //   `  const encodedResult = ${this.config.mode === 'async' ? 'await ' : ''}backend.call(inputBuffer);\n` +
        //   `  const result = new Decoder({ useRecords: false }).unpack(encodedResult);\n` +
        //   `  process.stderr.write(\`[BB MSGPACK ${this.config.mode === 'async' ? 'ASYNC' : 'SYNC'}] \${commandName} => completed\\n\`);\n` +
        //   `  return result;\n` +
        //   `}\n`;
        const msgpackCallHelper = `${this.config.mode === 'async' ? 'async ' : ''}function msgpackCall(backend: ${this.getBackendType()}, input: any[]) {` +
            `  const inputBuffer = new Encoder({ useRecords: false }).pack(input);` +
            `  const encodedResult = ${this.config.mode === 'async' ? 'await ' : ''}backend.call(inputBuffer);` +
            `  return new Decoder({ useRecords: false }).unpack(encodedResult);` +
            `}\n`;
        const destroyMethod = this.config.mode === 'sync'
            ? `  destroy(): void {
    if (this.backend.destroy) this.backend.destroy();
  }`
            : `  destroy(): Promise<void> {
    return this.backend.destroy ? this.backend.destroy() : Promise.resolve();
  }`;
        return (msgpackCallHelper +
            `export class ${className}${implementsClause} {
  constructor(protected backend: ${this.getBackendType()}) {}

${methods}

${destroyMethod}
}`);
    }
    getApiClassName() {
        switch (this.config.mode) {
            case 'sync':
                return 'SyncApi';
            case 'async':
                return 'AsyncApi';
            default:
                throw new Error(`Invalid mode: ${this.config.mode}`);
        }
    }
    getBackendType() {
        switch (this.config.mode) {
            case 'sync':
                return 'IMsgpackBackendSync';
            case 'async':
                return 'IMsgpackBackendAsync';
            default:
                return '';
        }
    }
    generateApiMethod(metadata) {
        const { name, commandType, responseType } = metadata;
        // For async mode, queue immediately and return promise
        if (this.config.mode === 'async') {
            return `  ${name}(command: ${commandType}): Promise<${responseType}> {
    const msgpackCommand = from${commandType}(command);
    return msgpackCall(this.backend, [["${capitalize(name)}", msgpackCommand]]).then(([variantName, result]: [string, any]) => {
      if (variantName !== '${responseType}') {
        throw new Error(\`Expected variant name '${responseType}' but got '\${variantName}'\`);
      }
      return to${responseType}(result);
    });
  }`;
        }
        // For sync mode, keep the synchronous behavior
        return `  ${name}(command: ${commandType}): ${responseType} {
    const msgpackCommand = from${commandType}(command);
    const [variantName, result] = msgpackCall(this.backend, [["${capitalize(name)}", msgpackCommand]]);
    if (variantName !== '${responseType}') {
      throw new Error(\`Expected variant name '${responseType}' but got '\${variantName}'\`);
    }
    return to${responseType}(result);
  }`;
    }
}
// Factory methods for creating configured compilers
export function createSharedTypesCompiler() {
    return new SchemaCompiler({
        mode: 'types',
        imports: [],
    });
}
export function createSyncApiCompiler() {
    return new SchemaCompiler({
        mode: 'sync',
        imports: [
            `import { IMsgpackBackendSync } from '../../bb_backends/interface.js';`,
            `import { Decoder, Encoder } from 'msgpackr';`,
        ],
    });
}
export function createAsyncApiCompiler() {
    return new SchemaCompiler({
        mode: 'async',
        imports: [
            `import { IMsgpackBackendAsync } from '../../bb_backends/interface.js';`,
            `import { Decoder, Encoder } from 'msgpackr';`,
        ],
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NoZW1hX2NvbXBpbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NiaW5kL3NjaGVtYV9jb21waWxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7R0FFRztBQXVDSCxtQkFBbUI7QUFDbkIsU0FBUyxVQUFVLENBQUMsQ0FBUztJQUMzQixPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLEdBQUcsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNwRCxDQUFDO0FBRUQsU0FBUyxTQUFTLENBQUMsQ0FBUztJQUMxQixPQUFPLENBQUM7U0FDTCxLQUFLLENBQUMsR0FBRyxDQUFDO1NBQ1YsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQyxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQ3pHLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUNkLENBQUM7QUFFRCxTQUFTLFVBQVUsQ0FBQyxDQUFTO0lBQzNCLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQy9DLENBQUM7QUFFRCxNQUFNLE9BQU8sY0FBYztJQU16QixZQUFvQixNQUFzQjtRQUF0QixXQUFNLEdBQU4sTUFBTSxDQUFnQjtRQUxsQyxjQUFTLEdBQUcsSUFBSSxHQUFHLEVBQW9CLENBQUM7UUFDeEMscUJBQWdCLEdBQXVCLEVBQUUsQ0FBQztRQUNsRCxvRUFBb0U7UUFDNUQsb0JBQWUsR0FBRyxJ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