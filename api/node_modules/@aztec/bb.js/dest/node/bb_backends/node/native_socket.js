import { spawn } from 'child_process';
import * as net from 'net';
import * as fs from 'fs';
import * as os from 'os';
import * as path from 'path';
import { findPackageRoot } from './platform.js';
/**
 * Asynchronous native backend that communicates with bb binary via Unix Domain Socket.
 * Uses event-based I/O with a state machine to handle partial reads.
 *
 * Architecture: bb acts as the SERVER, TypeScript is the CLIENT
 * - bb creates the socket and listens for connections
 * - TypeScript waits for socket file to exist, then connects
 *
 * Protocol:
 * - Request: 4-byte little-endian length + msgpack buffer
 * - Response: 4-byte little-endian length + msgpack buffer
 */
export class BarretenbergNativeSocketAsyncBackend {
    constructor(bbBinaryPath, threads) {
        this.socket = null;
        this.connectionTimeout = null;
        // Queue of pending callbacks for pipelined requests
        // Responses come back in FIFO order, so we match them with queued callbacks
        this.pendingCallbacks = [];
        // State machine for reading responses
        this.readingLength = true;
        this.lengthBuffer = Buffer.alloc(4);
        this.lengthBytesRead = 0;
        this.responseLength = 0;
        this.responseBuffer = null;
        this.responseBytesRead = 0;
        // Create a unique socket path in temp directory
        this.socketPath = path.join(os.tmpdir(), `bb-${process.pid}-${Date.now()}.sock`);
        // Ensure socket path doesn't already exist (cleanup from previous crashes)
        if (fs.existsSync(this.socketPath)) {
            fs.unlinkSync(this.socketPath);
        }
        let connectionResolve = null;
        let connectionReject = null;
        this.connectionPromise = new Promise((resolve, reject) => {
            connectionResolve = resolve;
            connectionReject = reject;
        });
        // Set HARDWARE_CONCURRENCY if threads specified
        const env = threads !== undefined ? { ...process.env, HARDWARE_CONCURRENCY: threads.toString() } : process.env;
        // Spawn bb process - it will create the socket server
        const args = [bbBinaryPath, 'msgpack', 'run', '--input', this.socketPath];
        this.process = spawn(findPackageRoot() + '/scripts/kill_wrapper.sh', args, {
            stdio: ['ignore', 'ignore', 'ignore'],
            env,
        });
        // Disconnect from event loop so process can exit. The kill wrapper will reap bb once parent (node) dies.
        this.process.unref();
        this.process.on('error', err => {
            if (connectionReject) {
                connectionReject(new Error(`Native backend process error: ${err.message}`));
                connectionReject = null;
                connectionResolve = null;
            }
            // Reject all pending callbacks
            const error = new Error(`Native backend process error: ${err.message}`);
            for (const callback of this.pendingCallbacks) {
                callback.reject(error);
            }
            this.pendingCallbacks = [];
        });
        this.process.on('exit', (code, signal) => {
            const errorMsg = code !== null && code !== 0
                ? `Native backend process exited with code ${code}`
                : signal && signal !== 'SIGTERM'
                    ? `Native backend process killed with signal ${signal}`
                    : 'Native backend process exited unexpectedly';
            if (connectionReject) {
                connectionReject(new Error(errorMsg));
                connectionReject = null;
                connectionResolve = null;
            }
            // Reject all pending callbacks
            const error = new Error(errorMsg);
            for (const callback of this.pendingCallbacks) {
                callback.reject(error);
            }
            this.pendingCallbacks = [];
        });
        // Wait for bb to create socket file, then connect
        this.waitForSocketAndConnect()
            .then(() => {
            if (connectionResolve) {
                connectionResolve();
                connectionResolve = null;
                connectionReject = null;
            }
        })
            .catch(err => {
            if (connectionReject) {
                connectionReject(err);
                connectionReject = null;
                connectionResolve = null;
            }
        });
        // Set a timeout for connection
        this.connectionTimeout = setTimeout(() => {
            if (connectionReject) {
                connectionReject(new Error('Timeout waiting for bb socket connection'));
                connectionReject = null;
                connectionResolve = null;
                this.cleanup();
            }
        }, 5000);
    }
    async waitForSocketAndConnect() {
        // Poll for socket file to exist (bb is creating it)
        const startTime = Date.now();
        while (!fs.existsSync(this.socketPath)) {
            if (Date.now() - startTime > 5000) {
                throw new Error('Timeout waiting for bb to create socket file');
            }
            await new Promise(resolve => setTimeout(resolve, 50));
        }
        // Additional check: ensure it's actually a socket
        const stats = fs.statSync(this.socketPath);
        if (!stats.isSocket()) {
            throw new Error(`Path exists but is not a socket: ${this.socketPath}`);
        }
        // Connect to bb's socket server as a client
        return new Promise((resolve, reject) => {
            this.socket = net.connect(this.socketPath);
            // Disable Nagle's algorithm for lower latency
            this.socket.setNoDelay(true);
            // Set up event handlers
            this.socket.once('connect', () => {
                this.socket.unref();
                // Clear connection timeout on successful connection
                if (this.connectionTimeout) {
                    clearTimeout(this.connectionTimeout);
                    this.connectionTimeout = null;
                }
                resolve();
            });
            this.socket.once('error', err => {
                reject(new Error(`Failed to connect to bb socket: ${err.message}`));
            });
            // Set up data handler after connection is established
            this.socket.on('data', (chunk) => {
                this.handleData(chunk);
            });
            // Handle ongoing errors after initial connection
            this.socket.on('error', err => {
                // Reject all pending callbacks
                const error = new Error(`Socket error: ${err.message}`);
                for (const callback of this.pendingCallbacks) {
                    callback.reject(error);
                }
                this.pendingCallbacks = [];
            });
            this.socket.on('end', () => {
                // Reject all pending callbacks
                const error = new Error('Socket connection ended unexpectedly');
                for (const callback of this.pendingCallbacks) {
                    callback.reject(error);
                }
                this.pendingCallbacks = [];
            });
        });
    }
    handleData(chunk) {
        let offset = 0;
        while (offset < chunk.length) {
            if (this.readingLength) {
                // Reading 4-byte length prefix
                const bytesToCopy = Math.min(4 - this.lengthBytesRead, chunk.length - offset);
                chunk.copy(this.lengthBuffer, this.lengthBytesRead, offset, offset + bytesToCopy);
                this.lengthBytesRead += bytesToCopy;
                offset += bytesToCopy;
                if (this.lengthBytesRead === 4) {
                    // Length is complete, switch to reading data
                    this.responseLength = this.lengthBuffer.readUInt32LE(0);
                    this.responseBuffer = Buffer.alloc(this.responseLength);
                    this.responseBytesRead = 0;
                    this.readingLength = false;
                }
            }
            else {
                // Reading response data
                const bytesToCopy = Math.min(this.responseLength - this.responseBytesRead, chunk.length - offset);
                chunk.copy(this.responseBuffer, this.responseBytesRead, offset, offset + bytesToCopy);
                this.responseBytesRead += bytesToCopy;
                offset += bytesToCopy;
                if (this.responseBytesRead === this.responseLength) {
                    // Response is complete - dequeue the next pending callback (FIFO)
                    const callback = this.pendingCallbacks.shift();
                    if (callback) {
                        callback.resolve(new Uint8Array(this.responseBuffer));
                    }
                    else {
                        // This shouldn't happen - response without a pending request
                        console.warn('Received response but no pending callback');
                    }
                    // Reset state for next message
                    this.readingLength = true;
                    this.lengthBytesRead = 0;
                    this.responseLength = 0;
                    this.responseBuffer = null;
                    this.responseBytesRead = 0;
                }
            }
        }
    }
    async call(inputBuffer) {
        // Wait for connection to be established
        await this.connectionPromise;
        if (!this.socket) {
            throw new Error('Socket not connected');
        }
        return new Promise((resolve, reject) => {
            // Enqueue this promise's callbacks (FIFO order)
            this.pendingCallbacks.push({ resolve, reject });
            // Write request: 4-byte little-endian length + msgpack data
            // Socket will buffer these if needed, maintaining order
            const lengthBuf = Buffer.alloc(4);
            lengthBuf.writeUInt32LE(inputBuffer.length, 0);
            this.socket.write(lengthBuf);
            this.socket.write(inputBuffer);
        });
    }
    cleanup() {
        // Reject any remaining pending callbacks
        const error = new Error('Backend connection closed');
        for (const callback of this.pendingCallbacks) {
            callback.reject(error);
        }
        this.pendingCallbacks = [];
        try {
            // Remove all event listeners to prevent hanging
            if (this.socket) {
                this.socket.removeAllListeners();
                // Unref so socket doesn't keep event loop alive
                // this.socket.unref();
                this.socket.destroy();
            }
        }
        catch (e) {
            // Ignore errors during cleanup
        }
        // Clear connection timeout if still pending
        if (this.connectionTimeout) {
            clearTimeout(this.connectionTimeout);
            this.connectionTimeout = null;
        }
        // Remove process event listeners and unref to not block event loop
        this.process.removeAllListeners();
        // this.process.unref();
        // Don't try to unlink socket - bb owns it and will clean it up
    }
    async destroy() {
        // Cleanup first (closes socket, unrefs everything)
        this.cleanup();
        // Send SIGTERM for graceful shutdown
        // Process is unref'd so won't block event loop - just kill and return
        try {
            this.process.kill('SIGTERM');
        }
        catch (e) {
            // Already dead
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF0aXZlX3NvY2tldC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9iYl9iYWNrZW5kcy9ub2RlL25hdGl2ZV9zb2NrZXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLEtBQUssRUFBZ0IsTUFBTSxlQUFlLENBQUM7QUFDcEQsT0FBTyxLQUFLLEdBQUcsTUFBTSxLQUFLLENBQUM7QUFDM0IsT0FBTyxLQUFLLEVBQUUsTUFBTSxJQUFJLENBQUM7QUFDekIsT0FBTyxLQUFLLEVBQUUsTUFBTSxJQUFJLENBQUM7QUFDekIsT0FBTyxLQUFLLElBQUksTUFBTSxNQUFNLENBQUM7QUFFN0IsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUVoRDs7Ozs7Ozs7Ozs7R0FXRztBQUNILE1BQU0sT0FBTyxvQ0FBb0M7SUFzQi9DLFlBQVksWUFBb0IsRUFBRSxPQUFnQjtRQXBCMUMsV0FBTSxHQUFzQixJQUFJLENBQUM7UUFHakMsc0JBQWlCLEdBQTBCLElBQUksQ0FBQztRQUV4RCxvREFBb0Q7UUFDcEQsNEVBQTRFO1FBQ3BFLHFCQUFnQixHQUduQixFQUFFLENBQUM7UUFFUixzQ0FBc0M7UUFDOUIsa0JBQWEsR0FBWSxJQUFJLENBQUM7UUFDOUIsaUJBQVksR0FBVyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZDLG9CQUFlLEdBQVcsQ0FBQyxDQUFDO1FBQzVCLG1CQUFjLEdBQVcsQ0FBQyxDQUFDO1FBQzNCLG1CQUFjLEdBQWtCLElBQUksQ0FBQztRQUNyQyxzQkFBaUIsR0FBVyxDQUFDLENBQUM7UUFHcEMsZ0RBQWdEO1FBQ2hELElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLEVBQUUsTUFBTSxPQUFPLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFF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