{
  "transpiled": true,
  "noir_version": "1.0.0-beta.14+82ec52a8c755d30ce655a2005834186a4acfa0c7-aztec",
  "name": "ContractClassRegistry",
  "functions": [
    {
      "name": "assert_class_id_is_published",
      "is_unconstrained": false,
      "custom_attributes": [
        "external",
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "contract_class_id",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::contract_class_id::ContractClassId",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log",
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "nZXdbrMwDIbvJcccxI7z11uZpoq2bEJCtGLwSZ8q7n3OhqFMSrS1Bzg0yYPt107u6tKcpvdj279dP9Th5a5OQ9t17fuxu57rsb32/O9d6fQAUgeY50rJ1HEcmibNPKxlwq0emn5Uh37qukr9q7vpa9HHre6/7FgPPKsr1fQXtgx8a7smjeZq263zW0EDLLtBO7cCwPvfIhw5syCcxQeEjjsE5hEh4kKIhp7xAYIOEkZwlPWB8ggkTwsCLcGK8HuCzRO8J1HC828lGNzL4QoI8hKHt2izCJ9HGCu5JNjEQIM7QCgkAkOURBiNWUQsyAFOnAAI9ikvPDjxwhudRaTyzbrhvVQm+JiPBAqlGclKadrwFAE04tZi+WRAoTiJnLQpUdz8gPj7ZEQtskLEfDKKXbb2KUQXsl0GvpQNY+yaDjJbiXr4A8Su1cFjizlIIRjur63VnFkJlvanVgFhgiVh8PhB2x9uYEGXwE0mBw+PjXkiFmeMpMMZq/fCvPJrfW6H/TUEln2uFDhexXqAX2xYbPy2qJPsbGGxmLRnaxZL6cBga5Odk4tDW5+6Jn0k+TH1Z/kmv47/bzIjl+NtuJ6byzQ0yb+HG5KfLywywuucYvgE",
      "verification_key": "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"
    },
    {
      "name": "broadcast_private_function",
      "is_unconstrained": false,
      "custom_attributes": [
        "external",
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "contract_class_id",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::contract_class_id::ContractClassId",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "artifact_metadata_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "utility_functions_artifact_tree_root",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "private_function_tree_sibling_path",
            "type": {
              "kind": "array",
              "length": 7,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          },
          {
            "name": "private_function_tree_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "artifact_function_tree_sibling_path",
            "type": {
              "kind": "array",
              "length": 7,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          },
          {
            "name": "artifact_function_tree_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "function_data",
            "type": {
              "kind": "struct",
              "path": "events::private_function_broadcasted::InnerPrivateFunction",
              "fields": [
                {
                  "name": "selector",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "metadata_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "vk_hash",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log",
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "rd3dblzXma3he9GxDtYYY66/3EojCJy0u2HAcAJ3soGNwPe+i2KN96OzQUKROgdZlCV9RbL4kqWaT835z0//+eOf//Hff/rpl//66/98+sN//PPTn3/96eeff/rvP/3817/88Pef/vrL47/+89P28n9an/6Q/Pb5k15+5cev9PmT99fL8Xo5Xy/X6+X+csnjb++Pi14vfr3k9bJeL/vr5Xi9nK+X6/Vyf7ms1ynrdcp6nbJep6zH3zsfl/P1cn257I/fux6X9XrZXy/H6+V8vVyvl/vL5Xi9heP1Fo7XWzgeU7Q9rut53V+v5+MP6/HBnS+/78+frpdfP/78pef18dd1PK55Xtfz+vL3H+/ddTyv5/P68il7vBPX/Xq9t+dVz6uf1zyvL/PyuO6vt38fz+v5vF7P6/161bb1DfUN940vH8PjjvXLHfvyHsav7+GX6/m8Xi/Xx5/Ky596uY+8vd5JX6736/Xlbvpy1fPq5zXP63q97i+/r9e7x369f5zXO+jL9Xxer+f1fr2+3ElfrnpeX+av1/vpy3U9ry/zXu7Ul79/P6736/XU8+rn9eWje7k/r+f1fr2+3J9fri/z7sdHvV4+6pePKnr9qKLfHv+5mfzp77/++OPLH3nTzaOmv/3w64+//P3TH375x88/f/70f374+R9f/tD//O2HX75c//7Dr4/ffdzOj7/85+P6GPhfP/3848tbv32ev729/1fP83j+5SuLv679+toB1+qtX4feHeD3B3i7/ZxgbQcjln83IR+8C8fVd+E+330X1vsD9qQT9uzzLuQ4v/qjUE4+il3vfRTHBxMuPQdke/fvf/RB+DAfxJZ3P4gPPw/HwYh7e3fE/f6IaHVEtO/fMkJSRzzenDs01/31I2JGLH3biLUYcWzvjtBHX5h327i3/f0JH9wjx57nhGNf3zbh7pfV+Sauf2vCNRPOb5pwum2cK+9O+OCbzD7fZfZ7e3t/rt+/Ex99Za70Ds1a1zfOIJDHm+c3zrhmxq3/hRn7t83Y1a+t7P7G92Pfrpnhd2d4/+i+vfbet9f9/v3i46OfYne/wK63377/ZcL5wQQ+oed9M2H/Nz4Ta+cz8btvF+urv8jvs5kcm69vGZH0Ll2erwodXx1aDvOFdZxvWtVXP6J4PEDs94vHj/O5N3SeXzviWMd82/ObEdvvP5Csj7739ifA/faBzde/EzZ92Oebb775/d2RD74u17X6hbmuDx5YfDTjq9+P64P75Lg7Q+f+wYyPfiDee1vXferdj+WjL42Lbxe6jvXu/br0wadjnf027v3Nj/bzX0b4o+8W/DQ5H/+bj8S//yJfH/xoP9fZD+Xc37T2/81YH33P6Jfo0nxtOP/ykG//6Gvj6teXs/n9GcdHD3SOeax07d82I1vfj8cjr+v9GR98jd58A318oX3ThMe/SD3fed7/SPYPvkTXOvrda603P410f8sHcu7fdreePAL2me39D+SDL9DHd7pJ/n7/S2Nf33uXfOWEDz4XH0346jv1/O479cNP5z1f4bff/3R++N2PH0m6j+vd737Hhz9ck51Px8p82zj1bwzZ519Y2777vSEfdeKNb1558wN2X9804c2X179MOD76dwUPEx5PY7z3T+aPHnH54p8Vkb7hg9g3MWE5734QH3xxPv7B3BGPJw6ub3nIta+Dh9Drfv+9uD/6lmPxLWe9uT9//8k8/xceMJ36/gdMH34yeBD8+Ly8+5V55qMRbz+h63o3kPOjB6CPn8h9pPJ4O3l3yIfvyX7cvCf7eb875IOfzvt+8szQfr155Pb178a+8e+Cx9tvPqv/zsfy+FcmT7PtXvu7Q+7vf9x1bd/7uOvS9z/uuvz9j7s+nPGVj7uu7/4hf/0v/Ii+ju/+EX1992ONDyds/Qf47W/8wvjKR2739v2P3G597536lRM++Gx+NOFrvyzu9d1fFh9+Or/ykdvH37rWNt+61nV/wyOmI+mXxvF43uz3D//++PjlD3/56dffL5vqZQntcTfoZUHz8XnQ9bzer1dvz6ueVz+veV7X87o/r8fz+pzn5zw/5+U5L895ec7Lc16e8/Kcl+e8POflOS/Pees5bz3nree89Zz3spj38qTC2p/X43l9zHu5319WYr9cH/Nevlnu2/Oql8/h4+qXJ4hel2qP51rtub8uBn65vqzrPpdrz67Xns8F2/N1MfDLVc+rn9c8r+t53Z/X43k9n9fnvOM573zOO5/zzue88znvfM47n/PO57zzOe98zjuf867nvOs573rOu57zrue86znves67nvOu57zrOe9+zruf8+7nvPs5737Ou5/z7ue8+znvfs67n/O+LAq/vqG+4b6RvrH6xt43jr5x9o2rb3SyOlmdrE5WJ6uT1cnqZHWyOlmd7E52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4+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+F8zfkVc4DFnGAxR1jMGRZziMWcYjHHWLw5x4LboHM8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsP5nhNr5siaObNmDq2ZU2vm2Jo5t2YOrpmTa94cXfO8jWxzeM2cXjPH18z5NXOAzZxgM0fYzBk2c4gNp9jg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4umtOq3hxXxW3MgVVzYtUcWTVnVs2hVXNq1RxbRed4uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgoeL53y6OaDuzQl13MacUTeH1M0pdXNM3ZxTNwfV0TkeLni44OGChwseLni44OGChwseLni44OGChwseLni44OGChwseLni44OGChwseLni44OGChwseLni44OGChwseLni44OGChwseLni44OGChwseLni44OGChwseLni44OGChwseLni44OGChwseLni44OGChwseLni44OGChwseLni44OGChwseLni44OGChwseLni44OGChwseLnPm5Bw6OadOzrGTc+7kHDw5J0/O0ZNz9uQcPjmnT87xk3P+5BxAOSdQzhGUcwblHEI5p1DOMZRzDuUcRDknUc5RlHMW5RxGOadRznGUcx7lHEj55kTKOZJyzqR8cygltzHHUs65lHMw5ZxMOUdT0vkcTjmnU87xlHM+5RxQOSdUzhGVc0blHFI5p1TOMZVzTuUcVDknVc5RlXNW5RxWOadVznGVc17lHFg5J1bOkZVzZuUcWjmnVs6xlXNu5RxcOSdXztGVc3blHF45p1fO8ZVzfuUcYDknWM4RlnOG5RxiOadYzjGWc47lHGQ5J1nOUZZzluUcZjmnWc5xlnOe5RxoOSdazpGWc6blHGo5p1rOsZZ4uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi5rzqCdQ2jnFNo5hvbNObTcxpxEO0fRzlm0cxgtnePhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi77nDo9x07PudNz8PScPP3m6GluYw6fntOn5/hpOsfDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFyOOWd+Dpqfk+bnqPk5a34Om39z2jy3MefNz4HzdI6HCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx4ueLjg4YKHCx5u4eEWHm7h4RYebuHhFh5u4eEWHm7h4RYebuHhFh5u4eEWHm7h4RYebuHhFh5u4eEWHm7h4RYebuHhFh5u4eEWHm7h4RYebuHhFh5u4eEWHm7h4RYebuHhFh5u4eEWHm7h4RYebuHhFh5u4eEWHm7h4RYebuHhFh5u4eEWHm7h4RYebuHhFh5u4eEWHm7h4RYebuHhFh5u4eEWHm7h4RYebuHhFh5u4eEWHm7h4RYebuHhFh5u4eEWHm7h4RYebuHhFh5u4eEWHm7h4RYebuHhFh5u4eHWFw9371/eOnjr5K3Hbdznb58//Z8ffv3phz///OP/fPrDPx+//K9//PKXv//011+ev/z7//1bf+fPv/70888//fef/vbrX//y43/+49cf//TzX//y8nuftpf/e4nrP3R8tv74+MN6/vf/kO/PWvcfH7W//Go7PkvH41evf1znZ9kvv9SXP/v4XV8vf98vf//lb5z+fLl//t4+3/vLb6e/7fU5q7/9+Lhvht15/tnFn70+5+qfXevz47367bff/vjb/wM=",
      "verification_key": "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"
    },
    {
      "name": "broadcast_utility_function",
      "is_unconstrained": false,
      "custom_attributes": [
        "external",
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "contract_class_id",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::contract_class_id::ContractClassId",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "artifact_metadata_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "private_functions_artifact_tree_root",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "artifact_function_tree_sibling_path",
            "type": {
              "kind": "array",
              "length": 7,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          },
          {
            "name": "artifact_function_tree_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "function_data",
            "type": {
              "kind": "struct",
              "path": "events::utility_function_broadcasted::InnerUtilityFunction",
              "fields": [
                {
                  "name": "selector",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "metadata_hash",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log",
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "rd3bblzXmbXhe9GxDtYYY65dbqURBE7aHRgwnMBJGvgR+N7/oljj/eg0SChycpBFWdJXpKpebmo+Nec/P/3393/8x5//8MNP//OXv3363X/989Mff/7hxx9/+PMffvzLn777+w9/+enxX//5aXv5P61Pv0t++fxJL7/y41f6/Mn76+V4vZyvl+v1cn+55PG398dFrxe/XvJ6Wa+X/fVyvF7O18v1erm/XNbrlPU6Zb1OWa9T1uPvnY/L+Xq5vlz2x+9dj8t6veyvl+P1cr5ertfL/eVyvN7C8XoLx+stHI8p2h7X9bzur9fz8Yf1+ODOl9/350/Xy68ff/7S8/r46zoe1zyv63l9+fuP9+46ntfzeX35J3u8E9f9er2351XPq5/XPK8v8/K47q+3fx/P6/m8Xs/r/XrVtvUN9Q33jS8fw+OO9csd+/Iexq/v4Zfr+bxeL9fHn8rLn3q5j7y93klfrvfr9eVu+nLV8+rnNc/rer3uL7+v17vHfr1/nNc76Mv1fF6v5/V+vb7cSV+uel5f5q/X++nLdT2vL/Ne7tSXv38/rvfr9dTz6uf15aN7uT+v5/V+vb7cn1+uL/Pux0e9Xj7ql48qev2ool8e/7mZ/OHvP3///csfedPNo6a/fvfz9z/9/dPvfvrHjz9+/vS/3/34jy9/6G9//e6nL9e/f/fz43cft/P9T//9uD4G/s8PP37/8tYvn+dvb+//1fM8nn/5yuKva7++dsC1euvXoXcH+P0B3m4/J1jbwYjlX03IB+/CcfVduM9334X1/oA96YQ9+7wLOc6v/iiUk49i13sfxfHBhEvPAdne/fsffRA+zAex5d0P4sN/h+NgxL29O+J+f0S0OiLa928ZIakjHm/OHZrr/voRMSOWvm3EWow4tndH6KMH5t027m1/f8IH98ix5znh2Ne3Tbj7sDrfxPVvTbhmwvlNE063jXPl3QkffJLZ57PMfm9v78/163fio0fmSu/QrHV94wwCebx5fuOMa2bc+g/M2L9txq4+trL7G9+Pfbtmht+d4f2j+/bae99e9/v3i4+PvordfYBdbz99/8uE84MJ/IOe982E/d/4l1g7/xK/+nSxvvpBfp/N5Nh8fcuIpHfp8jwqdHx1aDnMA+s437Sqr/6O4vENYj9fPL6cz72h8/zaEcc65tOe34zYfv2BZH30ubdfAe6339h8/Tth04d9vvnkm1/fHfngcbmu1Qfmuj74xuKjGV/9flwf3CfH3Rk69w9mfPQF8d7buu5T734sHz00Lj5d6DrWu/fr0gf/HOvsp3Hvb760n/8ywh99tuCryfn433wk/vWDfH3wpf1cZz+Uc3/T2v+ZsT76nNGH6NI8Npx/+ZZv/+ixcfXx5Wx+f8bx0Tc6x3yvdO3fNiNb34/Hd17X+zM+eIzefAJ9PNC+acLjJ1LPZ573P5L9g4foWkc/e6315quR7m/5QM792+7Wk++AfWZ7/wP54AH6+Ew3yd/vPzT29Vvvkq+c8MG/xUcTvvpOPX/znfrhP+c9j/Db7/9zfvjZjy9Juo/r3c9+x4dfXJOdf46V+bRx6t8Yss9PWNu++70hH32J9t3Pf8d68xDd1zdNePM16V8mHB/9XMG3CY+nMd77kfmjJz/M90unj/UtH8Q970JyvvtBfPDgfPzA3K9GjycOrm/5luvMfP+7tvffi/ujryR8FXh8UZnM9vxqxPkf+Ibp1G//hunDf4zFT5s5r/f+Mc4PYt8fnzD4meTxs+K7gZwffQP6+Irc71QebyfvDvnwPdmPm/dkP+93h3zw1Xk/wozjTe35+ndj3/i54PH2m1T+nY/l8VMmT7PtXvu7Q+7f/n3Xtf3W77su/fbvuy7/9u+7Ppzxld93Xb/5i/z1H/gSfR2/+Uv09Zu/1/hwwtbPHLc/eGB89NDia9rS/m0Pra/83u/Wb/9m5eNa1za1ruv+lm8Skn4sx+Opol9/x/P7xy+/+9MPP/96pVAvq0aP+1Eva3iPD1HX83q/Xr09r3pe/bzmeV3P6/68Hs/rc56f8/ycl+e8POd9WV68nuuL13OB8XpdYXx5hL4sMX65ni/fwbyuX3253i8f4+v61fFcZ3xZlnhZ6TmfK41fruvluabHdX9eXxYUn2uP13Px8cv1fr3u2/Oq59XPa57X9bzuz+tz3v6ctz/n7c95x3Pe8Zx3POcdz3nHc97xnHc85x3Pecdz3vGcdz7nnc9553Pe+Zx3Puedz3nnc975nHc+553Peddz3vWcdz3nXc9513Pe9Zx3Peddz3nXc971nHc/593Pefdz3v2cdz/n3c9593Pe/Zx3P+fdz3lf1kFf31DfcN9I31h9Y+8bR984+8bVNzpZnaxOVierk9XJ6mR1sjpZnaxOdie7k93J7mR3sjvZnexOdie7k9PJ6eR0cjo5nZxOTienk9PJ6eTVyauTVyevTl6dvDq5Oak9qUGpRalJqU2pUalVqVmpXalhqWWpaaltqXGpdal5qX2pgamFqYmpjamRqZWpmamdqaGppampqa2psam1qbmpvanBqcWpyanNqdGp1anZqd2p4anlqemp7anxqfWp+an9qQGqBaoJqg26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DboNug26DaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNpg2mDaYNrja42uBqg6sNrja42uBqg6sNrja42uBqg6sNrja42uBqg6sNrja42uBqg6sNrja42uBqg6sNrja42uBqg6sNrja42uBqg6sNrja42uBqg6sNrja42uBqg6sNrja42uBqg6sNrja42uDiRzt+tuOHuza42uBqg6sNrja42uBqg6sNrja42uBqg6sNrja42uBqg6sNrja42uBqg6sNrja42uBqg6sNrja42uBqg+vkB91OboOrDa42uNrgaoOrDa42uNrgaoPr4mfoTm6Dqw2uNrja4GqDqw2uNrja4GqD6+bHc34+7w/obXBvg3sb3Nvg3gb3Nri3wb0N7m1wFz/6d3Ib3Nvg3gb3Nri3wb0N7m1wb4N7G9zNswqd3Ab3Nri3wb0N7m1wb4N7G9zb4N4G9/CERSe3wb0N7m1wb4N7G9zb4N4G9za4t8F98VxIJ7fBvQ3ubXBvgzvPsPAUC8+x8CQL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eDjj4YyHMx7OeDjj4YyHMx7OeDhrdsh5s0UOtzGb5MwuObNNzuyTMxvlzE45s1UOnePhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs6z/9VsgDU7YM0WWLMH1myCNbtgzTZYsw/WbIQ1O2HNVlizF9ZshjW7Yc12WLMf1myINTtizZZYb/bEmk2x3uyKxW3MvlizMdbsjDVbY83eWLM5Fp3P9lizP9ZskDU7ZM0WWbNH1mySNbtkzTZZs0/WbJQ1O2XNVlmzV9ZsljW7Zc12WbNf1myYNTtmzZZZs2fWbJo1u2bNtlmzb9ZsnDU7Z83WWbN31myeNbtnzfZZs3/WbKA1O2jNFlqzh9ZsojW7aM02WrOP1mykNTtpzVZas5fWbKY1u2nNdlqzn9ZsqDU7as2WWrOn1myqNbtqzbZas6/WbKw1O2vN1lqzt9ZsrjW7a832WrO/1mywNTtszRZbeDjj4YyHMx7OeDjj4YyHMx7OeDjj4YyHMx7OeDjj4YyHMx7OeDjj4YyHMx7OeDjj4YyHMx7OeDjj4YyHMx7OeDjj4ZzZBW+2wZt98N5shMdtzFZ4sxfebIY3u+HNdnh0joczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OK/Z93I2vpydL2fryzd7X3Ibs/vlbH85+1/OBph0joczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54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Hi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uODhgocLHi54uBxzzvwcND8nzc9R83PW/Bw2/+a0eW5jzpufA+fpHA8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPFzwcMHDBQ8XPNzCwy083MLDLTzcwsMtPNzCwy083MLDLTzcwsMtPNzCwy083MLDLTzcwsMtPNzCwy083MLDLTzcwsMtPNzCwy083MLDLTzcwsMtPNzCwy083MLDLTzcwsMtPNzCwy083MLDLTzcwsMtPNzCwy083MLDLTzcwsMtPNzCwy083MLDLTzcwsMtPNzCwy083MLDLTzcwsMtPNzCwy083MLDLTzcwsMtPNzCw60vHu7OL58//e93P//w3R9//P5vn373z8cv/+cfP/3p7z/85afnL//+//7a3/njzz/8+OMPf/7DX3/+y5++/+9//Pz9H378y59efu/T9vJ/Lw/F/9Lx2fr94w/r+d//S74/a92/f7Tx8qvt+Cwdj1+9/nGdn2W//FJf/uzjd329/H2//P2Xv3H68+X++Xv7fO8vv53+ttfnrP724yO7GXbn+WcXf/b6nKt/dq3Pj/fql19++f0v/x8=",
      "verification_key": "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"
    },
    {
      "name": "process_message",
      "is_unconstrained": true,
      "custom_attributes": [
        "external",
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec",
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext",
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec",
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9829419490427811213": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13921208329385594075": {
            "error_kind": "fmtstring",
            "length": 40,
            "item_types": []
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "publish",
      "is_unconstrained": false,
      "custom_attributes": [
        "external",
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "artifact_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "private_functions_root",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "public_bytecode_commitment",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log",
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "922421554006670918": {
            "error_kind": "string",
            "string": "num_items is greater than MAX_ITEMS"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "10965409165809799877": {
            "error_kind": "string",
            "string": "Given in_len to absorb is larger than the input array len"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15669273164684982983": {
            "error_kind": "string",
            "string": "num_permutations is greater than MAX_PERMUTATIONS"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16450579948625159707": {
            "error_kind": "string",
            "string": "Sponge must be in cache_size=1"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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eFEfvKgPXtTnuT84eFEfvKgPXtQHL+qDF/XBi/rgRX3woj54UZ/79MWL+jznwcGL+uBFffCiPnhRf3y7P77dH9/uj2/3x7f7PPnVPPnVPPnVPPnVPPnVPPnVPPnVPOfBwYv64EV98KI+eFEfvKgPXtTnuT84eFEfvKgPXtQHL+pTzz7Ci/rgRX3woj54UZ9++uJFfZ7z4OBFffCiPv2sK7yoP77dH9/uj2/3x7f749t9nvxqnvxqnvxqnvxqnvxqnvxqnvxqnvPg4EV98KI+++yjffYRXtTn8aL73B/cx4vu40X38aL7eNF9vOg+XnQfL7qPF93Hi+7jRffxovucB/fxovt40X286D5e9PHt/vh2f3y7P77dH9/u++RX++RX++RX++RX++RX++RX++RX+5wH9/Gi+3jRfbzoPl50Hy+6jxfd5/7gPl50Hy+6jxfdx4vu40X38aL7eNF9vOg+XnQfL7qPF93nPLiPF93Hi+7jRffxoo9v98e3++Pb/fHt/vh23ye/2ie/2ie/2ie/2ie/2ie/2ie/2uc8uI8X3ceL7uNF9/Gi+3jRfbzoPvcH9/Gi+3jRfbzoPl50Hy+6jxfdx4vu40X38aL7eNF9vOg+58F9vOg+XnQfL7qPF318uz++3R/f7o9v98e3+z751T751T751T751T751ZJf3UN+dQ/nwXvwovfgRe/Bi96DF70HL3oPXvQe7g/egxe9By96D170HrzoPXjRe/Ci9+BF78GL3oMXvceevnjRezgP3oMXvQcveg9e9B686H18+318+318+318+318+z33Gef7jDP51T3kV/eQX91zn7736XufvnjRe/Ci9+BF78GL3oMXvQcveg/3B+/Bi96DF70HL3oPXvQevOg9eNF78KL34EXvwYvek09fvOg9nAfvwYvegxe9J591hRe9j2+/j2+/j2+/j2+/j2+/p55xrmec65nfeua3n/ntp28/ffvpixe9By96Tz/7qJ99hBe9By96zzzrGS96zzz7CC96D170nnn2EV70HrzoPXjRe/Ci9+zTFy96D+fBe/Ci9+BF79lnXeFF7+Pb7+Pb7+Pb7+Pb7+Pbr5FfXSO/ukZ+dY386hr51TXyq2vkV9fO0xcveg0veg0veg0veg0veg0veo37g9fwot9q9pHhRa/hRb/V7CPDi36r71Pr/cY1vOg1f/riRa9x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t7d8e6fyq1R+lcqvUvlVKr9K5Vep/Co1DyZetBMv2okX7cSLduJFO/GinbwPduJFO/GinXjRTrxoJ160Ey/aiRftxIt24kU7Q3Xxop2aBxMv2okX7cSLduJFW7695dtbvr3l21u+vVP5VSq/SuVXqfwqlV+l8qtUfpWaBxMv2okX7cSLduJFO/GinXjRztZ9xot24kU78aKdeNHOVh/hRTvxop140U68aOeoLl60U/Ng4kU78aKdo3uFF2359pZvb/n2lm9v+fZO5Vep/CqVX6Xyq1R+lcqvUvlVah5MvGgnXrRz1UerPsKLduJFu3gf7MKLduFFu/CiXXjRLrxoF160Cy/ahRftwot2HdXFi3ZpHiy8aBdetAsv2oUXbfn2lm9v+faWb2/59i7lV6X8qpRflfKrUn5Vyq9K+VVpHiy8aBdetAsv2oUX7cKLduFFu3gf7MKLduFFu/CiXXjRLrxoF160Cy/ahRftwot2periRbs0DxZetAsv2lW6V3jRlm9v+faWb2/59pZv71J+VcqvSvlVKb8q5Vel/KqUX5XmwcKLduFFu/CiXa0+wot24UW7RvcZL9o16iO8aBdetGvUR3jRLrxoF160Cy/a9VQXL9qlebDwol140a6ne4UXbfn2lm9v+faWb2/59i7lV6X8qpRflfKrUn5Vyq9a+VVrHmy8aDdetBsv2o0X7caLduNFu/U+2HjRbrxoN160Gy/ajRftxot240W78aLdeNHuo7p40W7Ng40X7caLduNFu/GiLd/e8u0t397y7S3f3q38qpVftfKrVn7Vyq9a+VUrv2rNg40X7caLduNFu/Gi3XjRbrxot94HGy/ajRftxot240W78aLdeNFuvGg3XrQbL9pdqosX7dY82HjRbrxod+le4UVbvr3l21u+veXbW769W/lVK79q5Vet/KqVX7Xyq1Z+1ZoHGy/ajRftHvXRqI/wot140W69DzZetPupj/Ci3XjR7qc+wot240W78aLdeNHuVV28aLfmwcaLduNFu1f3Ci/a8u0t397y7S3f3vLtPcqvRvnVKL8a5Vej/GqUX43yq9E8OHjRHrxoD160By/agxftwYv26H1w8KI9eNEevGgPXrQHL9qDF+3Bi/bgRXvwoj1XdfGiPZoHBy/agxftwYv24EVbvr3l21u+veXbW769R/nVKL8a5Vej/GqUX43yq1F+NZoHBy/agxftwYv24EV78KI9eNEevQ8OXrQHL9qDF+3Bi/bgRXvwoj140R68aA9etKdVFy/ao3lw8KI9eNGe1r3Ci7Z8e8u3t3x7y7e3fHuP8qtRfjXKr0b51Si/GuVXo/xqNA8OXrQHL9rz1EdPfYQX7cGL9uh9cPCiPas+wov24EV7Vn2EF+3Bi/bgRXvwoj2runjRfpoHH160H160H160H1605dtbvr3l21u+veXb+ym/esqvnvKrp/zqKb96yq+e8qunefDhRfvhRfvhRfvhRfvhRfvhRfvpffDhRfvhRfvhRfvhRfvhRfvhRfvhRfvhRfvhRfuF6uJF+2kefHjRfnjRfnjRfnjRlm9v+faWb2/59pZv76f86im/esqvnvKrp/zqKb96yq+e5sGHF+2HF+2HF+2HF+2HF+2HF+2n98GHF+2HF+2HF+2HF+2HF+2HF+2HF+2HF+2HF+03qosX7ad58OFF++FF+43uFV605dtbvr3l21u+veXb+ym/esqvnvKrp/zqKb96yq+e8qunefDhRfvhRfut+mjVR3jRfnjRfnoffHjRfqs+khddedGVF1150ZUXXXnRlRddedGVF13NgysvuvKiKy+68qLy7S3f3vLtLd/e8u29yq9W+dUqv1rlV6v8apVfrfKr1Ty48qIrL7ryoisvuvKiKy+6eh9cedGVF1150ZUXXXnRlRddedGVF1150ZUXXXnR1Ty48qIrL7ryoisvKt/e8u0t397y7S3f3qv8apVfrfKrVX61yq9W+dUqv1rNgysvuvKiKy+68qIrL7ryoqv3wZUXXXnRlRddedGVF1150ZUXXXnRlRddedGVF13NgysvuvKiKy+68qLy7S3f3vLtLd/e8u29yq9W+dUqv1rlV6v8apVfrfKr1Ty48qKLF50PLzofXnQ+vOh8eNH5eB+cDy86H150PrzofHjR+fCi8+FF58OLzocXnQ8vOt9RXbzofMyD8+FF58OLzocXnQ8vOvLtI98+8u0j3z7y7fORX81HfjUf+dV85FfzkV/NF6obqhuqixedDy86H150PrzofHjR+fCi8/E+OB9edD686Hx40fnwovPhRefDi86HF50PLzofXnS+Ul286HzMg/PhRefDi85Xuld40ZFvH/n2kW8f+faRb5+vtc+tfW6db+t8W+fbqtuq26qLF50PLzrfqI9GfYQXnQ8vOt/oPuNF5xv1EV50PrzofE99hBedDy86H150PrzofE918aLzMQ/OhxedDy863+pe4UVHvn3k20e+feTbR759vtU+k1/NIb+aQ341h/xqDvnVHPKrOcyDc/Cic/Cic/Cic/Cic/Cic/Cic3gfnIMXnYMXnYMXnYMXnYMX/bd+WvOdPHjROXjROVd18aJzmAfn4EXn4EXn4EXn4EVHvn3k20e+feTbR759TmifQ/tMfjWH/GoO+dWcUN1U3VRdvOgcvOgcvOgcvOgcvOgcvOgc3gfn4EXn4EXn4EXn4EXn4EXn4EXn4EXn4EXn4EXnlOriRecwD87Bi87Bi85p3Su86Mi3j3z7yLePfPvIt88Z7fNon0fnOzrf0fmO6o7qjuriRefgRec89dFTH+FF5+BF5zzdZ7zonKc+wovOwYvOeeojvOgcvOgcvOgcvOicVV286BzmwTl40Tl40Tl40bl40ZFvH/n2kW8f+faRb59LfjWX/Gou+dVc8qu55Fdzj+oe1T2qixedixedixedixedixedixedy/vgXLzoXLzoXLzoXLzoXLzoXLzoXLzoXLzoXLzo3FBdvOhc5sG5eNG5eNG5eNG5eNGRbx/59pFvH/n2kW+fm9rn1D6nzjd1vqnzTdVN1U3VxYvOxYvOxYvOxYvOxYvOxYvO5X1wLl50Ll50Ll50Ll50Ll50Ll50Ll50Ll50Ll50bqsuXnQu8+BcvOhcvOjc0b3Ci458+8i3j3z7yLePfPvc0T6P9vnpfJ/O9+l8n+o+1X2qixedixed+9RHT32EF52LF527us940bmrPsKLzsWLzl31EV50Ll50Ai86gRedwItO4EUnNA8GXnQCLzqBF53Ai458+8i3j3z7yLePfPsE+dUE+dUE+dUE+dUE+dXEUd2rupoHAy86gRedwItO4EUn8KITeNEJ3gcn8KITeNEJvOgEXnQCLzqBF53Ai07gRSfwohOhunjRCc2DgRedwItO4EUn8KIj3z7y7SPfPvLtI98+Udrn0j6Xzrd0vqXzLdUt1dU8GHjRCbzoBF50Ai86gRedwItOtO4zXnQCLzqBF53Ai060+ggvOoEXncCLTuBFJ0Z18aITmgcDLzqBF50Y3Su86Mi3j3z7yLePfPvIt0887fPTPj+d79P5rs53VXdVV/Ng4EUn8KITqz5a9RFedAIvOsn74CRedBIvOokXncSLTuJFJ/Gik3jRSbzoJF508qguXnRS82DiRSfxopN40Um86Mi3j3z7yLePfPvIt08qv0rlV6n8KpVfpfKrVH6Vyq9S82DiRSfxopN40Um86CRedBIvOsn74CRedBIvOokXncSLTuJFJ/Gik3jRSbzoJF50MlUXLzqpeTDxopN40cnSvcKLjnz7yLePfPvIt498+6Tyq1R+lcqvUvlVKr9K5Vep/Co1DyZedBIvOokXnWz1EV50Ei86ObrPeNHJUR/hRSfxopOjPsKLTuJFJ/Gik3jRyae6eNFJzYOJF53Ei04+3Su86Mi3j3z7yLePfPvIt08qv0rlV6n8KpVfpfKrVH5Vyq9K82DhRafwolN40Sm86BRedAovOsX74BRedAovOoUXncKLTuFFp/CiU3jRKbzoFF506qguXnRK82DhRafwolN40Sm86Mi3j3z7yLePfPvIt08pvyrlV6X8qpRflfKrUn5Vyq9K82DhRafwolN40Sm86BRedAovOsX74BRedAovOoUXncKLTuFFp/CiU3jRKbzoFF50qlQXLzqlebDwolN40anSvcKLjnz7yLePfPvIt498+5Tyq1J+VcqvSvlVKb8q5Vel/Ko0DxZedAovOjXqo1Ef4UWn8KJTT/cZLzr11Ed40Sm86NRTH+FFp/CiU3jRKbzo1KouXnRK82DhRafwolOre4UXHfn2kW8f+faRbx/59mnlV638qpVftfKrVn7Vyq9a+VVrHmy86DRedBovOo0XncaLTuNFp/U+2HjRabzoNF50Gi86jRedxotO40Wn8aLTeNHpq7p40WnNg40XncaLTuNFp/GiI98+8u0j3z7y7SPfPq38qpVftfKrVn7Vyq9a+VUrv2rNg40XncaLTuNFp/Gi03jRabzotN4HGy86jRedxotO40Wn8aLTeNFpvOg0XnQaLzrdqosXndY82HjRabzodOte4UVHvn3k20e+feTbR759WvlVK79q5Vet/KqVX7Xyq1Z+1ZoHGy86jRedfuqjpz7Ci07jRaf1Pth40elVH+FFp/Gi06s+wotO40Wn8aLTeNHpVV286IzmwcGLzuBFZ/CiM3jRkW8f+faRbx/59pFvn1F+NcqvRvnVKL8a5Vej/GqUX43mwcGLzuBFZ/CiM3jRGbzoDF50Ru+DgxedwYvO4EVn8KIzeNEZvOgMXnQGLzqDF50J1cWLzmgeHLzoDF50Bi86gxcd+faRbx/59pFvH/n2GeVXo/xqlF+N8qtRfjXKr0b51WgeHLzoDF50Bi86gxedwYvO4EVn9D44eNEZvOgMXnQGLzqDF53Bi87gRWfwojN40ZlRXbzojObBwYvO4EVnRvcKLzry7SPfPvLtI98+8u0zyq9G+dUovxrlV6P8apRfjfKr0Tw4eNEZvOjMqo9WfYQXncGLzuh9cPCiM6s+wovOw4vOw4vOw4vOw4vOw4vOw4vOw4vOw4vO0zz48KLz8KLz8KLz8KIj3z7y7SPfPvLtI98+T/nVU371lF895VdP+dVTfvWUXz3Ngw8vOg8vOg8vOg8vOg8vOg8vOk/vgw8vOg8vOg8vOg8vOg8vOg8vOg8vOg8vOg8vOi9VFy86T/Pgw4vOw4vOw4vOw4uOfPvIt498+8i3j3z7POVXT/nVU371lF895VdP+dVTfvU0Dz686Dy86Dy86Dy86Dy86Dy86Dy9Dz686LxRH+FF5+FF5436CC86Dy86Dy86Dy86b1QXLzpP8+DDi87Di857uld40ZFvH/n2kW8f+faRb5+n/Oopv3rKr57yq6f86im/esqvnubBhxedJy+68qIrL7ryoisvunofXHnRlRddedGVF1150ZUXXXnRlRddedGVF1150dU8uPKiKy+68qIrLyrfPvLtI98+8u0j3z6r/GqVX63yq1V+tcqvVvnVKr9azYMrL7ryoisvuvKiKy+68qKr98GVF1150ZUXXXnRlRddedGVF1150ZUXXXnRlRddzYMrL7ryoisvuvKi8u0j3z7y7SPfPvLts8qvVvnVKr9a5Ver/GqVX63yq9U8uPKiKy+68qIrL7ryoisvunofXHnRlRddedGVF1150ZUXXXnRlRddedGVF1150dU8uPKiKy+68qIrLyrfPvLtI98+8u0j3z6r/GrJr95HfvU+8qv3kV+9j/zqfeRX72MefB9e9H140ffhRd+HF30fXvR9eNH38T74Przo+/Ci78OLvg8v+j686Pvwou/Di74PL/o+vOj7ruriRd/HPPg+vOj78KLvw4u+Dy/65NuffPuTb3/y7U++/X2hfQ7tM/nV+8iv3kd+9b5Q3VTdVF286Pvwou/Di74PL/o+vOj78KLv433wfXjR9+FF34cXfR9e9H140ffhRd+HF30fXvR9eNH3leriRd/HPPg+vOj78KLva90rvOiTb3/y7U++/cm3P/n29432ebTPo/Mdne/ofEd1R3VHdfGi78OLvu+pj576CC/6Przo+57uM170fU99hBd9H170fU99hBd9H170fXjR9+FF37eqixd9H/Pg+/Ci78OLvg8v+g5e9Mm3P/n2J9/+5NuffPs75FfvkF+9Q371DvnVO+RX7xzVPap7VBcv+g5e9B286Dt40X/rpzXfycP74Dt40Xfwou/gRd/Bi76DF30HL/oOXvQdvOg7eNF3QnXxou8wD76DF30HL/oOXvQdvOiTb3/y7U++/cm3P/n2d1L7nNrn1Pmmzjd1vqm6qbqpunjRd/Ci7+BF38GLvoMXfQcv+g7vg+/gRd/Bi76DF30HL/oOXvQdvOg7eNF38KLv4EXfadXFi77DPPgOXvQdvOg7o3uFF33y7U++/cm3P/n2J9/+zmifR/v8dL5P5/t0vk91n+o+1cWLvoMXfeepj576CC/6Dl70ndV9xou+s+ojvOg7eNF3Vn2EF30HL/ouXvRdvOi7eNF38aLvMg++ixd9Fy/6Ll70Xbzok29/8u1Pvv3Jtz/59nfJr94lv3qX/Opd8qt3ya/ePap7VfeqLl70Xbzou3jRd/Gi7+JF38WLvsv74Lt40Xfxou/iRd/Fi76LF30XL/ouXvRdvOi7eNF3Q3Xxou8yD76LF30XL/ouXvRdvOiTb3/y7U++/cm3P/n2d0v7XNrn0vmWzrd0vqW6pbqlunjRd/Gi7+JF38WLvosXfRcv+m7rPuNF38WLvosXfRcv+m6rj/Ci7+JF38WLvosXfXdUFy/6LvPgu3jRd/Gi747uFV70ybc/+fYn3/7k2598+7tP+/y0z0/n+3S+q/Nd1V3VXdXFi76LF3131UerPsKLvosXfcH74Au86Au86Au86Au86Au86Au86Au86Au86Au86IujunjRF5oHAy/6Ai/6Ai/6Ai/65NuffPuTb3/y7U++/QX51QvyqxfkVy/Ir16QX724qntVV/Ng4EVf4EVf4EVf4EVf4EVf4EVf8D74Ai/6Ai/6Ai/6Ai/6Ai/6Ai/6Ai/6Ai/6Ai/6IlUXL/pC82DgRV/gRV+U7hVe9Mm3P/n2J9/+5NuffPuL0j6X9rl1vq3zbZ1vq26rrubBwIu+wIu+wIu+aPURXvQFXvTF6D7jRV+M+ggv+gIv+mLUR3jRF3jRF3jRF3jRF0918aIvNA8GXvQFXvTF073Ciz759iff/uTbn3z7k29/sdrn1T6vznd1vqvzVX6Vyq9S82DiRV/iRV/iRV/iRV/iRV/iRV/yPvgSL/oSL/oSL/oSL/oSL/oSL/oSL/oSL/oSL/ryqC5e9KXmwcSLvsSLvsSLvsSLPvn2J9/+5NuffPuTb3+p/CqVX6Xyq1R+lcqvUvlVKr9KzYOJF32JF32JF32JF32JF32JF33J++BLvOhLvOhLvOhLvOhLvOhLvOhLvOhLvOhLvOjLUl286EvNg4kXfYkXfVm6V3jRJ9/+5NuffPuTb3/y7S+VX6Xyq1R+lcqvUvlVKr9K5VepeTDxoi/xoi9HfTTqI7zoS7zoy6f7jBd9+dRHeNGXeNGXT32EF32JF32JF32JF325qosXfal5MPGiL/GiL1f3Ci/65NuffPuTb3/y7U++/ZXyq1J+VcqvSvlVKb8q5Vel/Ko0DxZe9BVe9BVe9BVe9BVe9BVe9BXvg6/woq/woq/woq/woq/woq/woq/woq/woq/woq+u6uJFX2keLLzoK7zoK7zoK7zok29/8u1Pvv3Jtz/59lfKr0r5VSm/KuVXpfyqlF+V8qvSPFh40Vd40Vd40Vd40Vd40Vd40Ve8D77Ci77Ci77Ci77Ci77Ci77Ci77Ci77Ci77Ci75q1cWLvtI8WHjRV3jRV617hRd98u1Pvv3Jtz/59iff/kr5VSm/KuVXpfyqlF+V8qtSflWaBwsv+gov+uqpj576CC/6Ci/66uk+40VfrfoIL/oKL/pq1Ud40Vd40Vd40Vd40VerunjR15oHGy/6Gi/6Gi/6Gi/65NuffPuTb3/y7U++/bXyq1Z+1cqvWvlVK79q5Vet/Ko1DzZe9DVe9DVe9DVe9DVe9DVe9LXeBxsv+hov+hov+hov+hov+hov+hov+hov+hov+jpUFy/6WvNg40Vf40Vf40Vf40WffPuTb3/y7U++/cm3v1Z+1cqvWvlVK79q5Vet/KqVX7XmwcaLvsaLvsaLvsaLvsaLvsaLvtb7YONFX+NFX+NFX+NFX+NFX+NFX+NFX+NFX+NFX4/q4kVfax5svOhrvOjr0b3Ciz759iff/uTbn3z7k29/rfyqlV+18qtWftXKr1r5VSu/as2DjRd9jRd9veqjVR/hRV/jRV/rfbDxoq9XfYQXfYMXfYMXfYMXfYMXfYMXfYMXfYMXfYMXfaN5cPCib/Cib/Cib/CiT779ybc/+fYn3/7k298ovxrlV6P8apRfjfKrUX41yq9G8+DgRd/gRd/gRd/gRd/gRd/gRd/ofXDwom/wom/wom/wom/wom/wom/wom/wom/wom9SdfGibzQPDl70DV70DV70DV70ybc/+fYn3/7k2598+xvlV6P8apRfjfKrUX41yq9G+dVoHhy86Bu86Bu86Bu86Bu86Bu86Bu9Dw5e9M2oj/Cib/Cib0Z9hBd9gxd9gxd9gxd9M6qLF32jeXDwom/wom+e7hVe9Mm3P/n2J9/+5NuffPsb5Vej/GqUX43yq1F+NcqvRvnVaB4cvOgbvOh7eNH38KLv4UXfw4u+p/fBhxd9Dy/6Hl70Pbzoe3jR9/Ci7+FF38OLvocXfe+oLl70Pc2DDy/6Hl70Pbzoe3jRJ9/+5NuffPuTb3/y7e8pv3rKr57yq6f86im/esqvnvKrp3nw4UXfw4u+hxd9Dy/6Hl70Pbzoe3offHjR9/Ci7+FF38OLvocXfQ8v+h5e9D286Ht40fdKdfGi72kefHjR9/Ci75XuFV70ybc/+fYn3/7k2598+3vKr57yq6f86im/esqvnvKrp/zqaR58eNH38KLvjfpo1Ed40ffwou/pffDhRd8b9RFe9D286HtPfYQXfQ8v+h5e9D286HtPdfGi72kefHjR9/Ci763uFV70ybc/+fYn3/7k2598+3vKr57yq1V+tcqvVvnVKr9a5VereXDlRVdedOVFV1505UVXXnT1PrjyoisvuvKiKy+68qIrL7ryoisvuvKiKy+68qKreXDlRVdedOVFV15Uvv3Jtz/59iff/uTb3yq/WuVXq/xqlV+t8qtVfrXKr1bz4MqLrrzoyouuvOjKi6686Op9cOVFV1505UVXXnTlRVdedOVFV1505UVXXnTlRVfz4MqLrrzoyouuvKh8+5Nvf/LtT779ybe/VX61yq9W+dUqv1rlV6v8apVfrebBlRddedGVF1150ZUXXXnR1fvgyouuvOjKi6686MqLrrzoyouuvOjKi6686MqLrubBlRddedHFi+6HF1359pVvX/n2lW9f+fb9yK/2I7/aj/xqP/Kr/civ9juqe1T3qC5edD+86H540f3wovvhRffDi+7H++B+eNH98KL74UX3w4vuhxfdDy+6H150P7zofnjR/UJ18aL7MQ/uhxfdDy+6H150P7zoyrevfPvKt698+8q375fa59Q+p843db6p803VTdVN1cWL7ocX3Q8vuh9edD+86H540f14H9wPL7ofXnQ/vOh+eNH98KL74UX3w4vuhxfdDy+6X6suXnQ/5sH98KL74UX3G90rvOjKt698+8q3r3z7yrfvN9rn0T4/ne/T+T6d71Pdp7pPdfGi++FF93vqo6c+wovuhxfdb3Wf8aL7rfoIL7ofXnS/VR/hRffDi+7Bi+7Bi+7Bi+7Bi+5hHtyDF92DF92DF92DF1359pVvX/n2lW9f+fY95Fd7yK/2kF/tIb/6t35aq+5V3au6eNE9eNE9eNE9eNE9eNE9eNE9vA/uwYvuwYvuwYvuwYvuwYvuwYvuwYvuwYvuwYvuCdXFi+5hHtyDF92DF92DF92DF1359pVvX/n2lW9f+fY9pX0u7XPpfEvnWzrfUt1S3VJdvOgevOgevOgevOgevOgevOie1n3Gi+7Bi+7Bi+7Bi+5p9RFedA9edA9edA9edM+oLl50D/PgHrzoHrzontG9wouufPvKt698+8q3r3z7nqd9ftrnp/N9Ot/V+a7qruqu6uJF9+BF96z6aNVHeNE9eNG9vA/uxYvuxYvuxYvuxYvuxYvuxYvuxYvuxYvuxYvuPaqLF93LPLgXL7oXL7oXL7oXL7ry7SvfvvLtK9++8u17ya/2kl/tJb/aS361l/xq71Xdq7pXdfGie/Gie/Gie/Gie/Gie/Gie3kf3IsX3YsX3YsX3YsX3YsX3YsX3YsX3YsX3YsX3Zuqixfdyzy4Fy+6Fy+6t3Sv8KIr377y7SvfvvLtK9++t7TPpX1unW/rfFvn26rbqtuqixfdixfdixfd2+ojvOhevOje0X3Gi+4d9RFedC9edO+oj/Cie/Gie/Gie/Gie5/q4kX3Mg/uxYvuxYvufbpXeNGVb1/59pVvX/n2lW/fu9rn1T6vznd1vqvzJb/aIL/a0DwYeNENvOgGXnQDL7qBF93Ai27wPriBF93Ai27gRTfwoht40Q286AZedAMvuoEX3Tiqixfd0DwYeNENvOgGXnQDL7ry7SvfvvLtK9++8u0boX0O7TP51Qb51Qb51Uaobqiu5sHAi27gRTfwoht40Q286AZedIP3wQ286AZedAMvuoEX3cCLbuBFN/CiG3jRDbzoRqkuXnRD82DgRTfwohule4UXXfn2lW9f+faVb1/59o3WPrf2uXW+rfMdne+o7qiu5sHAi27gRTdGfTTqI7zoBl504+k+40U3nvoIL7qBF9146iO86AZedAMvuoEX3VjVxYtuaB4MvOgGXnRjda/woivfvvLtK9++8u0r376p/CqVX6Xyq1R+lcqvUvlVKr9KzYOJF93Ei27iRTfxopt40U286Cbvg5t40U286CZedBMvuokX3cSLbuJFN/Gim3jRzau6eNFNzYOJF93Ei27iRTfxoivfvvLtK9++8u0r376p/CqVX6Xyq1R+lcqvUvlVKr9KzYOJF93Ei27iRTfxopt40U286Cbvg5t40U286CZedBMvuokX3cSLbuJFN/Gim3jRzVZdvOim5sHEi27iRTdb9wovuvLtK9++8u0r377y7ZvKr1L5VSq/SuVXqfwqlV+l8qvUPJh40U286OZTHz31EV50Ey+6+XSf8aKbqz7Ci27iRTdXfYQX3cSLbuJFN/Gim6u6eNEtzYOFF93Ci27hRbfwoivfvvLtK9++8u0r376l/KqUX5Xyq1J+VcqvSvlVKb8qzYOFF93Ci27hRbfwolt40S286Bbvg1t40S286BZedAsvuoUX3cKLbuFFt/CiW3jRrVBdvOiW5sHCi27hRbfwolt40ZVvX/n2lW9f+faVb99SflXKr0r5VSm/KuVXpfyqlF+V5sHCi27hRbfwolt40S286BZedKt1n/GiW3jRLbzoFl50Cy+6hRfdwotu4UW38KJbo7p40S3Ng4UX3cKLbo3uFV505dtXvn3l21e+feXbt5RflfKrUn5Vyq9K+VUpvyrlV6V5sPCiW3jRrVUfrfoIL7qFF91a3We86Naqj/Ci23jRbbzoNl50Gy+6jRfdxotu40W38aLbmgcbL7qNF93Gi27jRVe+feXbV7595dtXvn1b+VUrv2rlV638qpVftfKrVn7VmgcbL7qNF93Gi27jRbfxott40W29DzZedBsvuo0X3caLbuNFt/Gi23jRbbzoNl50O1UXL7qtebDxott40W286DZedOXbV7595dtXvn3l27eVX7Xyq1Z+1cqvWvlVK79q5VetebDxott40W286DZedBsvuo0X3db7YONFt0d9hBfdxotuj/oIL7qNF93Gi27jRbdHdfGi25oHGy+6jRfdfrpXeNGVb1/59pVvX/n2lW/fVn7Vyq9a+VUrv2rlV638qpVftebBxotu40V38KI7eNEdvOgOXnRH74ODF93Bi+7gRXfwojt40R286A5edAcvuoMX3Tmqixfd0Tw4eNEdvOgOXnQHL7ry7SvfvvLtK9++8u07yq9G+dUovxrlV6P8apRfjfKr0Tw4eNEdvOgOXnQHL7qDF93Bi+7ofXDwojt40R286A5edAcvuoMX3cGL7uBFd/CiO6W6eNEdzYODF93Bi+6U7hVedOXbV7595dtXvn3l23eUX43yq1F+NcqvRvnVKL8a5VejeXDwojt40Z1RH436CC+6gxfd0fvg4EV3Rn2EF93Bi+489RFedAcvuoMX3cGL7jzVxYvuaB4cvOgOXnRnda/woivfvvLtK9++8u0r376j/GqUXz3lV0/51VN+9ZRfPeVXT/Pgw4vuw4vuw4vuw4vuw4vuw4vu0/vgw4vuw4vuw4vuw4vuw4vuw4vuw4vuw4vuw4vuu6qLF92nefDhRffhRffhRffhRVe+feXbV7595dtXvn2f8qun/Oopv3rKr57yq6f86im/epoHH150H150H150H150H150H150n94HH150H150H150H150H150H150H150H150H150X6kuXnSf5sGHF92HF93Xuld40ZVvX/n2lW9f+faVb9+n/Oopv3rKr57yq6f86im/esqvnubBhxfdhxfd99RHT32EF92HF92n98GHF9331Ed40X140X1PfYQX3YcX3YcX3YcX3beqixfdp3nw4UX34UX3yYuuvKh8+8q3r3z7yrevfPuu8qtVfrXKr1b51Sq/WuVXq/xqNQ+uvOjKi6686MqLrrzoyouu3gdXXnTlRVdedOVFV1505UVXXnTlRVdedOVFV150NQ+uvOjKi6686MqLyrevfPvKt698+8q37yq/WuVXq/xqlV+t8qtVfrXKr1bz4MqLrrzoyouuvOjKi6686Op9cOVFV1505UVXXnTlRVdedOVFV1505UVXXnTlRVfz4MqLrrzoyouuvKh8+8q3r3z7yrevfPuu8qtVfrXKr1b51Sq/WuVXq/xqNQ+uvOjKi6686MqLrrzoyouu3gdXXnTlRVdedOVFV1505UX350Xv9/286N/6aP2/un/r0Dq1/t/vjb91a/2/e/W3flr/b5//rX/fq7/1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vTG3teZezX1aa5/1vRp9r0bfq9H3apRfjfKrUX41yq9G+dUovxrlV6N5cJLfG5OhNX00WVq31qM193mSvwtT9NHU0fpqTR9NpdalNb83pkZr1S1+b4zmwWl+b0xfrXWvOrXWPut7Nfpejb5Xo+/VKL8a5Vej/GqUX43yq1F+NcqvRvPgDL83Zvi9MU999NRH72odWus+P/4uzFMfvdH6aa0+2k/rozW/N2ZDa9Xd0rq15vfG7NOae/W+T2v2+el79fS9evpePX2vnvKrp/zqKb96yq+e8qun/Oopv3qaB9/h98Y7pTV99M5o/bTmO/n0PvgufxfepY/eDa1Ta/ro3dZ6tOb3xrv83nihunG0vlrze+NFas29etFaa5/1vXr6Xj19r56+V0/51VN+9ZRfPeVXT/nVU371lF89zYOv+L3x6mhNH70KrVPr0pr7/Iq/C6/oo1f83nj9aU0fvb5ah9b83nhdWqtuj9ZPa35vvPm01r2aq7X2Wd+rp+/V0/fq6Xv1lF895VdP+dVTfvWUXz3lV0/51dM8+B6/N94brdVHT320n9ZHa93n5e/CW/XRltattfpon9Z8J1dedOVFV1505UVX8+DKi6686MqLrrzo6nu1+l6tvler79Xqe7XKr1b51Sq/WuVXq/xqlV+t8qvVPLjyoisvuvKiKy+68qIrL7p6H1x50ZUXXXnRlRddedGVF1150ZUXXXnRlRddedHVPLjyoisvuvKiKy+6+l6tvler79Xqe7X6Xq3yq1V+tcqvVvnVKr9a5Ver/Go1D6686MqLrrzoyouuvOjKi67eB1dedOVFV1505UVXXnTlRVdedOVFV1505UVXXnQ1D6686MqLrrzoyouuvler79Xqe7X6Xq2+V6v8apVfrfKrVX61yq9W+dUqv1rNgysvuvKiKy+68qIrL7p40fPxPng+vOj58KLnw4ueDy96Przo+fCi58OLng8vej686PmO6uJFz8c8eD686PnwoufDi54PL3rk2498+5FvP/LtR779fORX5yO/Oh/51fnIr85HfnW+q7pXda/q4kXPhxc9H170fHjR8+FFz4cXPR/vg+fDi54PL3o+vOj58KLnw4ueDy96Przo+fCi58OLni9VFy96PubB8+FFz4cXPV/pXuFFj3z7kW8/8u1Hvv3It5+vtM+lfW6db+t8W+fbqtuq26qLFz0f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bz/y7WeUX43yq1F+NcqvRvnVKL8a5VejeXDwomfwomfwomfwomfwomfwomf0Pjh40TN40TN40TN40TN40TN40TN40TN40TN40TOhunjRM5oHBy96Bi96Bi96Bi965NuPfPuRbz/y7Ue+/Yzyq1F+NcqvRvnVKL8a5Vej/Go0Dw5e9Axe9Axe9Axe9Axe9Axe9IzeBwcvegYvegYvegYvegYvegYvegYvegYvegYveqZVFy96RvPg4EXP4EXPjO4VXvTItx/59iPffuTbj3z7GeVXo/xqlF+N8qtRfjXKr0b51WgeHLzoGbzomac+euojvOgZvOgZvQ8OXvTMqo/womfwomdWfYQXPYMXPQ8veh5e9Dy86Hl40fM0Dz686Hl40fPwoufhRY98+5FvP/LtR779yLefp/zqKb96yq+e8qun/Oopv3rKr57mwYcXPQ8veh5e9Dy86Hl40fPwoufpffDhRc/Di56HFz0PL3oeXvQ8vOh5eNHz8KLn/337/9aqixc9T/Pgw4uehxc9Dy96Hl70yLcf+fYj337k2498+3nKr57yq6f86im/esqvnvKrp/zqaR58eNHz8KLn4UXPw4uehxc9Dy96nt4HH170PLzoeXjR8/Ci57X6CC96Hl70PLzoeXjR80Z18aLnaR58eNHz8KLnje4VXvTItx/59iPffuTbj3z7ecqvnvKrp/zqKb96yq+e8qun/OppHnx40fPwouet+mjVR3jR8+RFV++DKy+68qIrL7ryoisvuvKiKy+68qIrL7ryoisvupoHV1505UVXXnTlReXbj3z7kW8/8u1Hvv2s8qtVfrXKr1b51Sq/WuVXq/xqNQ+uvOjKi6686MqLrrzoyouu3gf/+/+3//9/u7zoyouuvOjKi6686MqLrrzoyouuvOjKi67mwZUXXXnRlRddeVH59iPffuTbj3z7kW8/q/xqlV+t8qtVfrXKr1b51Sq/Ws2DKy+68qIrL7ryoisvuvKiq/fBlRddedGVF1150ZUXXXnRlRddedGVF1150ZUXXc2DKy+68qIrL7ryovLtR779yLcf+fYj335W+dUqv1rlV6v8apVfLfnV/civ7sc8eD+86P3wovfDi94PL3o/vOj98KL3433wfnjR++FF74cXvR9e9H540fvhRe+HF70fXvR+eNH7HdXFi96PefB+eNH74UXvhxe9H170yrdf+fYr337l2698+/1C+xzaZ/Kr+5Ff3Y/86n6huqG6obp40fvhRe+HF70fXvR+eNH74UXvx/vg/fCi98OL3g8vej+86P3wovfDi94PL3o/vOj98KL3K9XFi96PefB+eNH74UXvV7pXeNEr337l2698+5Vvv/Lt92vtc2ufW+fbOt/R+Y7qjuqO6uJF74cXvd+oj0Z9hBe9H170fk/3GS96v6c+woveDy96v6c+woveDy96P7zo/fCi91vVxYvej3nwfnjR++FF77e6V3jRK99+5duvfPuVb7/y7feQX91DfnUP+dU95Ff3kF/dQ351D/nVPZ/q4kXvwYvegxe9By96D170HrzoPbwP3oMX/cO4v3M5eNF78KL34EXvwYvegxe9By96D170nqu6eNF7mAfvwYvegxe9By96D170yrdf+fYr337l2698+z2hfQ7tc+p8U+ebOt9U3VTdVF286D140XvwovfgRe/Bi96DF72H98F78KL34EXvwYvegxe9By96D170HrzoPXjRe/Ci97Tq4kXvYR68By96D170nta9wote+fYr337l2698+5Vvv2e0z6N9Hp3v6HxH5zuq+1T3qS5e9B686D1PffTUR3jRe/Ci9zzdZ7zoPas+wovegxe9Z9VHeNF78KL34EXvwYves6qLF72XefBevOi9eNF78aL34kWvfPuVb7/y7Ve+/cq330t+dS/51b3kV/eSX91LfnXvUd2jukd18aL34kXvxYveixe9Fy96L170Xt4H78WL3osXvRcvei9e9F686L140XvxovfiRe/Fi94bqosXvZd58P7n2//755/W3KuLF73y7Ve+/cq3X/n2K99+b2qfU/ucOt/U+ZbOt1S3VLdUFy96L170XrzovXjRe/Gi9+JF723dZ7zovXjRe/Gi9+JF78WL3osXvRcvei9e9F686L2junjRe5kH78WL3osXvXd0r/CiV779yrdf+fYr337l2+992uenfX4636fzfTrfp7pPdZ/q4kXvxYveu+qjVR/hRe/Fi967us940XtXfYQXvYEXvYEXvYEXvYEXvYEXvYEXvYEXvYEXvaF5MPCiN/CiN/CiN/CiV779yrdf+fYr337l22+QX90gv7pBfnWD/OoG+dWNq7pXdTUPBl70Bl70Bl70Bl70Bl70Bl70Bu+DN/CiN/CiN/CiN/Ci9z/f/t/6ac13MvCiN/CiN1J18aI3NA8GXvQGXvQGXvQGXvTKt1/59ivffuXbr3z7jdI+l/a5dL6l8y2db6luq67mwcCL3sCL3sCL3sCL3sCL3sCL3mjdZ7zojVEf4UVv4EVvjPoIL3oDL3oDL3oDL3pjVBcvekPzYOBFb+BFbzzdK7zolW+/8u1Xvv3Kt1/59hurfV7t8+p8V+e7Ot9V3VVdzYOBF72BF72JF72JF72JF72JF73J++BNvOhNvOhNvOhNvOhNvOhNvOhNvOhNvOhNvOjNo7p40ZuaBxMvehMvehMvehMveuXbr3z7lW+/8u1Xvv2m8qtUfpXKr1L5VSq/SuVXqfwqNQ8mXvQmXvQmXvT+v2//3/ppzXcyeR+8iRe9iRe9iRe9iRe9iRe9iRe9iRe9iRe9iRe9WaqLF72peTDxojfxojdL9woveuXbr3z7lW+/8u1Xvv2m8qtUfpXKr1L5VSq/SuVXqfwqNQ8mXvQmXvTmqI9GfYQXvYkXvTm6z3jRm6M+wovexIvefOojvOhNvOhNvOhNvOjNp7p40ZuaBxMvehMvenN1r/CiV779yrdf+fYr337l228qv0rlV6X8qpRflfKrUn5Vyq9K82DhRW/hRW/hRW/hRW/hRW/hRW/xPngLL3oLL3oLL3oLL3oLL3oLL3oLL3oLL3oLL3rrqi5e9JbmwcKL3sKL3sKL3sKLXvn2K99+5duvfPuVb7+l/KqUX5Xyq1J+VcqvSvlVKb8qzYOFF72FF72FF72FF72FF72FF73F++AtvOgtvOgtvOgtvOgtvOgtvOgtvOgtvOgtvOitUl286C3Ng4UXvYUXvdW6V3jRK99+5duvfPuVb7/y7beUX5Xyq1J+VcqvSvlVKb8q5VelebDworfworee+uipj/Cit/Cit57uM1701lMf4UVv4UVvPfURXvQWXvQWXvQWXvTWqi5e9JbmwcKL3sKL3sKL3saLXvn2K99+5duvfPuVb7+t/KqVX7Xyq1Z+1cqvWvlVK79qzYONF72NF72NF72NF72NF72NF72t98HGi97Gi97Gi97Gi97Gi97Gi97Gi97Gi97Gi94O1cWL3tY82HjR23jR23jR23jRK99+5duvfPuVb7/y7beVX7Xyq1Z+1cqvWvlVK79q5VetebDxorfxorfxorfxorfxorfxorf1Pth40dt40dt40dt40dt40dt40dt40dt40dt40dutunjR25oHGy96Gy96e3Sv8KJXvv3Kt1/59ivffuXbbyu/auVXrfyqlV+18qtWftXKr1rzYONFb+NFbz/10VMf4UVv40Vv632w8aK3V32EF72NF7296iO86G286B286B286B286B286B3Ng4MXvYMXvYMXvYMXvfLtV779yrdf+fYr335H+dUovxrlV6P8apRfjfKrUX41mgcHL3oHL3oHL3oHL3oHL3oHL3pH74ODF72DF72DF72DF72DF72DF72DF72DF72DF70TqosXvaN5cPCid/Cid/Cid/CiV779yrdf+fYr337l2+8ovxrlV6P8apRfjfKrUX41yq9G8+DgRe/gRe/gRe/gRe/gRe/gRe/ofXDwonfwonfwonfwondafYQXvYMXvYMXvYMXvTOqixe9o3lw8KJ38KJ3RvcKL3rl2698+5Vvv/LtV779jvKrUX41yq9G+dUovxrlV6P8ajQPDl70Dl70zqqPVn2EF72DF71P74MPL3ofXvQ+vOh9eNH78KL34UXvw4vehxe9Dy9631FdvOh9mgcfXvQ+vOh9eNH78KJXvv3Kt1/59ivffuXb71N+9ZRfPeVXT/nVU371lF895VdP8+DDi96HF70PL3ofXvQ+vOh9eNH79D748KL34UXvw4vehxe9Dy96H170PrzofXjR+/Ci96Xq4kXv0zz48KL34UXvK90rvOiVb7/y7Ve+/cq3X/n2+5RfPeVXT/nVU371lF895VdP+dXTPPjwovfhRe/Di97X6iO86H140fv0PvjwoveN+ggveh9e9L5RH+FF78OL3ocXvQ8vet9TXbzofZoHH170PrzofU/3Ci965duvfPuVb7/y7Ve+/T7lV0/51VN+9ZRfPeVXT/nVKr9azYMrL7ryoisvuvKiKy+68qKr98GVF1150ZUXXXnRlRddedGVF1150ZUXXXnRlRddzYMrL7ryoisvuvKi8u1Xvv3Kt1/59ivfflf51Sq/WuVXq/xqlV+t8qtVfrWaB1dedOVFV1505UVXXnTlRVfvgysvuvKiKy+68qIrL7ryoisvuvKiKy+68qIrL7qaB1dedOVFV1505UXl2698+5Vvv/LtV779rvKrVX61yq9W+dUqv1rlV6v8ajUPrrzoyouuvOjKi6686MqLrt4HV1505UVXXnTlRVdedOVFV150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XnTlRVdedOVFV1505UVXXnQ1D6686MqLrrzoyovKt6d8e8q3p3x7yrfnKr9a5Ver/GqVX63yq1V+tcqvVvPgyouuvOjKi6686MqLrrzo6n1w5UVXXnTxovXhRevDi9aHF60PL1ofXrQ+vGh9eNH68KL1MQ/WhxetDy9aH160PrxoybeXfHvJt5d8e8m310d+VR/5VX3kV/WRX9VHflXfVd2ruld18aL14UXrw4vWhxetDy9aH160Pt4H68OL1ocXrQ8vWh9etD68aH140frwovXhRevDi9aXqosXrY95sD68aH140frwovXhRUu+veTbS7695NtLvr2+0j6X9rl0vqXzLZ1vqW6rbqsuXrQ+vGh9eNH68KL14UXrw4vW17rPeNH6Rn2EF60PL1rfqI/wovXhRevDi9aHF61vVBcvWh/zYH140frwovU93Su8aMm3l3x7ybeXfHvJt9e32ufVPq/Od3W+q/Nd1V3VXdXFi9aHF62DF62DF62DF62DF63D+2AdvGgdvGgdvGgdvGgdvGgdvGgdvGgdvGgdvGido7p40TrMg3Xwov/WT2vu1cGLlnx7ybeXfHvJt5d8ex3yqzrkV3XIr+qQX9Uhv6oTqhuqG6qLF62DF62DF62DF62DF62DF63D+2AdvGgdvGgdvGgdvGgdvGgdvGgdvGgdvGgdvGidUl28aB3mwTp40Tp40Tqle4UXLfn2km8v+faSby/59jqtfW7tc+t8W+fbOt9W3VbdVl28aB28aJ1RH436CC9aBy9aZ3Sf8aJ1Rn2EF62DF63z1Ed40Tp40Tp40Tp40TpPdfGidZgH6+BF6+BF66zuFV605NtLvr3k20u+veTb66z2mfyqLvlVXfKruuRXdcmv6pJf1WUerIsXrYsXrYsXrYsXrYsXrYsXrcv7YF28aF28aF28aF28aF28aF28aF28aF28aF28aN2runjRusyDdfGidfGidfGidfGiJd9e8u0l317y7SXfXje0z6F9Jr+qS35Vl/yqbqhuqm6qLl60Ll60Ll60Ll60Ll60Ll60Lu+DdfGidfGidfGidfGidfGidfGidfGidfGidfGidUt18aJ1mQfr4kXr4kXrtu4VXrTk20u+veTbS7695NvrjvZ5tM+j8x2d7+h8R3VHdUd18aJ18aJ1n/roqY/wonXxonWf7jNetO5TH+FF6+JF6z71EV60Ll60Ll60Ll607qouXrQu82BdvGhdvGhdvGgFXrTk20u+veTbS7695NsryK8qyK8qyK8qyK8qyK8qjuoe1dU8GHjRCrxoBV60Ai9agRetwItW8D5YgRetwItW4EUr8KIVeNEKvGgFXrQCL1qBF60I1cWLVmgeDLxoBV60Ai9agRct+faSby/59pJvL/n2itQ+p/Y5db6p802db6puqq7mwcCLVuBFK/CiFXjRCrxoBV60gvfBCrxoBV60Ai9agRetwItW4EUr8KIVeNEKvGhFqy5etELzYOBFK/CiFaN7hRct+faSby/59pJvL/n2itE+j/b56XyfzvfpfJ/qPtXVPBh40Qq8aMVTHz31EV60Ai9asbrPeNGKVR/hRSvwohWrPsKLVuBFK/GilXjRSrxoJV60UvNg4kUr8aKVeNFKvGjJt5d8e8m3l3x7ybdXKr9K5Vep/CqVX6Xyq1R+lcqvUvNg4kUr8aKVeNFKvGglXrQSL1rJ+2AlXrQSL1qJF63Ei1biRSvxopV40Uq8aCVetDJUFy9aqXkw8aKVeNFKvGglXrTk20u+veTbS7695NsrlV+l8qtUfpXKr1L5VSq/SuVXqXkw8aKVeNFKvGglXrQSL1qJF61s3We8aCVetBIvWokXrWz1EV60Ei9aiRetxItWjuriRSs1DyZetBIvWjm6V3jRkm8v+faSby/59pJvr1R+lcqvUvlVKr9K5Vep/CqVX6XmwcSLVuJFK1d9tOojvGglXrSK98EqvGgVXrQKL1qFF63Ci1bhRavwolV40Sq8aNVRXbxolebBwotW4UWr8KJVeNGSby/59pJvL/n2km+vUn5Vyq9K+VUpvyrlV6X8qpRflebBwotW4UWr8KJVeNEqvGgVXrSK98EqvGgVXrQKL1qFF63Ci1bhRavwolV40Sq8aFWqLl60SvNg4UWr8KJVpXuFFy359pJvL/n2km8v+fYq5Vel/KqUX5Xyq1J+VcqvSvlVaR4svGgVXrQKL1rV6iO8aBVetGp0n/GiVaM+wotW4UWrRn2EF63Ci1bhRavwolVPdfGiVZoHCy9ahReterpXeNGSby/59pJvL/n2km+vUn5Vyq9K+VUpvyrlV6X8qpVftebBxotW40Wr8aLVeNFqvGg1XrRa74ONF63Gi1bjRavxotV40Wq8aDVetBovWo0XrT6qixet1jzYeNFqvGg1XrQaL1ry7SXfXvLtJd9e8u3Vyq9a+VUrv2rlV638qpVftfKr1jzYeNFqvGg1XrQaL1qNF63Gi1brfbDxotV40Wq8aDVetBovWo0XrcaLVuNFq/Gi1aW6eNFqzYONF63Gi1aX7hVetOTbS7695NtLvr3k26uVX7Xyq1Z+1cqvWvlVK79q5VetebDxotV40epRH436CC9ajRet1vtg40Wrn/oIL1qNF61+6iO8aDVetBovWo0XrV7VxYtWax5svGg1XrR6da/woiXfXvLtJd9e8u0l316j/GqUX43yq1F+NcqvRvnVKL8azYODF63Bi9bgRWvwojV40Rq8aI3eBwcvWoMXrcGL1uBFa/CiNXjRGrxoDV60Bi9ac1UXL1qjeXDwojV40Rq8aA1etOTbS7695NtLvr3k22uUX43yq1F+NcqvRvnVKL8a5VejeXDwojV40Rq8aA1etAYvWoMXrdH74OBFa/CiNXjRGrxoDV60Bi9agxetwYvW4EVrWnXxojWaBwcvWoMXrWndK7xoybeXfHvJt5d8e8m31yi/GuVXo/xqlF+N8qtRfjXKr0bz4OBFa/CiNU999NRHeNEavGiN3gcHL1qz6iO8aA1etGbVR3jRGrxoDV60Bi9as6qLF62nefDhRevhRevhRevhRUu+veTbS7695NtLvr2e8qun/Oopv3rKr57yq6f86im/epoHH160Hl60Hl60Hl60Hl60Hl60nt4HH160Hl60Hl60Hl60Hl60Hl60Hl60Hl60Hl60XqguXrSe5sGHF62HF62HF62HFy359pJvL/n2km8v+fZ6yq+e8qun/Oopv3rKr57yq6f86mkefHjRenjRenjRenjRenjRenjRenoffHjRenjRenjRenjRenjRenjRenjRenjRenjReqO6eNF6mgcfXrQeXrTe6F7hRUu+veTbS7695NtLvr2e8qun/Oopv3rKr57yq6f86im/epoHH160Hl603qqPVn2EF62HF62n98GHF6236iN50ZUXXXnRlRddedGVF1150ZUXXXnR1Ty48qIrL7ryoisvKt9e8u0l317y7SXfXqv8apVfrfKrVX61yq9W+dUqv1rNgysvuvKiKy+68qIrL7ryoqv3wZUXXXnRlRddedGVF1150ZUXXXnRlRddedGVF13NgysvuvKiKy+68qLy7SXfXvLtJd9e8u21yq9W+dUqv1rlV6v8apVfrfKr1Ty48qIrL7ryoisvuvKiKy+6eh9cedGVF1150ZUXXXnRlRddedGVF1150ZUXXXnR1Ty48qIrL7ryoisvKt9e8u0l317y7SXfXqv8apVfrfKrVX61yq9W+dUqv1rNgysvunjR/vCi/eFF+8OL9ocX7Y/3wf7wov3hRfvDi/aHF+0PL9ofXrQ/vGh/eNH+8KL9HdXFi/bHPNgfXrQ/vGh/eNH+8KIt397y7S3f3vLtLd/eH/lVf+RX/ZFf9Ud+1R/5VX+huqG6obp40f7wov3hRfvDi/aHF+0PL9of74P94UX7w4v2hxftDy/aH160P7xof3jR/vCi/eFF+yvVxYv2xzzYH160P7xof6V7hRdt+faWb2/59pZvb/n2/lr73Nrn1vm2zrd1vq26rbqtunjR/vCi/Y36aNRHeNH+8KL9je4zXrS/UR/hRfvDi/b31Ed40f7wov3hRfvDi/b3VBcv2h/zYH940f7wov2t7hVetOXbW7695dtbvr3l2/tb7TP5VR/yqz7kV33Ir/qQX/Uhv+rDPNgHL9oHL9oHL9oHL9oHL9oHL9qH98E+eNE+eNE+eNE+eNE+eNF/66c138mDF+2DF+1zVRcv2od5sA9etA9etA9etA9etOXbW7695dtbvr3l2/uE9jm0z+RXfciv+pBf9QnVTdVN1cWL9sGL9sGL9sGL9sGL9sGL9uF9sA9etA9etA9etA9etA9etA9etA9etA9etA9etE+pLl60D/NgH7xoH7xon9a9wou2fHvLt7d8e8u3t3x7n9E+j/Z5dL6j8x2d76juqO6oLl60D160z1MfPfURXrQPXrTP033Gi/Z56iO8aB+8aJ+nPsKL9sGL9sGL9sGL9lnVxYv2YR7sgxftgxftgxftixdt+faWb2/59pZvb/n2vuRXfcmv+pJf9SW/6kt+1feo7lHdo7p40b540b540b540b540b540b68D/bFi/bFi/bFi/bFi/bFi/bFi/bFi/bFi/bFi/YN1cWL9mUe7IsX7YsX7YsX7YsXbfn2lm9v+faWb2/59r6pfU7tc+p8U+ebOt9U3VTdVF28aF+8aF+8aF+8aF+8aF+8aF/eB/viRfviRfviRfviRfviRfviRfviRfviRfviRfu26uJF+zIP9sWL9sWL9h3dK7xoy7e3fHvLt7d8e8u39x3t82ifn8736Xyfzvep7lPdp7p40b540b5PffTUR3jRvnjRvqv7jBftu+ojvGhfvGjfVR/hRfviRTvwoh140Q68aAdetEPzYOBFO/CiHXjRDrxoy7e3fHvLt7d8e8u3d5BfdZBfdZBfdZBfdZBfdRzVvaqreTDwoh140Q68aAdetAMv2oEX7eB9sAMv2oEX7cCLduBFO/CiHXjRDrxoB160Ay/aEaqLF+3QPBh40Q68aAdetAMv2vLtLd/e8u0t397y7R2lfS7tc+l8S+dbOt9S3VJdzYOBF+3Ai3bgRTvwoh140Q68aEfrPuNFO/CiHXjRDrxoR6uP8KIdeNEOvGgHXrRjVBcv2qF5MPCiHXjRjtG9wou2fHvLt7d8e8u3t3x7x9M+P+3z0/k+ne/qfFd1V3U1DwZetAMv2rHqo1Uf4UU78KKdvA924kU78aKdeNFOvGgnXrQTL9qJF+3Ei3biRTuP6uJFOzUPJl60Ey/aiRftxIu2fHvLt7d8e8u3t3x7p/KrVH6Vyq9S+VUqv0rlV6n8KjUPJl60Ey/aiRftxIt24kU78aKdvA924kU78aKdeNFOvGgnXrQTL9qJF+3Ei3biRTtTdfGinZoHEy/aiRftLN0rvGjLt7d8e8u3t3x7y7d3Kr9K5Vep/CqVX6Xyq1R+lcqvUvNg4kU78aKdeNHOVh/hRTvxop2j+4wX7Rz1EV60Ey/aOeojvGgnXrQTL9qJF+18qosX7dQ8mHjRTrxo59O9wou2fHvLt7d8e8u3t3x7p/KrVH6Vyq9S+VUqv0rlV6X8qjQPFl60Cy/ahRftwot24UW78KJdvA924UW78KJdeNEuvGgXXrQLL9qFF+3Ci3bhRbuO6uJFuzQPFl60Cy/ahRftwou2fHvLt7d8e8u3t3x7l/KrUn5Vyq9K+VUpvyrlV6X8qjQPFl60Cy/ahRftwot24UW78KJdvA924UW78KJdeNEuvGgXXrQLL9qFF+3Ci3bhRbtKdfGiXZoHCy/ahRftKt0rvGjLt7d8e8u3t3x7y7d3Kb8q5Vel/KqUX5Xyq1J+VcqvSvNg4UW78KJdoz4a9RFetAsv2vV0n/GiXU99hBftwot2PfURXrQLL9qFF+3Ci3at6uJFuzQPFl60Cy/atbpXeNGWb2/59pZvb/n2lm/vVn7Vyq9a+VUrv2rlV638qpVftebBxot240W78aLdeNFuvGg3XrRb74ONF+3Gi3bjRbvxot140W68aDdetBsv2o0X7b6qixft1jzYeNFuvGg3XrQbL9ry7S3f3vLtLd/e8u3dyq9a+VUrv2rlV638qpVftfKr1jzYeNFuvGg3XrQbL9qNF+3Gi3brfbDxot140W68aDdetBsv2o0X7caLduNFu/Gi3a26eNFuzYONF+3Gi3a37hVetOXbW7695dtbvr3l27uVX7Xyq1Z+1cqvWvlVK79q5VetebDxot140e6nPnrqI7xoN160W++DjRftXvURXrQbL9q96iO8aDdetBsv2o0X7V7VxYv2aB4cvGgPXrQHL9qDF2359pZvb/n2lm9v+fYe5Vej/GqUX43yq1F+NcqvRvnVaB4cvGgPXrQHL9qDF+3Bi/bgRXv0Pjh40R68aA9etAcv2oMX7cGL9uBFe/CiPXjRnlBdvGiP5sHBi/bgRXvwoj140ZZvb/n2lm9v+faWb+9RfjXKr0b51Si/GuVXo/xqlF+N5sHBi/bgRXvwoj140R68aA9etEfvg4MX7cGL9uBFe/CiPXjRHrxoD160By/agxftGdXFi/ZoHhy8aA9etGd0r/CiLd/e8u0t397y7S3f3qP8apRfjfKrUX41yq9G+dUovxrNg4MX7cGL9qz6aNVHeNEevGiP3gcHL9qz6iO8aD+8aD+8aD+8aD+8aD+8aD+8aD+8aD+8aD/Ngw8v2g8v2g8v2g8v+n9l3N3OZkm23fV78XEfrPkVcw5uBVkIjEGWLIyMjYTQvnfqrazM8Zc42Yrurq7ZtVbEyCfG+mk/+PYH3/7g2x98+4Nvf4f+6tBfHfqrQ3916K8O/dWhvzrcB89e9J296Dt70Xf2ou/sRd/Zi77D98GzF31nL/rOXvSdveg7e9F39qLv7EXf2Yu+sxd915hrL/oO98GzF31nL/rOXvSdveiDb3/w7Q++/cG3P/j2d+ivDv3Vob869FeH/urQXx36q8N98OxF39mLvrMXfWcv+s5e9J296Dt8Hzx70XeLc2Qv+s5e9N3iHNmLvrMXfWcv+s5e9N1irr3oO9wHz170nb3ou8O+shd98O0Pvv3Btz/49gff/g791aG/OvRXh/7q0F8d+qtDf3W4D5696Dt4UcGLCl5U8KKCFxW+DwpeVPCighcVvKjgRQUvKnhRwYsKXlTwooIXFe6DghcVvKjgRQUvCt/+4NsffPuDb3/w7U/or4T+SuivhP5K6K+E/kror4T7oOBFBS8qeFHBiwpeVPCiwvdBwYsKXlTwooIXFbyo4EUFLyp4UcGLCl5U8KLCfVDwooIXFbyo4EXh2x98+4Nvf/DtD779Cf2V0F8J/ZXQXwn9ldBfCf2VcB8UvKjgRQUvKnhRwYsKXlT4Pih4UcGLCl5U8KKCFxW8qOBFBS8qeFHBiwpeVLgPCl5U8KKCFxW8KHz7g29/8O0Pvv3Btz+hv5L7q/3cX+3n/mo/91f7ub/az/3Vfr4P7mcvup+96H72ovvZi+5nL7qfveh+/j64n73ofvai+9mL7mcvup+96H72ovvZi+5nL7qfveh+ibn2ovv5Prifveh+9qL72YvuZy+68O0L377w7QvfvvDt+xWec+E5u7/az/3Vfu6v9ivMbcxtzLUX3c9edD970f3sRfezF93PXnQ/fx/cz150P3vR/exF97MX3c9edD970f3sRfezF93PXnS/wVx70f18H9zPXnQ/e9H9HvaVvejCty98+8K3L3z7wrfvt3jOi+e8eL+L97t4v4u5i7mLufai+9mL7nc4R4dzZC+6n73ofof9bC+63+Ec2YvuZy+63+Ec2YvuZy+6n73ofvai+wlz7UX3831wP3vR/exF97MX3bAXXfj2hW9f+PaFb1/49g33VxvurzbcX224v9pwf7URmBuYG5hrL7phL7phL7phL/rX+rB2Toa/D27Yi27Yi27Yi27Yi27Yi27Yi27Yi27Yi27Yi24U5tqLbvg+uGEvumEvumEvumEvuvDtC9++8O0L377w7RuN59x4zo3323i/jffbmNuY25hrL7phL7phL7phL7phL7phL7rh74Mb9qIb9qIb9qIb9qIb9qIb9qIb9qIb9qIb9qIbD3PtRTd8H9ywF92wF91Y7Ct70YVvX/j2hW9f+PaFb99YPOfFcz6838P7Pbzfw9zD3MNce9ENe9GNwzk6nCN70Q170Q1hP9uLbgjnyF50w150QzhH9qIb9qKb9qKb9qKb9qKb9qKbvg9u2otu2otu2otu2osufPvCty98+8K3L3z7pvurTfdXm+6vNt1fbbq/2gzMTcxNzLUX3bQX3bQX3bQX3bQX3bQX3fT3wU170U170U170U170U170U170U170U170U170c3CXHvRTd8HN+1FN+1FN+1FN+1FF7594dsXvn3h2xe+fXPwnAfPefB+B+938H4HcwdzB3PtRTftRTftRTftRTftRTftRTcf9rO96Ka96Ka96Ka96ObDObIX3bQX3bQX3bQX3VzMtRfd9H1w01500150c7Gv7EUXvn3h2xe+feHbF7598/CcD8/58H4P71d4v8JcYa4w11500150UzhHwjmyF920F93y98Ete9Ete9Ete9Ete9Ete9Ete9Ete9Ete9Ete9GtwFx70S3cB8tedMtedMtedMtedOHbF7594dsXvn3h27fcX225v9pyf7Xl/mrL/dVWYm5iLu6DZS+6ZS+6ZS+6ZS+6ZS+6ZS+65e+DW/aiW/aiW/aiW/aiW/aiW/aiW/aiW/aiW/aiW4259qJbuA+WveiWvejWYF/Ziy58+8K3L3z7wrcvfPvW4DkPnvPD+314vw/v92Huw1zcB8tedMtedMtedOvhHNmLbtmLbi32s73o1uIc2Ytu2YtuLc6RveiWveiWveiWvejWYa696Bbug2UvumUvunXYV/aiC9++8O0L377w7QvfviU8Z+E5C+9XeL/C+0V/1eivGvfBthfdthfdthfdthfdthfdthfd9vfBbXvRbXvRbXvRbXvRbXvRbXvRbXvRbXvRbXvR7cBce9Ft3AfbXnTbXnTbXnTbXnTh2xe+feHbF7594du30V81+qtGf9Xorxr9VaO/avRXjftg24tu24tu24tu24tu24tu24tu+/vgtr3otr3otr3otr3otr3otr3otr3otr3otr3o9mCuveg27oNtL7ptL7o92Ff2ogvfvvDtC9++8O0L376N/qrRXzX6q0Z/1eivGv1Vo79q3AfbXnTbXnR7cY4W58hedNtedPuwn+1Ftw/nyF502150+3CO7EW37UW37UW37UW3hbn2otu4D7a96La96Lawr+xFF7594dsXvn3h2xe+fQf91aC/GvRXg/5q0F8N+qtBfzW4D4696I696I696I696I696I696I6/D+7Yi+7Yi+7Yi+7Yi+7Yi+7Yi+7Yi+7Yi+7Yi+4k5tqL7uA+OPaiO/aiO/aiO/aiC9++8O0L377w7QvfvoP+atBfDfqrQX816K8G/dWgvxrcB8dedMdedMdedMdedMdedMdedMffB3fsRXfsRXfsRXfsRXfsRXfsRXfsRXfsRXfsRXce5tqL7uA+OPaiO/aiOw/7yl504dsXvn3h2xe+feHbd9BfDfqrQX816K8G/dWgvxr0V4P74NiL7tiL7hzO0eEc2Yvu2IvuHPazveiOcI7sRXfsRXeEc2QvumMvumMvumMvuiPMtRfdh/vgsxfdZy+6z150n73owrcvfPvCty98+8K370N/9dBfPfRXD/3VQ3/10F899FcP98FnL7rPXnSfveg+e9F99qL77EX34fvgsxfdZy+6z150n73oPnvRffai++xF99mL7rMX3VeYay+6D/fBZy+6z150n73oPnvRhW9f+PaFb1/49oVv34f+6qG/euivHvqrh/7qob966K8e7oPPXnSfveg+e9F99qL77EX32Yvuw/fBZy+6z150n73oPnvRffai++xF99mL7rMX3Wcvum8x1150H+6Dz150n73ovsW+shdd+PaFb1/49oVvX/j2feivHvqrh/7qob966K8e+quH/urhPvjsRffZi+4TzpFwjuxF99mL7sP3wWcvuk84R/aiu/aiu/aiu/aiu/aiu/aiu/aiu/aiu/aiu7gPrr3orr3orr3orr3owrcvfPvCty98+8K376K/WvRXi/5q0V8t+qtFf7Xorxb3wbUX3bUX3bUX3bUX3bUX3bUX3cX3wbUX3bUX3bUX3bUX3bUX3bUX3bUX3bUX3bUX3W3MtRfdxX1w7UV37UV37UV37UUXvn3h2xe+feHbF759F/3Vor9a9FeL/mrRXy36q0V/tbgPrr3orr3orr3orr3orr3orr3oLr4Prr3o7uIc2Yvu2ovuLs6RveiuveiuveiuvejuYq696C7ug2svumsvunvYV/aiC9++8O0L377w7Qvfvov+atFfLfqrRX+16K8W/dWiv1rcB9dedNdedM9edM9edM9edM9edA/fB89edM9edM9edM9edM9edM9edM9edM9edM9edC8w1150D/fBsxfdsxfdsxfdsxdd+PaFb1/49oVvX/j2PfRXh/7q0F8d+qtDf3Xorw791eE+ePaie/aie/aie/aie/aie/aie/g+ePaie/aie/aie/aie/aie/aie/aie/aie/aie4O59qJ7uA+eveievejeYF/Ziy58+8K3L3z7wrcvfPse+qtDf3Xorw791aG/OvRXh/7qcB88e9E9e9G9xTlanCN70T170T18Hzx70b3FObIX3bMX3TucI3vRPXvRPXvRPXvRvcNce9E93AfPXnTPXnRP2Ff2ogvfvvDtC9++8O0L376H/urQXwn9ldBfCf2V0F8J/ZVwHxS8qOBFBS8qeFHBiwpeVPg+KHhRwYsKXlTwooIXFbyo4EUFLyp4UcGLCl5UuA8KXlTwooIXFbwofPvCty98+8K3L3z7Cv2V0F8J/ZXQXwn9ldBfCf2VcB8UvKjgRQUvKnhRwYsKXlT4Pih4UcGLCl5U8KKCFxW8qOBFBS8qeFHBiwpeVLgPCl5U8KKCFxW8KHz7wrcvfPvCty98+wr9ldBfCf2V0F8J/ZXQXwn9lXAfFLyo4EUFLyp4UcGLCl5U+D4oeFHBiwpeVPCighcVvKjgRQUvKnhRwYsKXlS4DwpeVPCishe9z1704NsPvv3g2w++/eDb73N/dZ/7q/vcX93n/uo+91f3BeYG5gbm2oveZy96n73offai99mL3mcvep+/D95nL3qfveh99qL32YveZy96n73offai99mL3mcvel9hrr3ofb4P3mcvep+96H32ovfZix58+8G3H3z7wbcffPt9jefceM6N99t4v43325jbmNuYay96n73offai99mL3mcvep+96H3+Pnifveh99qL32YveZy96n73offai99mL3mcvep+96H0Pc+1F7/N98D570fvsRe9b7Ct70YNvP/j2g28/+PaDb79v8ZwXz/nwfg/v9/B+D3MPcw9z7UXvsxe973CODufIXvQ+e9H7hP1sL3qfcI7sRe+zF71POEf2ovfZi17Yi17Yi17Yi17Yi174PnhhL3phL3phL3phL3rw7QfffvDtB99+8O0X7q8u3F9duL+6cH/11/qwxtzE3MRce9ELe9ELe9ELe9ELe9ELe9ELfx+8sBe9sBe9sBe9sBe9sBe9sBe9sBe9sBe9sBe9KMy1F73wffDCXvTCXvTCXvTCXvTg2w++/eDbD7794NsvBs958JwH73fwfgfvdzB3MHcw1170wl70wl70wl70wl70wl704mE/24te2Ite2Ite2ItePJwje9ELe9ELe9ELe9GLxVx70QvfBy/sRS/sRS8W+8pe9ODbD7794NsPvv3g2y8Oz/nwnA/v9/B+hfcrzBXmCnPtRS/sRS+EcyScI3vRC3vRS38fvLQXvbQXvbQXvbQXvbQXvbQXvbQXvbQXvbQXvQzMtRe99H3w0l700l700l700l704NsPvv3g2w++/eDbL91fXbq/unR/den+6tL91WVibmJuYq696KW96KW96KW96KW96KW96KW/D17ai17ai17ai17ai17ai17ai17ai17ai17ai1425tqLXvo+eGkvemkvejnYV/aiB99+8O0H337w7Qfffjl4zoPn/PB+H97vw/t9mPsw92GuveilveilvejlwzmyF720F71c7Gd70cvFObIXvbQXvVycI3vRS3vRS3vRS3vRy8Nce9FL3wcv7UUv7UUvD/vKXvTg2w++/eDbD7794NsvhecsPGfh/QrvV3i/7q+u3F9d4T5Y9qJX9qJX9qJX9qJX9qJX9qJX/j54ZS96ZS96ZS96ZS96ZS96ZS96ZS96ZS96ZS96FZhrL3qF+2DZi17Zi17Zi17Zix58+8G3H3z7wbcffPtV4TkXnrP7qyv3V1fur64KcwtzcR8se9Ere9Ere9Ere9Ere9Ere9Erfx+8she9she9she9she9she9she9she9she9she9Gsy1F73CfbDsRa/sRa8G+8pe9ODbD7794NsPvv3g268envPDc354vw/vd/F+F3MXc3EfLHvRK3vRq8U5Wpwje9Ere9Grw362F706nCN70St70avDObIXvbIXvbIXvbIXvRLm2ote4T5Y9qJX9qJXwr6yFz349oNvP/j2g28/+PZr9FeN/qrRXzX6q0Z/1eivGv1V4z7Y9qLX9qLX9qLX9qLX9qLX9qLX/j54bS96bS96bS96bS96bS96bS96bS96bS96bS96nZhrL3qN+2Dbi17bi17bi17bix58+8G3H3z7wbcffPs1+qtGf9Xorxr9VaO/avRXjf6qcR9se9Fre9Fre9Fre9Fre9Fre9Frfx+8the9the9the9the9the9the9the9the9the9fphrL3qN+2Dbi17bi14/7Ct70YNvP/j2g28/+PaDb79Gf9Xorxr9VaO/avRXjf6q0V817oNtL3ptL3p9OEeHc2Qvem0ven3Yz/ai18I5she9the9Fs6Rvei1vei1vei1vei1MNde9Ab3wbEXvbEXvbEXvbEXPfj2g28/+PaDbz/49hv0V4P+atBfDfqrQX816K8G/dXgPjj2ojf2ojf2ojf2ojf2ojf2ojf+PnhjL3pjL3pjL3pjL3pjL3pjL3pjL3pjL3pjL3pTmGsveoP74NiL3tiL3tiL3tiLHnz7wbcffPvBtx98+w36q0F/NeivBv3VoL8a9FeD/mpwHxx70Rt70Rt70Rt70Rt70Rt70ZuH/WwvemMvemMvemMvemMvemMvemMvemMvemMverOYay96g/vg2Ive2IveLPaVvejBtx98+8G3H3z7wbffoL8a9FeD/mrQXw36q0F/NeivBvfBsRe9sRe9Ec6RcI7sRW/sRW+E/WwveiOcI3vRe/ai9+xF79mL3rMXvWcves9e9J696D170Xu4Dz570Xv2ovfsRe/Zix58+8G3H3z7wbcffPs99FcP/dVDf/XQXz30Vw/91UN/9XAffPai9+xF79mL3rMXvWcves9e9B6+Dz570Xv2ovfsRe/Zi96zF71nL3rPXvSeveg9e9F7jbn2ovdwH3z2ovfsRe/Zi96zFz349oNvP/j2g28/+PZ76K8e+quH/uqhv3rorx76q4f+6uE++OxF79mL3rMXvWcves9e9J696D18H3z2ovcW58he9J696L3FObIXvWcves9e9J696L3FXHvRe7gPPnvRe/ai9w77yl704NsPvv3g2w++/eDb76G/euivHvqrh/7qob966K8e+quH++CzF71nL3prL3prL3prL3prL3qL74NrL3prL3prL3prL3prL3prL3prL3prL3prL3obmGsveov74NqL3tqL3tqL3tqLHnz7wbcffPvBtx98+y36q0V/teivFv3Vor9a9FeL/mpxH1x70Vt70Vt70Vt70Vt70Vt70Vt8H1x70Vt70Vt70Vt70Vt70Vt70Vt70Vt70Vt70dvBXHvRW9wH11701l70drCv7EUPvv3g2w++/eDbD779Fv3Vor9a9FeL/mrRXy36q0V/tbgPrr3orb3o7eIcLc6Rveitvegtvg+uvejt4hzZi97ai94ezpG96K296K296K296O1hrr3oLe6Day96ay96K+wre9GDbz/49oNvP/j2g2+/RX+16K8O/dWhvzr0V4f+6tBfHe6DZy96Zy96Zy96Zy96Zy96Zy96h++DZy96Zy96Zy96Zy96Zy96Zy96Zy96Zy96Zy96l5hrL3qH++DZi97Zi97Zi97Zix58+8G3H3z7wbcffPsd+qtDf3Xorw791aG/OvRXh/7qcB88e9E7e9E7e9E7e9E7e9E7e9E7fB88e9E7e9E7e9E7e9E7e9E7e9E7e9E7e9E7e9G7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/dXgPjj2ojn2ojn2ojn2ojn2ojn2ojn+PphjL5pjL5pjL5pjL5pjL5pjL5pjL5pjL5pjL5rzMNdeNAf3wbEXzbEXzVnsK3vRhG9P+PaEb0/49oRvz0F/NeivBv3VoL8a9FeD/mrQXw3ug2MvmmMvmnM4R4dzZC+aYy+aI+xne9Ec4RzZi+bYi+YI58heNMdeNJ+9aD570Xz2ovnsRfPhPvjsRfPZi+azF81nL5rw7QnfnvDtCd+e8O350F899FcP/dVDf/XQXz30Vw/91cN98NmL5rMXzWcvms9eNJ+9aD570Xz4PvjsRfPZi+azF81nL5rPXjSfvWg+e9F89qL57EXzFebai+bDffDZi+azF81nL5rPXjTh2xO+PeHbE7494dvzob966K8e+quH/uqhv3rorx76q4f74LMXzWcvms9eNJ+9aD570Xz2ovnwffDZi+azF81nL5rPXjTfwzmyF81nL5rPXjSfvWi+xVx70Xy4Dz570Xz2ovkW+8peNOHbE7494dsTvj3h2/Ohv3rorx76q4f+6qG/euivHvqrh/vgsxfNZy+aTzhHwjmyF81nL5qL74NrL5prL5prL5prL5prL5prL5prL5prL5prL5obmGsvmov74NqL5tqL5tqL5tqLJnx7wrcnfHvCtyd8ey76q0V/teivFv3Vor9a9FeL/mpxH1x70Vx70Vx70Vx70Vx70Vx70Vx8H1x70Vx70Vx70Vx70Vx70Vx70Vx70Vx70Vx70dzGXHvRXNwH11401140d7Cv7EUTvj3h2xO+PeHbE749F/3Vor9a9FeL/mrRXy36q0V/tbgPrr1orr1orr1o7sM5shfNtRfNxffBtRfNXZwje9Fce9HcxTmyF821F821F821F809zLUXzcV9cO1Fc+1Fcw/7yl404dsTvj3h2xO+PeHbc9FfLfqrRX+16K8W/dWivzr0V4f74NmL5tmL5tmL5tmL5tmL5tmL5uH74NmL5tmL5tmL5tmL5tmL5tmL5tmL5tmL5tmL5gXm2ovm4T549qJ59qJ59qJ59qIJ357w7QnfnvDtCd+eh/7q0F8d+qtDf3Xorw791aG/OtwHz140z140z140z140z140z140D98Hz140z140z140z140z140z140z140z140z140bzDXXjQP98GzF82zF80b7Ct70YRvT/j2hG9P+PaEb89D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0F8N7oNjL1pjL1pjL1pjL1pjL1pjL1rj74M19qI19qI19qI19qI19qI19qI19qI19qI19qI1hbn2ojW4D469aI29aI29aI29aMG3F3x7wbcXfHvBt9egvxr0V4P+atBfDfqrQX816K8G98GxF62xF62xF62xF62xF62xF6152M/2ojX2ojX2ojX2ojUP58hetMZetMZetMZetGYx1160BvfBsRetsRetWewre9GCby/49oJvL/j2gm+vQX816K8G/dWgvxr0V4P+atBfDe6DYy9aYy9aI5wj4RzZi9bYi9bD98FnL1rPXrSevWg9e9F69qL17EXr2YvWsxetZy9aLzDXXrQe7oPPXrSevWg9e9F69qIF317w7QXfXvDtBd9eD/3VQ3/10F899FcP/dVDf/XQXz3cB5+9aD170Xr2ovXsRevZi9azF62H74PPXrSevWg9e9F69qL17EXr2YvWsxetZy9az160XmOuvWg93AefvWg9e9F6g31lL1rw7QXfXvDtBd9e8O310F899FcP/dVDf/XQXz30Vw/91cN98NmL1rMXrWcvWu/hHNmL1rMXrYfvg89etN7iHNmL1rMXrbc4R/ai9exF69mL1rMXrXeYay9aD/fBZy9az1603mFf2YsWfHvBtxd8e8G3F3x7PfRXD/3VQ3/10F899FcP/dWiv1rcB9detNZetNZetNZetNZetNZetBbfB9detNZetNZetNZetNZetNZetNZetNZetNZetDYw1160FvfBtRettRettRettRct+PaCby/49oJvL/j2WvRXi/5q0V8t+qtFf7Xorxb91eI+uPaitfaitfaitfaitfaitfaitfg+uPaitfaitfaitfaitfaitfaitfaitfaitfaitYO59qK1uA+uvWitvWjtYF/ZixZ8e8G3F3x7wbcXfHst+qtFf7Xorxb91aK/WvRXi/5qcR9ce9Fae9HaxTlanCN70Vp70Vp8H1x70drDObIXrbUXrT2cI3vRWnvRWnvRWnvRWmGuvWgt7oNrL1prL1or7Ct70YJvL/j2gm8v+PaCb69Df3Xorw791aG/OvRXh/7q0F8d7oNnL1pnL1pnL1pnL1pnL1pnL1qH74NnL1pnL1pnL1pnL1pnL1pnL1pnL1pnL1pnL1qXmGsvWof74NmL1tmL1tmL1tmLFnx7wbcXfHvBtxd8ex36q0N/deivDv3Vob869FeH/upwHzx70Tp70Tp70Tp70Tp70Tp70Tp8Hzx70Tp70Tp70Tp70Tp70Tp70Tp70Tp70Tp70bqHufaidbgPnr1onb1o3cO+shct+PaCby/49oJvL/j2OvRXh/7q0F8d+qtDf3Xorw791eE+ePaidfaidYdzdDhH9qJ19qJ1+D549qJ1wjmyF62zF60TzpG9aJ29aJ29aJ29aJ0wF15UuA8KXlTwooIXFbwofHvBtxd8e8G3F3x7Cf2V0F8J/ZXQXwn9ldBfCf2VcB8UvKjgRQUvKnhRwYsKXlT4Pih4UcGLCl5U8KKCFxW8qOBFBS8qeFHBiwpeVLgPCl5U8KKCFxW8KHx7wbcXfHvBtxd8ewn9ldBfCf2V0F8J/ZXQXwn9lXAfFLyo4EUFLyp4UcGLCl5U+D4oeFHBiwpeVPCighcVvKjgRQUvKnhRwYsKXlS4DwpeVPCighcVvCh8e8G3F3x7wbcXfHsJ/ZXQXwn9ldBfCf2V0F8J/ZVwHxS8qOBFBS8qeFHBiwpeVPg+KHhRwYvKXrQ/e9H+7EX7sxftz160P3vR/uxF+7MX7c9etD/fB/uzF+3PXrQ/e9H+7EUbvr3h2xu+veHbG769P/dX/bm/6s/9VX/ur/pzf9VfYm5ibmKuvWh/9qL92Yv2Zy/an71of/ai/fn7YH/2ov3Zi/ZnL9qfvWh/9qL92Yv2Zy/an71of/ai/TXm2ov25/tgf/ai/dmL9mcv2p+9aMO3N3x7w7c3fHvDt/c3eM6D5zx4v4P3O3i/g7kPcx/m2ov2Zy/an71of/ai/dmL9mcv2t/DfrYX7W9xjuxF+7MX7W9xjuxF+7MX7c9etD970f4Wc+1F+/N9sD970f7sRfs77Ct70YZvb/j2hm9v+PaGb+9PeM7Ccxber/B+hfcrzBXmCnPtRfuzF+2wF+2wF+2wF+2wF+3w98EOe9EOe9EOe9EOe9EOe9EOe9EOe9EOe9EOe9GOwFx70Q7fBzvsRf9aH9beV2Ev2vDtDd/e8O0N397w7R3urzrcX3W4v+pwf9Xh/qqjMLcwtzDXXrTDXrTDXrTDXrTDXrTDXrTD3wc77EU77EU77EU77EU77EU77EU77EU77EU77EU7BnPtRTt8H+ywF+2wF+0Y7Ct70YZvb/j2hm9v+PaGb+94eM4Pz/nh/T6834f3+zD3Ye7DXHvRDnvRjsU5Wpwje9EOe9GOxX62F+1YnCN70Q570Y7DObIX7bAX7bAX7bAX7TjMtRft8H2ww160w160Q9hX9qIN397w7Q3f3vDtDd/eITxn91ed7q863V91ur/qdH/V6f6q0/fBTnvRTnvRTnvRTnvRTnvRTnvRTn8f7LQX7bQX7bQX7bQX7bQX7bQX7bQX7bQX7bQX7UzMtRft9H2w01600160016001604dsbvr3h2xu+veHbOwvPufCc3V91ur/qdH/VWZjbmNuYay/aaS/aaS/aaS/aaS/aaS/a6e+DnfainfainfainfainfainfainfainfainfainYO59qKdvg922ot22ot2Puwre9GGb2/49oZvb/j2hm/vXDznxXNevN/F+12838XcxdzFXHvRTnvRzsM5Opwje9FOe9HOw362F+08nCN70U570c7DObIX7bQX7bQX7bQX7RTm2ot2+j7YaS/aaS/aaS/aZS/a8O0N397w7Q3f3vDtXe6vutxfdbm/6nJ/1eX+qiswNzAX98GyF+2yF+2yF+2yF+2yF+2yF+3y98Eue9Eue9Eue9Eue9Eue9Eue9Eue9Eue9Eue9Guwlx70S7cB8tetMtetMtetMtetOHbG7694dsbvr3h27saz7nxnBvvt/F+G++3MbcxF/fBshftshftshftshftshftshft8vfBLnvRLnvRLnvRLnvRLnvRLnvRLnvRLnvRLnvRroe59qJduA+WvWiXvWjXYl/ZizZ8e8O3N3x7w7c3fHvX4jkvnvPh/R7e7+H9HuYe5uI+WPaiXfaiXYdzdDhH9qJd9qJdwn62F+0SzpG9aJe9aJdwjuxFu+xFu+1Fu+1Fu+1Fu+1Fu3EfbHvRbnvRbnvRbnvRhm9v+PaGb2/49oZv70Z/1eivGv1Vo79q9FeN/qrRXzXug20v2m0v2m0v2m0v2m0v2m0v2u3vg932ot32ot32ot32ot32ot32ot32ot32ot32ot2Fufai3bgPtr1ot71ot71ot71ow7c3fHvDtzd8e8O3d6O/avRXjf6q0V81+qtGf9Xorxr3wbYX7bYX7bYX7bYX7bYX7bYX7X7Yz/ai3fai3fai3fai3Q/nyF60216021602160ezHXXrQb98G2F+22F+1e7Ct70YZvb/j2hm9v+PaGb+9Gf9Xorxr9VaO/avRXjf6q0V817oNtL9ptL9otnCPhHNmLdtuL9vj7YI+9aI+9aI+9aI+9aI+9aI+9aI+9aI+9aI+9aE9grr1oD+6DYy/aYy/aYy/aYy/a8O0N397w7Q3f3vDtPeivBv3VoL8a9FeD/mrQXw36q8F9cOxFe+xFe+xFe+xFe+xFe+xFe/x9sMdetMdetMdetMdetMdetMdetMdetMdetMdetKcx1160B/fBsRftsRftGewre9GGb2/49oZvb/j2hm/vQX816K8G/dWgvxr0V4P+atBfDe6DYy/aYy/aYy/a83CO7EV77EV7FvvZXrRncY7sRXvsRXsW58hetMdetMdetMdetOcw1160B/fBsRftsRftOewre9GGb2/49oZvb/j2hm/vQX816K8G/dWgvxr0V4P+6qG/ergPPnvRfvai/exF+9mL9rMX7Wcv2g/fB5+9aD970X72ov3sRfvZi/azF+1nL9rPXrSfvWi/wFx70X64Dz570X72ov3sRfvZizZ8e8O3N3x7w7c3fHs/9FcP/dVDf/XQXz30Vw/91UN/9XAffPai/exF+9mL9rMX7Wcv2s9etB++Dz570X72ov3sRfvZi/azF+1nL9rPXrSfvWg/e9F+g7n2ov1wH3z2ov3sRfsN9pW9aMO3N3x7w7c3fHvDt/dDf/XQXz30Vw/91UN/9dBfPfRXD/fBZy/az1603+IcLc6RvWg/e9F++D747EX7Hc6RvWg/e9F+h3NkL9rPXrSfvWg/e9F+wlx70X64Dz570X72ov2EfWUv2vDtDd/e8O0N397w7b3orxb91aK/WvRXi/5q0V8t+qvFfXDtRXvtRXvtRXvtRXvtRXvtRXvxfXDtRXvtRXvtRXvtRXvtRXvtRXvtRXvtRXvtRXsTc+1Fe3EfXHvRXnvRXnvRXnvRhm9v+PaGb2/49oZv70V/teivFv3Vor9a9FeL/mrRXy3ug2sv2msv2msv2msv2msv2msv2ovvg2sv2msv2msv2msv2msv2msv2msv2msv2msv2vsw1160F/fBtRfttRftfdhX9qIN397w7Q3f3vDtDd/ei/5q0V8t+qtFf7Xorxb91aK/WtwH1160116093CODufIXrTXXrQX3wfXXrRXOEf2or32or3CObIX7bUX7bUX7bUX7RXm2ov24T549qJ99qJ99qJ99qIN397w7Q3f3vDtDd/eh/7q0F8d+qtDf3Xorw791aG/OtwHz160z160z160z160z160z160D98Hz160z160z160z160z160z160z160z160z160rzDXXrQP98GzF+2zF+2zF+2zF2349oZvb/j2hm9v+PY+9FeH/urQXx36q0N/deivDv3V4T549qJ99qJ99qJ99qJ99qJ99qJ9+D549qJ99qJ99qJ99qJ99qJ99qJ99qJ99qJ99qJ9i7n2on24D569aJ+9aN9iX9mLNnx7w7c3fHvDtzd8ex/6q0N/deivDv3Vob869FeH/upwHzx70T570T7hHAnnyF60z160D98Hz160TzhH8KKCFxW8qOBFBS8qeFHBiwpeVPCiwn1Q8KKCFxW8qOBF4dsbvr3h2xu+veHbW+ivhP5K6K+E/kror4T+SuivhPug4EUFLyp4UcGLCl5U8KLC90HBiwpeVPCighcVvKjgRQUvKnhRwYsKXlTwosJ9UPCighcVvKjgReHbG7694dsbvr3h21vor4T+SuivhP5K6K+E/kror4T7oOBFBS8qeFHBiwpeVPCiwvdBwYsKXlTwooIXFbyo4EUFLyp4UcGLCl5U8KLCfVDwooIXFbyo4EXh2xu+veHbG7694dtb6K+E/kror4T+SuivhP5K6K+E+6DgRWUvOp+96Hz2ovPZi85nLzqfvw/OZy86n73ofPai89mLzmcvOp+96Hz2ovPZi85nLzpfYK696Hy+D85nLzqfveh89qLz2YsOfPvAtw98+8C3D3z7fO6v5nN/NZ/7q/ncX83n/mq+wtzC3MJce9H57EXnsxedz150PnvR+exF5/P3wfnsReezF53PXnQ+e9H57EXnsxedz150PnvR+exF5xvMtRedz/fB+exF57MXnW+wr+xFB7594NsHvn3g2we+fb6H5/zwnB/e78P7fXi/D3Mf5j7MtRedz150vsU5Wpwje9H57EXnW+xne9H5FufIXnQ+e9H5DufIXnQ+e9H57EXnsxed7zDXXnQ+3wfnsxedz150PmFf2YsOfPvAtw98+8C3D3z7fMJzdn814f5qwv3VhPurCfdXE+6vJnwfnLAXnbAXnbAXnbAXnbAXnbAXnfD3wQl70Ql70Ql70Ql70Ql70b/Wh7VzMuxFJ+xFJxJz7UUnfB+csBedsBedsBedsBcd+PaBbx/49oFvH/j2icJzLjxn91cT7q8m3F9NFOY25jbm2otO2ItO2ItO2ItO2ItO2ItO+PvghL3ohL3ohL3ohL3ohL3ohL3ohL3ohL3ohL3oxGCuveiE74MT9qIT9qITD/vKXnTg2we+feDbB7594NsnFs958ZwX73fxfhfvdzF3MXcx1150wl504nCODufIXnTCXnTisJ/tRScO58hedMJedOJwjuxFJ+xFJ+xFJ+xFJ4S59qITvg9O2ItO2ItO2ItO2osOfPvAtw98+8C3D3z7pPurSfdXk+6vJt1fTbq/mgzMDcwNzLUXnbQXnbQXnbQXnbQXnbQXnfT3wUl70Ul70Ul70Ul70Ul70Ul70Ul70Ul70Ul70cnCXHvRSd8HJ+1FJ+1FJ+1FJ+1FB7594NsHvn3g2we+fbLxnBvPufF+G++38X4bcxtzG3PtRSftRSftRSftRSftRSftRSf9fXDSXnTSXnTSXnTSXnTSXnTSXnTSXnTSXnTSXnTyYa696KTvg5P2opP2opOLfWUvOvDtA98+8O0D3z7w7ZOL57x4zof3e3i/h/d7mHuYe5hrLzppLzp5OEeHc2QvOmkvOinsZ3vRSeEc2YtO2otOCufIXnTSXnTKXnTKXnTKXnTKXnQK98GyF52yF52yF52yFx349oFvH/j2gW8f+PYp91dT7q+m3F9Nub+acn81FZibmIv7YNmLTtmLTtmLTtmLTtmLTtmLTvn74JS96JS96JS96JS96JS96JS96JS96JS96JS96FRhrr3oFO6DZS86ZS86ZS86ZS868O0D3z7w7QPfPvDtU4PnPHjOg/c7eL+D9zuYO5iL+2DZi07Zi07Zi07Zi07Zi07Zi0497Gd70Sl70Sl70Sl70amHc2QvOmUvOmUvOmUvOrWYay86hftg2YtO2YtOLfaVvejAtw98+8C3D3z7wLdPHZ7z4Tkf3u/h/QrvV5grzMV9sOxFp+xFp4RzJJwje9Epe9Fpfx+cthedthedthedthedthedthedthedthedthedDsy1F53GfbDtRaftRaftRaftRQe+feDbB7594NsHvn0a/VWjv2r0V43+qtFfNfqrRn/VuA+2vei0vei0vei0vei0vei0vei0vw9O24tO24tO24tO24tO24tO24tO24tO24tO24tON+bai07jPtj2otP2otODfWUvOvDtA98+8O0D3z7w7dPorxr9VaO/avRXjf6q0V81+qvGfbDtRaftRaftRacfzpG96LS96PRiP9uLTi/Okb3otL3o9OIc2YtO24tO24tO24tOH+bai07jPtj2otP2otOHfWUvOvDtA98+8O0D3z7w7dPorxr9VaO/avRXjf6q0V8N+qvBfXDsRWfsRWfsRWfsRWfsRWfsRWf8fXDGXnTGXnTGXnTGXnTGXnTGXnTGXnTGXnTGXnQmMNdedAb3wbEXnbEXnbEXnbEXHfj2gW8f+PaBbx/49hn0V4P+atBfDfqrQX816K8G/dXgPjj2ojP2ojP2ojP2ojP2ojP2ojP+PjhjLzpjLzpjLzpjLzpjLzpjLzpjLzpjLzpjLzozmGsvOoP74NiLztiLzgz2lb3owLcPfPvAtw98+8C3z6C/GvRXg/5q0F8N+qtBfzXorwb3wbEXnbEXnVmco8U5shedsRedOexne9GZwzmyF52xF505nCN70Rl70Rl70Rl70Rlhrr3oDO6DYy86Yy86I+wre9GBbx/49oFvH/j2gW+fh/7qob966K8e+quH/uqhv3rorx7ug89edJ696Dx70Xn2ovPsRefZi87D98FnLzrPXnSeveg8e9F59qLz7EXn2YvOsxedZy86LzHXXnQe7oPPXnSeveg8e9F59qID3z7w7QPfPvDtA98+D/3VQ3/10F899FcP/dVDf/XQXz3cB5+96Dx70Xn2ovPsRefZi86zF52H74PPXnSeveg8e9F59qLz7EXn2YvOsxedZy86z1503sNce9F5uA8+e9F59qLzHvaVvejAtw98+8C3D3z7wLfPQ3/10F899FcP/dVDf/XQXz30Vw/3wWcvOs9edN7hHB3Okb3oPHvRefg++OxF5wnnyF50nr3oPOEc2YvOsxedZy86z150njDXXnQW98G1F521F521F521Fx349oFvH/j2gW8f+PZZ9FeL/mrRXy36q0V/teivFv3V4j649qKz9qKz9qKz9qKz9qKz9qKz+D649qKz9qKz9qKz9qKz9qKz9qKz9qKz9qKz9qKzhbn2orO4D6696Ky96Ky96Ky96MC3D3z7wLcPfPvAt8+iv1r0V4v+atFfLfqrRX+16K8W98G1F521F521F521F521F521F53F98G1F521F521F521F521F521F521F521F521F51dzLUXncV9cO1FZ+1FZxf7yl504NsHvn3g2we+feDbZ9FfLfqrRX+16K8W/dWiv1r0V4v74NqLztqLzgrnSDhH9qKz9qKz+D649qKzwjmyF52zF52zF52zF52zF52zF52zF52zF52zF53DffDsRefsRefsRefsRQe+feDbB7594NsHvn0O/dWhvzr0V4f+6tBfHfqrQ391uA+eveicveicveicveicveicvegcvg+eveicveicveicveicveicveicveicveicvehcY6696Bzug2cvOmcvOmcvOmcvOvDtA98+8O0D3z7w7XPorw791aG/OvRXh/7q0F8d+qvDffDsRefsRefsRefsRefsRefsRefwffDsRecW58hedM5edG5xjuxF5+xF5+xF5+xF5xZz7UXncB88e9E5e9G5w76yFx349oFvH/j2gW8f+PY59FeH/urQXx36q0N/deivDv3V4T549qJz8KKCFxW8qOBFBS8qfB8UvKjgRQUvKnhRwYsKXlTwooIXFbyo4EUFLyrcBwUvKnhRwYsKXhS+feDbB7594NsHvn2E/kror4T+SuivhP5K6K+E/kq4DwpeVPCighcVvKjgRQUvKnwfFLyo4EUFLyp4UcGLCl5U8KKCFxW8qOBFBS8q3AcFLyp4UcGLCl4Uvn3g2we+feDbB759hP5K6K+E/kror4T+SuivhP5KuA8KXlTwooIXFbyo4EUFLyp8HxS8qOBFBS8qeFHBiwpeVPCighcVvKjgRQUvKtwHBS8qeFHBiwpeFL594NsHvn3g2we+fYT+Su6v3uf+6n3ur97n/up97q/e5/7qfb4Pvs9e9H32ou+zF32fvej77EXfZy/6Pn8ffJ+96PvsRd9nL/o+e9H32Yu+z170ffai77MXfZ+96PsSc+1F3+f74PvsRd9nL/o+e9H32Ys++PYH3/7g2x98+4Nvf1/hORees/ur97m/ep/7q/cV5jbmNubai77PXvR99qLvsxd9n73o++xF3+fvg++zF32fvej77EXfZy/6PnvR99mLvs9e9H32ou+zF33fYK696Pt8H3yfvej77EXf97Cv7EUffPuDb3/w7Q++/cG3v2/xnBfPefF+F+938X4XcxdzF3PtRd9nL/q+wzk6nCN70ffZi77vsJ/tRd93OEf2ou+zF33f4RzZi77PXvR99qLvsxd9nzDXXvR9vg++z170ffai77MXfWEv+uDbH3z7g29/8O0P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8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L377w7QvfvvDtC9++8O0L337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB99+8O0H337w7QfffvDtB9/+1zqxLqwb68H6Yb1YH9aYi7yCbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvP/j2g28/+PaDbz/49oNvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+Db/1on1oV1Yz1YP6wX68Mac5FX8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3C75d8O2Cbxd8u+DbBd8u+HbBtwu+XfDtgm8XfLvg2wXfLvh2wbcLvl3w7YJvF3y74NsF3y74dsG3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",
      "verification_key": "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"
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "external",
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9829419490427811213": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13921208329385594075": {
            "error_kind": "fmtstring",
            "length": 40,
            "item_types": []
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "1335198680857977525": {
            "error_kind": "string",
            "string": "No public functions"
          }
        }
      },
      "bytecode": "JwAABAEqAAABBRKHlCBFHCK1PAAAAQ==",
      "debug_symbols": "XY1bCoAgEEX3Mt+toK1EiI9RBkRl0iDEvWeRIH3ee+6jgkFVnKBg4wHrVkExeU9O+Khlphi6W9sCQ4rMiN2CiW97D0hN/C+dkkkqj5+0JeiJ5isNMk4TR42mMD5LL2t7uwE="
    }
  ],
  "outputs": {
    "globals": {},
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "contract_class_id",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::contract_class_id::ContractClassId"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ContractClassRegistry::assert_class_id_is_published_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ContractClassRegistry::assert_class_id_is_published_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "contract_class_id",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::contract_class_id::ContractClassId"
                    }
                  },
                  {
                    "name": "artifact_metadata_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "utility_functions_artifact_tree_root",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "private_function_tree_sibling_path",
                    "type": {
                      "kind": "array",
                      "length": 7,
                      "type": {
                        "kind": "field"
                      }
                    }
                  },
                  {
                    "name": "private_function_tree_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "artifact_function_tree_sibling_path",
                    "type": {
                      "kind": "array",
                      "length": 7,
                      "type": {
                        "kind": "field"
                      }
                    }
                  },
                  {
                    "name": "artifact_function_tree_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "function_data",
                    "type": {
                      "fields": [
                        {
                          "name": "selector",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                          }
                        },
                        {
                          "name": "metadata_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "vk_hash",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "events::private_function_broadcasted::InnerPrivateFunction"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ContractClassRegistry::broadcast_private_function_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ContractClassRegistry::broadcast_private_function_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "contract_class_id",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::contract_class_id::ContractClassId"
                    }
                  },
                  {
                    "name": "artifact_metadata_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "private_functions_artifact_tree_root",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "artifact_function_tree_sibling_path",
                    "type": {
                      "kind": "array",
                      "length": 7,
                      "type": {
                        "kind": "field"
                      }
                    }
                  },
                  {
                    "name": "artifact_function_tree_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "function_data",
                    "type": {
                      "fields": [
                        {
                          "name": "selector",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                          }
                        },
                        {
                          "name": "metadata_hash",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "events::utility_function_broadcasted::InnerUtilityFunction"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ContractClassRegistry::broadcast_utility_function_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ContractClassRegistry::broadcast_utility_function_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ContractClassRegistry::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ContractClassRegistry::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "artifact_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "private_functions_root",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "public_bytecode_commitment",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ContractClassRegistry::publish_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ContractClassRegistry::publish_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "ContractClassRegistry::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ContractClassRegistry::sync_private_state_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[external(\"utility\")] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    },
    "109": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY,\n        call_interface_stubs::{\n            register_private_fn_stub, register_public_fn_stub, register_utility_fn_stub,\n        },\n    },\n    notes::NOTES,\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_contract_library_method, is_fn_external,\n        is_fn_initializer, is_fn_internal, is_fn_test, is_fn_view, modify_fn_body,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse dep::protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    register_private_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    let (args_serialization, _, serialized_args_name) =\n        derive_serialization_quotes(original_params, false);\n\n    let context_creation = quote {\n        $args_serialization\n        let args_hash = dep::aztec::hash::hash_args_array($serialized_args_name);\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, args_hash);\n    };\n\n    let function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {function_name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message =\n            f\"Function {function_name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_private(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_private(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_private(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, true)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is serialized and hashed before being passed to the context.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n\n        let (return_serialization, _, serialized_return_name) =\n            derive_serialization_quotes([(return_value_var_name, return_value_type)], false);\n\n        body = body_without_return;\n\n        quote {\n            $return_value_assignment\n            $return_serialization\n            context.set_return_hash($serialized_return_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    register_public_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    let name = f.name();\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let name = f.name();\n        let assertion_message =\n            f\"Function {name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    register_utility_fn_stub(f);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage(f.module()) {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender().unwrap())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\n///\n/// # Arguments\n/// * `f` - The function definition to inject the authwit verification check into. The function must have parameters\n///         matching the names specified in the `#[authorize_once]` attribute.\n/// * `is_private` - Whether the function is a private function (`true`) or a public function (`false`). This determines\n///                  which authwit verification method to use: `assert_current_call_valid_authwit` for private functions\n///                  or `assert_current_call_valid_authwit_public` for public functions.\npub(crate) comptime fn create_authorize_once_check(\n    f: FunctionDefinition,\n    is_private: bool,\n) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[external(\\\"private\\\")] or #[external(\\\"public\\\")] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_private {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender().unwrap())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f) & !is_fn_contract_library_method(f) & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "114": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "115": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            compute_note_hash_for_nullification(retrieved_note, STORAGE_SLOT),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "116": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "117": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "118": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "119": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    process_message_plaintext(\n        contract_address,\n        compute_note_hash_and_nullifier,\n        AES128::decrypt(message_ciphertext, message_context.recipient),\n        message_context,\n    );\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "120": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// Each field of the original note log was serialized to 32 bytes. Below we convert the bytes back to fields.\n// 479 / 32 = 15\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "121": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret_using_aztec_address.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient).unwrap();\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, MESSAGE_PLAINTEXT_LEN> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        // TODO(#17158): handle invalid ephemeral keys when decrypting to prevent DoS vectors\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk.unwrap());\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret.unwrap());\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n"
    },
    "138": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "158": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "160": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n"
    },
    "169": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, length, counter)\n}\n\n#[oracle(privateNotifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    length: u32,\n    counter: u32,\n) {}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n"
    },
    "170": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "172": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_interface::NoteType, retrieved_note::RetrievedNote};\n\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(privateNotifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(privateNotifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(privateNotifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(utilityGetNotes)]\nunconstrained fn get_notes_oracle<Note, let M: u32, let MaxNotes: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to <RetrievedNote<Note> as Packable>::N. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\nwhere\n    // TODO(https://github.com/noir-lang/noir/issues/9399): `Note: Packable` should work here.\n    RetrievedNote<Note>: Packable,\n{}\n\npub unconstrained fn get_notes<Note, let M: u32, let MaxNotes: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MaxNotes]\nwhere\n    Note: NoteType + Packable,\n{\n    let packed_retrieved_notes: BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\n         = get_notes_oracle::<Note, M, MaxNotes>(\n            storage_slot,\n            num_selects,\n            select_by_indexes,\n            select_by_offsets,\n            select_by_lengths,\n            select_values,\n            select_comparators,\n            sort_by_indexes,\n            sort_by_offsets,\n            sort_by_lengths,\n            sort_order,\n            limit,\n            offset,\n            status,\n            MaxNotes,\n            <RetrievedNote<Note> as Packable>::N,\n        );\n\n    let mut notes = BoundedVec::<_, MaxNotes>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = RetrievedNote::unpack(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MaxNotes];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(utilityCheckNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n// TODO: Oracles below are generic private log oracles and are not specific to notes. Move them somewhere else.\n\n/// Returns the next app tag for a given sender and recipient pair.\n///\n/// This also notifies the simulator that a tag has been used in a note, and to therefore increment the\n/// associated index so that future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub unconstrained fn get_next_app_tag_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> Field {\n    get_next_app_tag_as_sender_oracle(sender, recipient)\n}\n\n#[oracle(privateGetNextAppTagAsSender)]\nunconstrained fn get_next_app_tag_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> Field {}\n\n/// Gets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// The value persists through nested calls, meaning all calls down the stack will use the same\n/// 'senderForTags' value (unless it is replaced).\npub unconstrained fn get_sender_for_tags() -> Option<AztecAddress> {\n    get_sender_for_tags_oracle()\n}\n\n#[oracle(privateGetSenderForTags)]\nunconstrained fn get_sender_for_tags_oracle() -> Option<AztecAddress> {}\n\n/// Sets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// Account contracts typically set this value before calling other contracts. The value persists\n/// through nested calls, meaning all calls down the stack will use the same 'senderForTags'\n/// value (unless it is replaced by another call to this setter).\npub unconstrained fn set_sender_for_tags(sender_for_tags: AztecAddress) {\n    set_sender_for_tags_oracle(sender_for_tags);\n}\n\n#[oracle(privateSetSenderForTags)]\nunconstrained fn set_sender_for_tags_oracle(_sender_for_tags: AztecAddress) {}\n"
    },
    "175": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "177": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 3;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version '3', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "211": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "214": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "215": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "217": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "218": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "221": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n"
    },
    "232": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "303": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/contract_class_id.nr",
      "source": "use crate::constants::GENERATOR_INDEX__CONTRACT_LEAF;\nuse crate::traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct ContractClassId {\n    pub inner: Field,\n}\n\nimpl ToField for ContractClassId {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for ContractClassId {\n    fn from_field(value: Field) -> Self {\n        Self { inner: value }\n    }\n}\n\nimpl Empty for ContractClassId {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ContractClassId {\n    pub fn compute(\n        artifact_hash: Field,\n        private_functions_root: Field,\n        public_bytecode_commitment: Field,\n    ) -> Self {\n        let hash = crate::hash::poseidon2_hash_with_separator(\n            [artifact_hash, private_functions_root, public_bytecode_commitment],\n            GENERATOR_INDEX__CONTRACT_LEAF,\n        ); // TODO(@spalladino): Update generator index\n        ContractClassId::from_field(hash)\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "310": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n"
    },
    "319": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash/poseidon2_chunks.nr",
      "source": "use crate::{constants::TWO_POW_64, poseidon2::Poseidon2Sponge};\n\n/// Computes, for a given sponge cache size, the number of items needed to reach cache size 1.\n/// Fails if the sponge cache size is greater than the permutation size.\nfn items_needed_for_cache_1<let PERMUTATION_SIZE: u32>(sponge_cache_size: u32) -> u32 {\n    assert(\n        sponge_cache_size <= PERMUTATION_SIZE,\n        \"Sponge cache size is greater than permutation size\",\n    );\n    if sponge_cache_size == 0 {\n        1\n    } else if sponge_cache_size == 1 {\n        0\n    } else {\n        (PERMUTATION_SIZE + 1) - sponge_cache_size\n    }\n}\n\n/// Absorbs a number of items into a sponge from a larger array, one by one.\n/// Fails if the number of items is greater than the maximum number of items\n/// comptime defined.\nfn absorb_items<let N: u32, let MAX_ITEMS: u32>(\n    mut sponge: Poseidon2Sponge,\n    input: [Field; N],\n    offset: u32,\n    num_items: u32,\n) -> Poseidon2Sponge {\n    let mut should_add = true;\n    assert(num_items <= MAX_ITEMS, \"num_items is greater than MAX_ITEMS\");\n\n    for i in 0..MAX_ITEMS {\n        should_add &= i != num_items;\n        if should_add {\n            sponge.absorb(input[offset + i]);\n        }\n    }\n\n    sponge\n}\n\n/// Absorbs a number of full permutations into a sponge from a larger array.\n/// Assumes permutations that can ingest 3 items at a time.\n/// Important: assumes that the sponge is in cache_size=1\n/// In order to use this function with non-zero num_permutations, you must first align the sponge to cache_size=1 using `items_needed_for_cache_1`.\nfn absorb_full_permutations<let NUM_ITEMS: u32, let MAX_PERMUTATIONS: u32>(\n    mut sponge: Poseidon2Sponge,\n    input: [Field; NUM_ITEMS],\n    offset: u32,\n    num_permutations: u32,\n) -> Poseidon2Sponge {\n    std::static_assert(sponge.cache.len() == 3, \"Sponge cache must be 3 items\");\n    assert(\n        num_permutations <= MAX_PERMUTATIONS,\n        \"num_permutations is greater than MAX_PERMUTATIONS\",\n    );\n    if (num_permutations != 0) {\n        assert(sponge.cache_size == 1, \"Sponge must be in cache_size=1\");\n    }\n    let mut should_add = true;\n\n    for i in 0..MAX_PERMUTATIONS {\n        should_add &= i != num_permutations;\n        let chunk_base_index = offset + i * 3;\n        if should_add {\n            sponge.cache[1] = input[chunk_base_index];\n            sponge.cache[2] = input[chunk_base_index + 1];\n            // Add cache to state before permutation (duplex operation)\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[chunk_base_index + 2];\n        }\n    }\n\n    sponge\n}\n\n/// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n/// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n/// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n/// The below code forces the compiler to:\n///  - absorb normally up to 2 times to set cache_size to 1\n///  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n///  - absorb normally up to 2 times to add any remaining values to the hash\n/// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\nfn absorb_in_chunks<let NUM_ITEMS: u32, let MAX_CHUNKS: u32>(\n    mut sponge: Poseidon2Sponge,\n    input: [Field; NUM_ITEMS],\n    in_len: u32,\n) -> Poseidon2Sponge {\n    std::static_assert(\n        MAX_CHUNKS * 3 <= NUM_ITEMS,\n        \"MAX_CHUNKS * 3 must be less than or equal to NUM_ITEMS\",\n    );\n    std::static_assert(\n        (MAX_CHUNKS + 1) * 3 > NUM_ITEMS,\n        \"MAX_CHUNKS + 1 * 3 must be greater than NUM_ITEMS\",\n    );\n\n    // In order to absorb full permutations, we need cache_size to be 1\n    let prefix_items_to_align = items_needed_for_cache_1::<3>(sponge.cache_size);\n\n    // Absorb up to cache size 1\n    let num_prefix_items = std::cmp::min(prefix_items_to_align, in_len);\n\n    sponge = absorb_items::<NUM_ITEMS, 2>(sponge, input, 0, num_prefix_items);\n\n    // Now cache size is 1, we can absorb full permutations\n    let num_full_permutations = (in_len - num_prefix_items) / 3;\n\n    sponge = absorb_full_permutations::<NUM_ITEMS, MAX_CHUNKS>(\n        sponge,\n        input,\n        num_prefix_items,\n        num_full_permutations,\n    );\n\n    // Now we need to absorb any remaining items that don't complete a permutation\n    let num_suffix_items = in_len - num_prefix_items - num_full_permutations * 3;\n\n    sponge = absorb_items::<NUM_ITEMS, 2>(\n        sponge,\n        input,\n        num_prefix_items + num_full_permutations * 3,\n        num_suffix_items,\n    );\n\n    sponge\n}\n\npub fn poseidon2_absorb_in_chunks_existing_sponge<let NUM_ITEMS: u32>(\n    mut sponge: Poseidon2Sponge,\n    input: [Field; NUM_ITEMS],\n    in_len: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= NUM_ITEMS, \"Given in_len to absorb is larger than the input array len\");\n    assert(!sponge.squeeze_mode, \"Cannot absorb in squeeze mode\");\n\n    absorb_in_chunks::<NUM_ITEMS, (NUM_ITEMS - (NUM_ITEMS % 3)) / 3>(sponge, input, in_len)\n}\n\npub fn poseidon2_absorb_in_chunks<let N: u32>(input: [Field; N], in_len: u32) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    poseidon2_absorb_in_chunks_existing_sponge(Poseidon2Sponge::new(iv), input, in_len)\n}\n\nmod tests {\n    use crate::constants::TWO_POW_64;\n    use crate::poseidon2::Poseidon2Sponge;\n    use super::{\n        absorb_full_permutations, absorb_items, items_needed_for_cache_1,\n        poseidon2_absorb_in_chunks, poseidon2_absorb_in_chunks_existing_sponge,\n    };\n\n    #[test]\n    fn test_items_needed_for_cache_1() {\n        // Test various cache sizes and their alignment requirements\n        assert(items_needed_for_cache_1::<3>(0) == 1, \"Cache size 0 should need 1 item\");\n        assert(items_needed_for_cache_1::<3>(1) == 0, \"Cache size 1 should need 0 items\");\n        assert(items_needed_for_cache_1::<3>(2) == 2, \"Cache size 2 should need 2 items\");\n        assert(items_needed_for_cache_1::<3>(3) == 1, \"Cache size 3 should need 1 item\");\n    }\n\n    #[test(should_fail_with = \"Sponge cache size is greater than permutation size\")]\n    fn test_items_needed_for_cache_1_exceeds_permutation_size() {\n        let _ = items_needed_for_cache_1::<3>(4);\n    }\n\n    #[test]\n    fn test_absorb_items_zero_items() {\n        let input: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let sponge = Poseidon2Sponge::new(0);\n\n        let mut result = absorb_items::<10, 2>(sponge, input, 0, 0);\n\n        // Should produce same output as original sponge with no absorption\n        assert(result.squeeze() == Poseidon2Sponge::new(0).squeeze(), \"No items absorbed\");\n    }\n\n    #[test]\n    fn test_absorb_items_multiple() {\n        let input: [Field; 10] = [42, 43, 3, 4, 5, 6, 7, 8, 9, 10];\n        let sponge = Poseidon2Sponge::new(0);\n\n        let mut result = absorb_items::<10, 2>(sponge, input, 0, 2);\n\n        // Verify by comparing with manual absorption\n        let mut expected = Poseidon2Sponge::new(0);\n        expected.absorb(42);\n        expected.absorb(43);\n\n        assert(result.squeeze() == expected.squeeze(), \"Should absorb multiple items correctly\");\n    }\n\n    #[test]\n    fn test_absorb_items_with_offset() {\n        let input: [Field; 10] = [1, 2, 42, 43, 5, 6, 7, 8, 9, 10];\n        let sponge = Poseidon2Sponge::new(0);\n\n        let mut result = absorb_items::<10, 2>(sponge, input, 2, 2);\n\n        // Verify items at offset 2 were absorbed\n        let mut expected = Poseidon2Sponge::new(0);\n        expected.absorb(42);\n        expected.absorb(43);\n\n        assert(result.squeeze() == expected.squeeze(), \"Should absorb items starting at offset\");\n    }\n\n    #[test(should_fail_with = \"num_items is greater than MAX_ITEMS\")]\n    fn test_absorb_items_exceeds_max_items() {\n        let input: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let sponge = Poseidon2Sponge::new(0);\n\n        let _ = absorb_items::<10, 2>(sponge, input, 0, 3);\n    }\n\n    #[test]\n    fn test_absorb_full_permutations() {\n        let input: [Field; 12] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n        let mut sponge = Poseidon2Sponge::new(0);\n        // Set cache_size to 1 by absorbing one item\n        sponge.absorb(100);\n\n        let mut result = absorb_full_permutations::<12, 3>(sponge, input, 0, 2);\n\n        // Verify by manually absorbing the same items\n        let mut expected = Poseidon2Sponge::new(0);\n        expected.absorb(100);\n        for i in 0..6 {\n            expected.absorb(input[i]);\n        }\n\n        assert(result.squeeze() == expected.squeeze(), \"Should absorb full permutations correctly\");\n    }\n\n    #[test]\n    fn test_absorb_full_permutations_zero() {\n        let input: [Field; 12] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n        let mut sponge = Poseidon2Sponge::new(0);\n        sponge.absorb(100);\n\n        let mut result = absorb_full_permutations::<12, 3>(sponge, input, 0, 0);\n\n        // Should be same as original sponge with no additional absorption\n        let mut expected = Poseidon2Sponge::new(0);\n        expected.absorb(100);\n\n        assert(\n            result.squeeze() == expected.squeeze(),\n            \"Zero permutations should not change sponge\",\n        );\n    }\n\n    #[test(should_fail_with = \"Sponge must be in cache_size=1\")]\n    fn test_absorb_full_permutations_wrong_cache_size() {\n        let input: [Field; 12] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n        let sponge = Poseidon2Sponge::new(0); // cache_size is 0\n\n        let _ = absorb_full_permutations::<12, 3>(sponge, input, 0, 1);\n    }\n\n    #[test(should_fail_with = \"num_permutations is greater than MAX_PERMUTATIONS\")]\n    fn test_absorb_full_permutations_exceeds_max() {\n        let input: [Field; 12] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n        let mut sponge = Poseidon2Sponge::new(0);\n        sponge.absorb(100);\n\n        let _ = absorb_full_permutations::<12, 2>(sponge, input, 0, 3);\n    }\n\n    #[test]\n    fn existing_sponge_poseidon_chunks_matches_fixed() {\n        let in_len = 501;\n        let mut input: [Field; 4096] = [0; 4096];\n        let mut fixed_input = [3; 501];\n        assert(in_len == fixed_input.len()); // sanity check\n        for i in 0..in_len {\n            input[i] = 3;\n        }\n        // absorb 250 of the 501 things\n        let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n        let first_sponge = poseidon2_absorb_in_chunks_existing_sponge(empty_sponge, input, 250);\n        // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n        let mut final_sponge = poseidon2_absorb_in_chunks_existing_sponge(first_sponge, input, 251);\n        let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n        assert(final_sponge.squeeze() == fixed_len_hash);\n    }\n\n    #[test]\n    fn poseidon_chunks_empty_inputs() {\n        let in_len = 0;\n        let mut input: [Field; 4096] = [0; 4096];\n        let mut constructed_empty_sponge = poseidon2_absorb_in_chunks(input, in_len);\n        let mut first_sponge =\n            poseidon2_absorb_in_chunks_existing_sponge(constructed_empty_sponge, input, in_len);\n        assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n    }\n\n    #[test]\n    fn test_poseidon_chunks_various_lengths() {\n        // Test multiple lengths to ensure correctness across different permutation boundaries\n        let mut input: [Field; 20] = [0; 20];\n        for i in 0..20 {\n            input[i] = (i + 1) as Field;\n        }\n\n        // Test length 1\n        let mut result = poseidon2_absorb_in_chunks(input, 1);\n        assert(result.squeeze() == Poseidon2Sponge::hash([1], 1), \"Length 1 failed\");\n\n        // Test length 3 (exactly one full permutation)\n        let mut result = poseidon2_absorb_in_chunks(input, 3);\n        assert(result.squeeze() == Poseidon2Sponge::hash([1, 2, 3], 3), \"Length 3 failed\");\n\n        // Test length 7 (2 full permutations + 1)\n        let mut result = poseidon2_absorb_in_chunks(input, 7);\n        assert(\n            result.squeeze() == Poseidon2Sponge::hash([1, 2, 3, 4, 5, 6, 7], 7),\n            \"Length 7 failed\",\n        );\n\n        // Test length 10 (3 full permutations + 1)\n        let mut result = poseidon2_absorb_in_chunks(input, 10);\n        assert(\n            result.squeeze() == Poseidon2Sponge::hash([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n            \"Length 10 failed\",\n        );\n    }\n\n    #[test]\n    fn test_poseidon_chunks_with_extra_non_zero_values() {\n        let mut input: [Field; 10] = [0; 10];\n        input[0] = 42;\n        input[1] = 43;\n        input[2] = 44;\n        // Only absorb the 3 fields above.\n        let in_len = 3;\n        input[3] = 99;\n        input[9] = 9999;\n\n        let mut result = poseidon2_absorb_in_chunks(input, in_len);\n        let expected = Poseidon2Sponge::hash([42, 43, 44], in_len);\n\n        assert(result.squeeze() == expected);\n    }\n\n    #[test]\n    fn test_incremental_absorption_matches_all_at_once() {\n        let mut input: [Field; 30] = [0; 30];\n        for i in 0..15 {\n            input[i] = (i + 100) as Field;\n        }\n\n        // Absorb all 15 at once\n        let iv = (15 as Field) * TWO_POW_64;\n        let mut all_at_once =\n            poseidon2_absorb_in_chunks_existing_sponge(Poseidon2Sponge::new(iv), input, 15);\n\n        // Absorb incrementally: 7 + 8\n        let mut incremental =\n            poseidon2_absorb_in_chunks_existing_sponge(Poseidon2Sponge::new(iv), input, 7);\n        let mut remaining: [Field; 30] = [0; 30];\n        for i in 0..8 {\n            remaining[i] = input[7 + i];\n        }\n        incremental = poseidon2_absorb_in_chunks_existing_sponge(incremental, remaining, 8);\n\n        let all_at_once_hash = all_at_once.squeeze();\n        let incremental_hash = incremental.squeeze();\n        assert(\n            all_at_once_hash == incremental_hash,\n            \"Incremental absorption should match all-at-once\",\n        );\n\n        // verify that both match using the standard poseidon2 hash\n        let mut exact_input = [0; 15];\n        for i in 0..15 {\n            exact_input[i] = (i + 100) as Field;\n        }\n        let exact_hash = Poseidon2Sponge::hash(exact_input, 15);\n        assert(all_at_once_hash == exact_hash, \"Chunked should match standard poseidon2 hash\");\n    }\n\n    #[test(should_fail_with = \"Given in_len to absorb is larger than the input array len\")]\n    fn test_poseidon_chunks_length_exceeds_array() {\n        let input: [Field; 5] = [1, 2, 3, 4, 5];\n        let _ = poseidon2_absorb_in_chunks(input, 10);\n    }\n\n    #[test]\n    fn test_large_absorption() {\n        // Test a larger number to ensure the optimization works correctly\n        let mut input: [Field; 100] = [0; 100];\n        for i in 0..50 {\n            input[i] = (i + 1) as Field;\n        }\n\n        let mut result = poseidon2_absorb_in_chunks(input, 50);\n\n        // Verify against standard approach\n        let mut expected_input = [0; 50];\n        for i in 0..50 {\n            expected_input[i] = (i + 1) as Field;\n        }\n        let expected = Poseidon2Sponge::hash(expected_input, 50);\n\n        assert(result.squeeze() == expected, \"Large absorption should work correctly\");\n    }\n\n    #[test]\n    fn fuzz_7_items(items: [Field; 7], mut in_len: u32) {\n        in_len = std::cmp::min(in_len, 7);\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n\n        for i in 0..7 {\n            if i < in_len {\n                sponge.absorb(items[i]);\n            }\n        }\n        let expected_result = sponge.squeeze();\n        let chunked_result = poseidon2_absorb_in_chunks(items, in_len).squeeze();\n        assert(chunked_result == expected_result, \"Fuzz 7 items should match expected\");\n    }\n\n    #[test]\n    fn fuzz_30_items(items: [Field; 30], mut in_len: u32) {\n        in_len = std::cmp::min(in_len, 30);\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n\n        for i in 0..30 {\n            if i < in_len {\n                sponge.absorb(items[i]);\n            }\n        }\n        let expected_result = sponge.squeeze();\n        let chunked_result = poseidon2_absorb_in_chunks(items, in_len).squeeze();\n        assert(chunked_result == expected_result, \"Fuzz 30 items should match expected\");\n    }\n\n    #[test]\n    fn fuzz_1024_items(items: [Field; 1024], mut in_len: u32) {\n        in_len = std::cmp::min(in_len, 1024);\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n\n        for i in 0..1024 {\n            if i < in_len {\n                sponge.absorb(items[i]);\n            }\n        }\n        let expected_result = sponge.squeeze();\n        let chunked_result = poseidon2_absorb_in_chunks(items, in_len).squeeze();\n        assert(chunked_result == expected_result, \"Fuzz 1024 items should match expected\");\n    }\n\n    #[test(should_fail_with = \"Cannot absorb in squeeze mode\")]\n    fn test_cannot_absorb_after_squeeze() {\n        let input: [Field; 10] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let mut sponge = Poseidon2Sponge::new(0);\n\n        // Absorb some data\n        sponge.absorb(100);\n\n        // Squeeze to enter squeeze mode\n        let _ = sponge.squeeze();\n\n        // Try to absorb more data using chunked function - should fail\n        let _ = poseidon2_absorb_in_chunks_existing_sponge(sponge, input, 5);\n    }\n\n}\n"
    },
    "320": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "333": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "334": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr",
      "source": "/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n"
    },
    "336": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "364": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "367": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            let T_N = serialized_t.len();\n            for j in 0..T_N {\n                result[i * T_N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn array_serialization() {\n        let array = [1, 2, 3, 4];\n\n        let serialized: [Field; 4] = array.serialize();\n        let deserialized: [Field; 4] = Deserialize::deserialize(serialized);\n        assert_eq(deserialized, array);\n    }\n\n    #[test]\n    fn nested_array_serialization() {\n        let nested_array = [[1, 2, 3, 4], [5, 6, 7, 8]];\n\n        let serialized: [Field; 8] = nested_array.serialize();\n        let deserialized: [[Field; 4]; 2] = Deserialize::deserialize(serialized);\n\n        assert_eq(deserialized, nested_array);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "384": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_padded_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_padded_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod assert_trailing_zeros;\npub mod find_index;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped,\n    assert_array_appended_reversed_to_empty_dest, assert_array_appended_reversed_up_to_some_length,\n    assert_array_appended_to_empty_dest, assert_array_appended_to_empty_dest_and_scoped,\n};\npub use assert_array_prepended::{assert_array_prepended, assert_array_prepended_up_to_some_length};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_padded_array::{\n    assert_sorted_transformed_i_padded_array_capped_size,\n    assert_sorted_transformed_padded_array_capped_size, check_padded_items,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},\n};\npub use assert_split_transformed_padded_arrays::assert_split_transformed_padded_arrays;\npub use assert_trailing_zeros::assert_trailing_zeros;\npub use find_index::{find_first_index, find_last_index};\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use get_sorted_tuple::{get_sorted_tuple, SortedTuple};\npub use sort_by_counter::sort_by_counter_asc;\n\nuse crate::traits::{Deserialize, Empty, Serialize};\nuse super::for_loop::{for_i_in_0_, for_i_only_in_0_};\n\n//**********************************************************************************\n// ARRAY\n//**********************************************************************************\n\n// TODO: Consider making this a part of the noir stdlib.\n/// Helper fn to create a subarray from a given array.\npub fn subarray<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate.\n// If the element is not found, the function returns Option::none.\n// TODO: Consider making this a part of the noir stdlib.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> Option<u32> {\n    let mut index: Option<u32> = Option::none();\n    for i in 0..N {\n        if find(array[i]) {\n            index = Option::some(i);\n            break;\n        }\n    }\n    index\n}\n\n// Helper function to find the index of the first element (starting from the back) of an array that satisfies a given predicate.\n// If the element is not found, the function returns Option::none.\n// TODO: Consider making this a part of the noir stdlib.\npub unconstrained fn find_index_hint_in_reverse<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> Option<u32> {\n    let mut index: Option<u32> = Option::none();\n    for i in 0..N {\n        let j = N - i - 1;\n        if find(array[j]) {\n            index = Option::some(j);\n            break;\n        }\n    }\n    index\n}\n\n//**********************************************************************************\n// FREE ARRAY FUNCTIONS (to deprecate or make into methods of array wrappers)\n//**********************************************************************************\n\n/// Deprecated.\n///\n/// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n/// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n/// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if array[i].is_empty() {\n            seen_empty = true;\n        } else {\n            assert_eq(seen_empty, false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n/// Deprecated.\n///\n/// Helper function to count the number of non-empty elements in a validated array.\n/// Important: Only use it for validated arrays where validate_array(array) returns true,\n/// which ensures that:\n/// 1. All elements before the first empty element are non-empty\n/// 2. All elements after and including the first empty element are empty\n/// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let maybe_length = unsafe { find_index_hint(array, |elem: T| elem.is_empty()) };\n\n    let mut length = N;\n\n    if maybe_length.is_some() {\n        length = maybe_length.unwrap_unchecked();\n\n        array[length].assert_empty(\"Expected array empty\");\n    }\n\n    if length != 0 {\n        assert(!array[length - 1].is_empty());\n    }\n\n    length\n}\n\n// Returns an array length defined by fully trimming _all_ \"empty\" items\n// from the RHS.\npub unconstrained fn trimmed_array_length_hint<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty,\n{\n    let maybe_index_of_last_nonempty =\n        find_index_hint_in_reverse(array, |elem: T| !elem.is_empty());\n    let length: u32 = if maybe_index_of_last_nonempty.is_some() {\n        1 + maybe_index_of_last_nonempty.unwrap_unchecked()\n    } else {\n        0\n    };\n    length\n}\n\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !elem.is_empty() {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !elem.is_empty() {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n/// Helper function to convert a validated array to BoundedVec.\n/// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Returns the number of consecutive elements at the start of the array for which the predicate returns false.\n// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.\npub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {\n    let mut length = 0;\n    let mut stop = false;\n    for i in 0..N {\n        if predicate(array[i]) {\n            stop = true;\n        } else {\n            assert(\n                stop == false,\n                \"matching element found after already encountering a non-matching element\",\n            );\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to check if an array is padded with a given value from a given index.\n// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.\npub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool\nwhere\n    T: Eq,\n{\n    let mut is_valid = true;\n    let mut should_check = false;\n    for i in 0..N {\n        should_check |= i == from_index;\n        is_valid &= !should_check | (array[i] == padded_with);\n    }\n    is_valid\n}\n\n//**********************************************************************************\n// ARRAY WRAPPERS\n//**********************************************************************************\n\n/*\n *\n *\n *                                                                                                    \n *                          |-----------------------------------------|------------------------------| \n *                          | LHS                                     | RHS                          |\n *                          |-----------------------------------------|------------------------------|\n *       ClaimedLengthArray | Interspersed 0s possible.               | Unvalidated.                 |\n *                          | Possibly not fully trimmed.             | Nonempty elements possible.  |\n *                          |-----------------------------------------|------------------------------|\n *            EmptyRHSArray | Interspersed 0s possible.               | All 0s (validated).          |\n *                          | Possibly not fully trimmed.             |                              |\n *                          |-----------------------------------------|------------------------------|\n *             TrimmedArray | Interspersed 0s possible.               | All 0s (validated)           |\n *                          | Last lhs element validated as nonempty. |                              |\n *                          | (I.e. fully trimmed)                    |                              |\n *                          |-----------------------------------------|------------------------------|\n *        DenseTrimmedArray | Dense (validated).                      | All 0s (validated)           |\n *                          |-----------------------------------------|------------------------------|\n *\n *\n *                          | What guarantees do we have?                      |\n *                          |--------|--------|--------------------------------| \n *                          | Dense? | RHS    | Length vs Fully Trimmed Length |\n *                          |--------|--------|--------------------------------|\n *       ClaimedLengthArray | ?      | ?      | ?                              |\n *                          |        |        |                                |\n *                          |--------|--------|--------------------------------|\n *            EmptyRHSArray | ?      | All 0s | Length >= Fully Trimmed Length |\n *                          |        |        |                                |\n *                          |--------|--------|--------------------------------|\n *             TrimmedArray | ?      | All 0s | Length == Fully Trimmed Length |\n *                          |        |        |                                |\n *                          |        |        |                                |\n *                          |--------|--------|--------------------------------|\n *        DenseTrimmedArray | Yes    | All 0s | Length == Fully Trimmed Length |\n *                          |--------|--------|--------------------------------|\n *\n *\n * An ClaimedLengthArray is distinct from a regular array [T; N], because it carries a length.\n * \n */\n\n/// ClaimedLengthArray - An array interpreted by Kernel circuits.\n/// Its `length` is merely a claim that must eventually be validated.\n/// Validation must include:\n/// - Asserting all items to the LHS of the length are nonempty (dense).\n/// - Asserting all items to the RHS of the length are empty.\n#[derive(Deserialize, Serialize)]\npub struct ClaimedLengthArray<T, let N: u32> {\n    pub array: [T; N],\n    pub length: u32,\n}\n\nimpl<T, let N: u32> ClaimedLengthArray<T, N>\nwhere\n    T: Empty,\n{\n    // No constructor. Append to an empty one.\n\n    // For constrained append functions, see the dedicated file: assert_array_appended.nr\n\n    pub fn push(&mut self, item: T) {\n        assert(self.length != N, \"Array full\");\n\n        let next_index = self.length;\n        self.array[next_index] = item;\n        self.length += 1;\n    }\n\n    pub fn assert_dense_trimmed(self) {\n        for_i_in_0_(\n            self.length,\n            self.array.len(),\n            |i| {\n                assert(!self.array[i].is_empty(), \"LHS of input array is not dense\")\n                // Requires Noir #9002:\n                // self.array[i].assert_not_empty(\"LHS of input array is not dense\"); // LHS of input array is not dense.\n            },\n            |i| self.array[i].assert_empty(\"RHS of input array is not empty\"),\n            false,\n        );\n    }\n\n    pub fn assert_empty<let S: u32>(self, msg: str<S>) {\n        for i in 0..N {\n            self.array[i].assert_empty(msg);\n        }\n        assert_eq(self.length, 0);\n    }\n\n    pub unconstrained fn push_hint(&mut self, item: T) {\n        assert(self.length != N, \"Array full\");\n\n        let mut next_index = self.length;\n        self.array[next_index] = item;\n        self.length += 1;\n    }\n\n    pub unconstrained fn pop_hint(&mut self) -> T {\n        assert(self.length != 0, \"Array empty\");\n\n        let mut top_index = self.length - 1;\n        let popped_item = self.array[top_index];\n        self.array[top_index] = T::empty();\n        self.length -= 1;\n        popped_item\n    }\n\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        // We pass `false`, because by construction, we should know that self.length <= self.array.len().\n        for_i_only_in_0_(self.length, self.array.len(), |i| f(self.array[i]), false);\n    }\n\n    // E.g.\n    // dest.for_each_i(|source_item, i| { assert_eq(dest.array[i], source_item, \"bad copy\"); })\n    pub fn for_each_i<Env>(self, f: fn[Env](T, u32) -> ()) {\n        // We pass `false`, because by construction, we should know that self.length <= self.array.len().\n        for_i_only_in_0_(\n            self.length,\n            self.array.len(),\n            |i| f(self.array[i], i),\n            false,\n        );\n    }\n\n    pub fn from_bounded_vec(vec: BoundedVec<T, N>) -> Self {\n        Self { array: vec.storage(), length: vec.len() }\n    }\n}\n\n// TODO: compiler bug. No idea why this is needed, if we have #[derive(Eq)] above the struct definition.\nimpl<T, let N: u32> Eq for ClaimedLengthArray<T, N>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.array == other.array) & (self.length == other.length)\n    }\n}\n\nimpl<T, let N: u32> Empty for ClaimedLengthArray<T, N>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { array: [T::empty(); N], length: 0 }\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn test_array_length_until() {\n    let array = [11, 22, 33, 44, 55];\n    assert_eq(array_length_until(array, |x| x == 55), 4);\n    assert_eq(array_length_until(array, |x| x == 56), 5);\n    assert_eq(array_length_until(array, |x| x > 40), 3);\n    assert_eq(array_length_until(array, |x| x > 10), 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_non_consecutive_fails() {\n    let array = [1, 1, 0, 1, 0];\n    let _ = array_length_until(array, |x| x == 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_first_non_matching_fails() {\n    let array = [1, 0, 0, 0, 0];\n    let _ = array_length_until(array, |x| x == 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let maybe_index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(maybe_index.unwrap_unchecked(), 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let maybe_index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(maybe_index.is_none(), true);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test]\nfn test_array_padded_with() {\n    let array = [11, 22, 33, 44, 44];\n    assert_eq(array_padded_with(array, 0, 44), false);\n    assert_eq(array_padded_with(array, 1, 44), false);\n    assert_eq(array_padded_with(array, 2, 44), false);\n    assert_eq(array_padded_with(array, 3, 44), true);\n    assert_eq(array_padded_with(array, 4, 44), true);\n    assert_eq(array_padded_with(array, 4, 33), false);\n    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.\n    assert_eq(array_padded_with(array, 0, 11), false);\n}\n"
    },
    "385": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimized to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n"
    },
    "389": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "54": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/protocol/contract_class_registry/src/main.nr",
      "source": "mod events;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract ContractClassRegistry {\n    use dep::aztec::{\n        hash::compute_public_bytecode_commitment,\n        macros::functions::external,\n        protocol_types::{\n            constants::{\n                ARTIFACT_FUNCTION_TREE_MAX_HEIGHT, CONTRACT_CLASS_REGISTRY_BYTECODE_CAPSULE_SLOT,\n                FUNCTION_TREE_HEIGHT, MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS,\n                MAX_PACKED_BYTECODE_SIZE_PER_UTILITY_FUNCTION_IN_FIELDS,\n                MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n            },\n            contract_class_id::ContractClassId,\n            traits::ToField,\n        },\n    };\n\n    use crate::events::{\n        class_published::ContractClassPublished,\n        private_function_broadcasted::{\n            ClassPrivateFunctionBroadcasted, InnerPrivateFunction, PrivateFunction,\n        },\n        utility_function_broadcasted::{\n            ClassUtilityFunctionBroadcasted, InnerUtilityFunction, UtilityFunction,\n        },\n    };\n\n    use dep::aztec::oracle::capsules;\n\n    #[external(\"private\")]\n    fn publish(\n        artifact_hash: Field,\n        private_functions_root: Field,\n        public_bytecode_commitment: Field,\n    ) {\n        // Safety: We load the bytecode via a capsule, which is unconstrained. In order to ensure the loaded bytecode\n        // matches the expected one, we recompute the commitment and assert it matches the one provided by the caller.\n        let mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS] = unsafe {\n            capsules::load(\n                context.this_address(),\n                CONTRACT_CLASS_REGISTRY_BYTECODE_CAPSULE_SLOT,\n            )\n                .unwrap()\n        };\n        // Compute and check the public bytecode commitment\n        let computed_public_bytecode_commitment =\n            compute_public_bytecode_commitment(packed_public_bytecode);\n        assert_eq(computed_public_bytecode_commitment, public_bytecode_commitment);\n\n        // Compute contract class id from preimage\n        let contract_class_id = ContractClassId::compute(\n            artifact_hash,\n            private_functions_root,\n            public_bytecode_commitment,\n        );\n\n        // Emit the contract class id as a nullifier:\n        // - to demonstrate that this contract class hasn't been published before\n        // - to enable apps to read that this contract class has been published.\n        context.push_nullifier(contract_class_id.to_field());\n\n        // Broadcast class info including public bytecode\n        dep::aztec::oracle::debug_log::debug_log_format(\n            \"ContractClassPublished: {}\",\n            [\n                contract_class_id.to_field(),\n                artifact_hash,\n                private_functions_root,\n                public_bytecode_commitment,\n            ],\n        );\n\n        let event = ContractClassPublished {\n            contract_class_id,\n            version: 1,\n            artifact_hash,\n            private_functions_root,\n            packed_public_bytecode,\n        };\n        context.emit_contract_class_log(event.serialize_non_standard());\n    }\n\n    #[external(\"private\")]\n    fn broadcast_private_function(\n        contract_class_id: ContractClassId,\n        artifact_metadata_hash: Field,\n        utility_functions_artifact_tree_root: Field,\n        private_function_tree_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n        private_function_tree_leaf_index: Field,\n        artifact_function_tree_sibling_path: [Field; ARTIFACT_FUNCTION_TREE_MAX_HEIGHT],\n        artifact_function_tree_leaf_index: Field,\n        function_data: InnerPrivateFunction,\n    ) {\n        // Safety: The bytecode loaded here is unconstrained, which is acceptable since:\n        // 1. Unlike public functions, we don't need execution guarantees for private functions.\n        // 2. This broadcast simply provides convenient bytecode sharing vs offchain distribution.\n        // 3. Computing the VK for private bytecode in-circuit is not possible, so we can't do better.\n        let private_bytecode: [Field; MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS] = unsafe {\n            capsules::load(\n                context.this_address(),\n                CONTRACT_CLASS_REGISTRY_BYTECODE_CAPSULE_SLOT,\n            )\n                .unwrap()\n        };\n\n        let event = ClassPrivateFunctionBroadcasted {\n            contract_class_id,\n            artifact_metadata_hash,\n            utility_functions_artifact_tree_root,\n            private_function_tree_sibling_path,\n            private_function_tree_leaf_index,\n            artifact_function_tree_sibling_path,\n            artifact_function_tree_leaf_index,\n            function: PrivateFunction {\n                selector: function_data.selector,\n                metadata_hash: function_data.metadata_hash,\n                vk_hash: function_data.vk_hash,\n                bytecode: private_bytecode,\n            },\n        };\n        dep::aztec::oracle::debug_log::debug_log_format(\n            \"ClassPrivateFunctionBroadcasted: {}\",\n            [\n                contract_class_id.to_field(),\n                artifact_metadata_hash,\n                utility_functions_artifact_tree_root,\n                function_data.selector.to_field(),\n                function_data.vk_hash,\n                function_data.metadata_hash,\n            ],\n        );\n        context.emit_contract_class_log(event.serialize_non_standard());\n    }\n\n    #[external(\"private\")]\n    fn broadcast_utility_function(\n        contract_class_id: ContractClassId,\n        artifact_metadata_hash: Field,\n        private_functions_artifact_tree_root: Field,\n        artifact_function_tree_sibling_path: [Field; ARTIFACT_FUNCTION_TREE_MAX_HEIGHT],\n        artifact_function_tree_leaf_index: Field,\n        function_data: InnerUtilityFunction,\n    ) {\n        // Safety: The bytecode loaded here is unconstrained, which is acceptable since:\n        // 1. Unlike public functions, we don't need execution guarantees for utility functions.\n        // 2. This broadcast simply provides convenient bytecode sharing vs offchain distribution.\n        let utility_bytecode: [Field; MAX_PACKED_BYTECODE_SIZE_PER_UTILITY_FUNCTION_IN_FIELDS] = unsafe {\n            capsules::load(\n                context.this_address(),\n                CONTRACT_CLASS_REGISTRY_BYTECODE_CAPSULE_SLOT,\n            )\n                .unwrap()\n        };\n        let event = ClassUtilityFunctionBroadcasted {\n            contract_class_id,\n            artifact_metadata_hash,\n            private_functions_artifact_tree_root,\n            artifact_function_tree_sibling_path,\n            artifact_function_tree_leaf_index,\n            function: UtilityFunction {\n                selector: function_data.selector,\n                metadata_hash: function_data.metadata_hash,\n                bytecode: utility_bytecode,\n            },\n        };\n        dep::aztec::oracle::debug_log::debug_log_format(\n            \"ClassUtilityFunctionBroadcasted: {}\",\n            [\n                contract_class_id.to_field(),\n                artifact_metadata_hash,\n                private_functions_artifact_tree_root,\n                function_data.selector.to_field(),\n                function_data.metadata_hash,\n            ],\n        );\n        context.emit_contract_class_log(event.serialize_non_standard());\n    }\n\n    #[external(\"private\")]\n    fn assert_class_id_is_published(contract_class_id: ContractClassId) {\n        context.push_nullifier_read_request(contract_class_id.to_field());\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "63": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "71": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        NULL_MSG_SENDER_CONTRACT_ADDRESS, PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    side_effect::Counted,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between an #[external(\"private\")] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[external(\"private\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[external(\"private\")] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[external(\"private\")] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[external(\"private\")] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<Counted<Field>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<Counted<Field>, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<Counted<NoteHash>, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Counted<Nullifier>, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub anchor_block_header: BlockHeader,\n\n    pub private_logs: BoundedVec<Counted<PrivateLogData>, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp = inputs.anchor_block_header.global_variables.timestamp\n            + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            anchor_block_header: inputs.anchor_block_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"null\" for the first\n    /// function call of every transaction.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `Option<AztecAddress>::none` for the first function call of\n    ///   the tx. No other _private_ function calls in the tx will have a `none`\n    ///   msg_sender, but _public_ function calls might (see the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.inputs.call_context.msg_sender;\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[external(\"private\")] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[external(\"private\")]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(Counted::new(note_hash, self.next_counter()));\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0 }.count(self.next_counter()));\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash }.count(\n            nullifier_counter,\n        ));\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some older block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_anchor_block_header(self) -> BlockHeader {\n        self.anchor_block_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[external(\"private\")] macro.\n    ///\n    /// # Arguments\n    /// * `serialized_return_values` - The serialized return values as a field array\n    ///\n    pub fn set_return_hash<let N: u32>(&mut self, serialized_return_values: [Field; N]) {\n        let return_hash = hash_args_array(serialized_return_values);\n        self.return_hash = return_hash;\n        execution_cache::store(serialized_return_values, return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[external(\"private\")] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            anchor_block_header: self.anchor_block_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardise on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact apprach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = Counted::new(note_hash, self.next_counter());\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = Counted::new(nullifier, self.next_counter());\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incooming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let nullifier = process_l1_to_l2_message(\n            self.anchor_block_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0 }\n            .count(counter);\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter };\n        self.private_logs.push(private_log.count(counter));\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        // However, it won't be able to check that we didn't add extra padding (trailing zeroes)\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L2 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        let call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - An array of fields to pass to the function.\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        self.public_teardown_call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            anchor_block_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "74": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "77": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "79": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args_array(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    dep::std::println(hash);\n    let hash_check = hash_calldata(input.as_slice());\n    assert(hash == hash_check);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n"
    }
  }
}
