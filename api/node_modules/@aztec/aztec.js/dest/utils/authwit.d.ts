import type { ChainInfo } from '@aztec/entrypoints/interfaces';
import { Fr } from '@aztec/foundation/fields';
import { type FunctionCall } from '@aztec/stdlib/abi';
import { AuthWitness } from '@aztec/stdlib/auth-witness';
import type { AztecAddress } from '@aztec/stdlib/aztec-address';
import type { TxProfileResult } from '@aztec/stdlib/tx';
import { ContractFunctionInteraction } from '../contract/contract_function_interaction.js';
import type { ProfileInteractionOptions, SendInteractionOptions, SimulateInteractionOptions, SimulationReturn } from '../contract/interaction_options.js';
import type { SentTx } from '../contract/sent_tx.js';
import type { Wallet } from '../wallet/index.js';
/** Intent with an inner hash */
export type IntentInnerHash = {
    /** The consumer   */
    consumer: AztecAddress;
    /** The action to approve */
    innerHash: Buffer<ArrayBuffer> | Fr;
};
/** Intent with a call */
export type CallIntent = {
    /** The caller to approve  */
    caller: AztecAddress;
    /** The call to approve */
    call: FunctionCall;
};
/** Intent with a ContractFunctionInteraction */
export type ContractFunctionInteractionCallIntent = {
    /** The caller to approve  */
    caller: AztecAddress;
    /** The action to approve */
    action: ContractFunctionInteraction;
};
/**
 * Compute an authentication witness message hash from an intent and metadata
 *
 * If using the `IntentInnerHash`, the consumer is the address that can "consume" the authwit, for token approvals it is the token contract itself.
 * The `innerHash` itself will be the message that a contract is allowed to execute.
 * At the point of "approval checking", the validating contract (account for private and registry for public) will be computing the message hash
 * (`H(consumer, chainid, version, inner_hash)`) where the all but the `inner_hash` is injected from the context (consumer = msg_sender),
 * and use it for the authentication check.
 * Therefore, any allowed `innerHash` will therefore also have information around where it can be spent (version, chainId) and who can spend it (consumer).
 *
 * If using the `CallIntent`, the caller is the address that is making the call, for a token approval from Alice to Bob, this would be Bob.
 * The action is then used along with the `caller` to compute the `innerHash` and the consumer.
 *
 *
 * @param intent - The intent to approve (consumer and innerHash or caller and action)
 *                 The consumer is the address that can "consume" the authwit, for token approvals it is the token contract itself.
 *                 The caller is the address that is making the call, for a token approval from Alice to Bob, this would be Bob.
 *                 The caller becomes part of the `inner_hash` and is dealt with entirely in application logic.
 * @param metadata - The metadata for the intent (chainId, version)
 * @returns The message hash for the action
 */
export declare const computeAuthWitMessageHash: (intent: IntentInnerHash | CallIntent | ContractFunctionInteractionCallIntent, metadata: ChainInfo) => Promise<Fr>;
/**
 * Compute an authentication witness message hash from an intent and metadata. This is just
 * a wrapper around computeAuthwitMessageHash that allows receiving an already computed messageHash as input
 * @param messageHashOrIntent - The precomputed messageHash or intent to approve (consumer and innerHash or caller and call/action)
 * @param metadata - The metadata for the intent (chainId, version)
 * @returns The message hash for the intent
 */
export declare function getMessageHashFromIntent(messageHashOrIntent: Fr | Buffer | IntentInnerHash | CallIntent | ContractFunctionInteractionCallIntent, chainInfo: ChainInfo): Promise<Fr>;
/**
 * Computes the inner authwitness hash for either a function call or an action, for it to later be combined with the metadata
 * required for the outer hash and eventually the full AuthWitness.
 * @param caller - Who is going to be calling the function
 * @param action - The action to compute the inner hash from
 * @returns The inner hash for the action
 **/
export declare const computeInnerAuthWitHashFromAction: (caller: AztecAddress, action: FunctionCall | ContractFunctionInteraction) => Promise<Fr>;
/**
 * Lookup the validity of an authwit in private and public contexts.
 *
 * Uses the chain id and version of the wallet.
 *
 * @param wallet - The wallet use to simulate and read the public data
 * @param onBehalfOf - The address of the "approver"
 * @param intent - The consumer and inner hash or the caller and action to lookup
 * @param witness - The computed authentication witness to check
 * @returns - A struct containing the validity of the authwit in private and public contexts.
 */
export declare function lookupValidity(wallet: Wallet, onBehalfOf: AztecAddress, intent: IntentInnerHash | CallIntent | ContractFunctionInteractionCallIntent, witness: AuthWitness): Promise<{
    /** boolean flag indicating if the authwit is valid in private context */
    isValidInPrivate: boolean;
    /** boolean flag indicating if the authwit is valid in public context */
    isValidInPublic: boolean;
}>;
/**
 * Convenience class designed to wrap the very common interaction of setting a public authwit in the AuthRegistry contract
 */
export declare class SetPublicAuthwitContractInteraction extends ContractFunctionInteraction {
    private from;
    private constructor();
    static create(wallet: Wallet, from: AztecAddress, messageHashOrIntent: Fr | Buffer | IntentInnerHash | CallIntent | ContractFunctionInteractionCallIntent, authorized: boolean): Promise<SetPublicAuthwitContractInteraction>;
    /**
     * Overrides the simulate method, adding the sender of the authwit (authorizer) as from
     * and preventing misuse
     * @param options - An optional object containing additional configuration for the transaction.
     * @returns The result of the transaction as returned by the contract function.
     */
    simulate<T extends SimulateInteractionOptions>(options: Omit<T, 'from'>): Promise<SimulationReturn<T['includeMetadata']>>;
    /**
     * Overrides the profile method, adding the sender of the authwit (authorizer) as from
     * and preventing misuse
     * @param options - Same options as `simulate`, plus profiling method
     * @returns An object containing the function return value and profile result.
     */
    profile(options?: Omit<ProfileInteractionOptions, 'from'>): Promise<TxProfileResult>;
    /**
     * Overrides the send method, adding the sender of the authwit (authorizer) as from
     * and preventing misuse
     * @param options - An optional object containing 'fee' options information
     * @returns A SentTx instance for tracking the transaction status and information.
     */
    send(options?: Omit<SendInteractionOptions, 'from'>): SentTx;
    private static getSetAuthorizedAbi;
}
//# sourceMappingURL=authwit.d.ts.map