import { ExecutionPayload } from '@aztec/entrypoints/payload';
import { type ContractArtifact, type FunctionArtifact } from '@aztec/stdlib/abi';
import { AztecAddress } from '@aztec/stdlib/aztec-address';
import type { GasSettings } from '@aztec/stdlib/gas';
import type { FeePaymentMethod } from '../fee/fee_payment_method.js';
import type { Wallet } from './index.js';
/**
 * Fee payment method that allows an account contract to pay for its own deployment
 * It works by rerouting the provided fee payment method through the account's entrypoint,
 * which sets itself as fee payer. If no payment method is provided, it is assumed the
 * account will pay with its own fee juice balance.
 *
 * Usually, in order to pay fees it is necessary to obtain an ExecutionPayload that encodes the necessary information
 * that is sent to the user's account entrypoint, that has plumbing to handle it.
 * If there's no account contract yet (it's being deployed) a MultiCallContract is used, which doesn't have a concept of fees or
 * how to handle this payload.
 * HOWEVER, the account contract's entrypoint does, so this method reshapes that fee payload into a call to the account contract entrypoint
 * being deployed with the original fee payload.
 *
 * This class can be seen in action in DeployAccountMethod.ts#getSelfPaymentMethod
 */
export declare class AccountEntrypointMetaPaymentMethod implements FeePaymentMethod {
    private wallet;
    private artifact;
    private feePaymentNameOrArtifact;
    private accountAddress;
    private paymentMethod?;
    constructor(wallet: Wallet, artifact: ContractArtifact, feePaymentNameOrArtifact: string | FunctionArtifact, accountAddress: AztecAddress, paymentMethod?: FeePaymentMethod | undefined);
    getAsset(): Promise<AztecAddress>;
    getExecutionPayload(): Promise<ExecutionPayload>;
    getFeePayer(): Promise<AztecAddress>;
    getGasSettings(): GasSettings | undefined;
}
//# sourceMappingURL=account_entrypoint_meta_payment_method.d.ts.map