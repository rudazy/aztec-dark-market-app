import { AbiTypeSchema, ContractArtifactSchema, FunctionAbiSchema, FunctionType } from '@aztec/stdlib/abi';
import { AuthWitness } from '@aztec/stdlib/auth-witness';
import { ContractClassWithIdSchema, ContractInstanceWithAddressSchema } from '@aztec/stdlib/contract';
import { Gas } from '@aztec/stdlib/gas';
import { PublicKeys } from '@aztec/stdlib/keys';
import { AbiDecodedSchema, optional, schemas } from '@aztec/stdlib/schemas';
import { Capsule, HashedValues, TxHash, TxProfileResult, TxReceipt, TxSimulationResult, UtilitySimulationResult } from '@aztec/stdlib/tx';
import { z } from 'zod';
export const ContractInstantiationDataSchema = z.object({
    constructorArtifact: optional(z.union([
        FunctionAbiSchema,
        z.string()
    ])),
    constructorArgs: optional(z.array(z.any())),
    skipArgsDecoding: optional(z.boolean()),
    salt: schemas.Fr,
    publicKeys: optional(PublicKeys.schema),
    deployer: optional(schemas.AztecAddress)
});
export const FunctionCallSchema = z.object({
    name: z.string(),
    to: schemas.AztecAddress,
    selector: schemas.FunctionSelector,
    type: z.nativeEnum(FunctionType),
    isStatic: z.boolean(),
    hideMsgSender: z.boolean(),
    args: z.array(schemas.Fr),
    returnTypes: z.array(AbiTypeSchema)
});
export const ExecutionPayloadSchema = z.object({
    calls: z.array(FunctionCallSchema),
    authWitnesses: z.array(AuthWitness.schema),
    capsules: z.array(Capsule.schema),
    extraHashedArgs: z.array(HashedValues.schema)
});
export const UserFeeOptionsSchema = z.object({
    gasSettings: optional(z.object({
        gasLimits: optional(Gas.schema),
        teardownGasLimits: optional(Gas.schema),
        maxFeePerGas: optional(z.object({
            feePerDaGas: schemas.BigInt,
            feePerL2Gas: schemas.BigInt
        })),
        maxPriorityFeePerGas: optional(z.object({
            feePerDaGas: schemas.BigInt,
            feePerL2Gas: schemas.BigInt
        }))
    })),
    embeddedPaymentMethodFeePayer: optional(schemas.AztecAddress)
});
export const WalletSimulationFeeOptionSchema = UserFeeOptionsSchema.extend({
    estimatedGasPadding: optional(z.number()),
    estimateGas: optional(z.boolean())
});
export const SendOptionsSchema = z.object({
    from: schemas.AztecAddress,
    authWitnesses: optional(z.array(AuthWitness.schema)),
    capsules: optional(z.array(Capsule.schema)),
    fee: optional(UserFeeOptionsSchema)
});
export const SimulateOptionsSchema = z.object({
    from: schemas.AztecAddress,
    authWitnesses: optional(z.array(AuthWitness.schema)),
    capsules: optional(z.array(Capsule.schema)),
    fee: optional(WalletSimulationFeeOptionSchema),
    skipTxValidation: optional(z.boolean()),
    skipFeeEnforcement: optional(z.boolean()),
    includeMetadata: optional(z.boolean())
});
export const ProfileOptionsSchema = SimulateOptionsSchema.extend({
    profileMode: z.enum([
        'gates',
        'execution-steps',
        'full'
    ]),
    skipProofGeneration: optional(z.boolean())
});
export const InstanceDataSchema = z.union([
    schemas.AztecAddress,
    ContractInstanceWithAddressSchema,
    ContractInstantiationDataSchema,
    z.object({
        instance: ContractInstanceWithAddressSchema,
        artifact: ContractArtifactSchema
    })
]);
export const MessageHashOrIntentSchema = z.union([
    schemas.Fr,
    schemas.Buffer,
    z.object({
        consumer: schemas.AztecAddress,
        innerHash: z.union([
            schemas.Buffer,
            schemas.Fr
        ])
    }),
    z.object({
        caller: schemas.AztecAddress,
        call: FunctionCallSchema
    })
]);
export const BatchedMethodSchema = z.union([
    z.object({
        name: z.literal('registerSender'),
        args: z.tuple([
            schemas.AztecAddress,
            optional(z.string())
        ])
    }),
    z.object({
        name: z.literal('registerContract'),
        args: z.tuple([
            InstanceDataSchema,
            optional(ContractArtifactSchema),
            optional(schemas.Fr)
        ])
    }),
    z.object({
        name: z.literal('sendTx'),
        args: z.tuple([
            ExecutionPayloadSchema,
            SendOptionsSchema
        ])
    }),
    z.object({
        name: z.literal('simulateUtility'),
        args: z.tuple([
            z.string(),
            z.array(z.any()),
            schemas.AztecAddress,
            optional(z.array(AuthWitness.schema))
        ])
    })
]);
export const ContractMetadataSchema = z.object({
    contractInstance: z.union([
        ContractInstanceWithAddressSchema,
        z.undefined()
    ]),
    isContractInitialized: z.boolean(),
    isContractPublished: z.boolean()
});
export const ContractClassMetadataSchema = z.object({
    contractClass: z.union([
        ContractClassWithIdSchema,
        z.undefined()
    ]),
    isContractClassPubliclyRegistered: z.boolean(),
    artifact: z.union([
        ContractArtifactSchema,
        z.undefined()
    ])
});
export const EventMetadataDefinitionSchema = z.object({
    eventSelector: schemas.EventSelector,
    abiType: AbiTypeSchema,
    fieldNames: z.array(z.string())
});
export const WalletSchema = {
    getChainInfo: z.function().args().returns(z.object({
        chainId: schemas.Fr,
        version: schemas.Fr
    })),
    getContractClassMetadata: z.function().args(schemas.Fr, optional(z.boolean())).returns(ContractClassMetadataSchema),
    getContractMetadata: z.function().args(schemas.AztecAddress).returns(ContractMetadataSchema),
    getTxReceipt: z.function().args(TxHash.schema).returns(TxReceipt.schema),
    getPrivateEvents: z.function().args(schemas.AztecAddress, EventMetadataDefinitionSchema, z.number(), z.number(), z.array(schemas.AztecAddress)).returns(z.array(AbiDecodedSchema)),
    registerSender: z.function().args(schemas.AztecAddress, optional(z.string())).returns(schemas.AztecAddress),
    getAddressBook: z.function().args().returns(z.array(z.object({
        alias: z.string(),
        item: schemas.AztecAddress
    }))),
    getAccounts: z.function().args().returns(z.array(z.object({
        alias: z.string(),
        item: schemas.AztecAddress
    }))),
    registerContract: z.function().args(InstanceDataSchema, optional(ContractArtifactSchema), optional(schemas.Fr)).returns(ContractInstanceWithAddressSchema),
    simulateTx: z.function().args(ExecutionPayloadSchema, SimulateOptionsSchema).returns(TxSimulationResult.schema),
    simulateUtility: z.function().args(z.string(), z.array(z.any()), schemas.AztecAddress, optional(z.array(AuthWitness.schema))).returns(UtilitySimulationResult.schema),
    profileTx: z.function().args(ExecutionPayloadSchema, ProfileOptionsSchema).returns(TxProfileResult.schema),
    sendTx: z.function().args(ExecutionPayloadSchema, SendOptionsSchema).returns(TxHash.schema),
    createAuthWit: z.function().args(schemas.AztecAddress, MessageHashOrIntentSchema).returns(AuthWitness.schema),
    // @ts-expect-error - ApiSchemaFor cannot properly type generic methods with readonly arrays
    batch: z.function().args(z.array(BatchedMethodSchema)).returns(z.array(z.discriminatedUnion('name', [
        z.object({
            name: z.literal('registerSender'),
            result: schemas.AztecAddress
        }),
        z.object({
            name: z.literal('registerContract'),
            result: ContractInstanceWithAddressSchema
        }),
        z.object({
            name: z.literal('sendTx'),
            result: TxHash.schema
        }),
        z.object({
            name: z.literal('simulateUtility'),
            result: UtilitySimulationResult.schema
        })
    ])))
};
