import { Fr } from '@aztec/foundation/fields';
import { CompleteAddress, getContractInstanceFromInstantiationParams } from '@aztec/stdlib/contract';
import { deriveKeys } from '@aztec/stdlib/keys';
import { AccountWithSecretKey } from '../account/account_with_secret_key.js';
import { Contract } from '../contract/contract.js';
import { DeployAccountMethod } from './deploy_account_method.js';
/**
 * Manages a user account. Provides methods for calculating the account's address and other related data,
 * plus a helper to return a preconfigured deploy method.
 */ export class AccountManager {
    wallet;
    secretKey;
    accountContract;
    instance;
    salt;
    constructor(wallet, secretKey, accountContract, instance, /**
     * Contract instantiation salt for the account contract
     */ salt){
        this.wallet = wallet;
        this.secretKey = secretKey;
        this.accountContract = accountContract;
        this.instance = instance;
        this.salt = salt;
    }
    static async create(wallet, secretKey, accountContract, salt) {
        const { publicKeys } = await deriveKeys(secretKey);
        salt = salt !== undefined ? new Fr(salt) : Fr.random();
        const { constructorName, constructorArgs } = await accountContract.getInitializationFunctionAndArgs() ?? {
            constructorName: undefined,
            constructorArgs: undefined
        };
        const artifact = await accountContract.getContractArtifact();
        const instance = await getContractInstanceFromInstantiationParams(artifact, {
            constructorArtifact: constructorName,
            constructorArgs,
            salt: salt,
            publicKeys
        });
        return new AccountManager(wallet, secretKey, accountContract, instance, salt);
    }
    getPublicKeys() {
        return this.instance.publicKeys;
    }
    getPublicKeysHash() {
        return this.getPublicKeys().hash();
    }
    /**
   * Returns the entrypoint for this account as defined by its account contract.
   * @returns An entrypoint.
   */ async getAccountInterface() {
        const chainInfo = await this.wallet.getChainInfo();
        const completeAddress = await this.getCompleteAddress();
        return this.accountContract.getInterface(completeAddress, chainInfo);
    }
    /**
   * Gets the calculated complete address associated with this account.
   * Does not require the account to have been published for public execution.
   * @returns The address, partial address, and encryption public key.
   */ getCompleteAddress() {
        return CompleteAddress.fromSecretKeyAndInstance(this.secretKey, this.instance);
    }
    /**
   * Returns the secret key used to derive the rest of the privacy keys for this contract
   */ getSecretKey() {
        return this.secretKey;
    }
    get address() {
        return this.instance.address;
    }
    /**
   * Returns the contract instance definition associated with this account.
   * Does not require the account to have been published for public execution.
   * @returns ContractInstance instance.
   */ getInstance() {
        return this.instance;
    }
    /**
   * Returns a Wallet instance associated with this account. Use it to create Contract
   * instances to be interacted with from this account.
   * @returns A Wallet instance.
   */ async getAccount() {
        const accountInterface = await this.getAccountInterface();
        return new AccountWithSecretKey(accountInterface, this.secretKey, this.salt);
    }
    /**
   * Returns the account contract that backs this account.
   * @returns The account contract
   */ getAccountContract() {
        return this.accountContract;
    }
    /**
   * Returns a preconfigured deploy method that contains all the necessary function
   * calls to deploy the account contract.
   */ async getDeployMethod() {
        const artifact = await this.accountContract.getContractArtifact();
        if (!await this.hasInitializer()) {
            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/15576):
            // there should be a path which enables an account contract's class & instance to be published,
            // even if the account contract doesn't have an initializer function. This should not throw.
            throw new Error(`Account contract ${artifact.name} does not have an initializer function to call.`);
        }
        const { constructorName, constructorArgs } = await this.accountContract.getInitializationFunctionAndArgs() ?? {
            constructorName: undefined,
            constructorArgs: undefined
        };
        return new DeployAccountMethod(this.getPublicKeys(), this.wallet, artifact, (address)=>Contract.at(address, artifact, this.wallet), new Fr(this.salt), constructorArgs, constructorName);
    }
    /**
   * Returns whether this account contract has an initializer function.
   */ async hasInitializer() {
        return await this.accountContract.getInitializationFunctionAndArgs() !== undefined;
    }
}
