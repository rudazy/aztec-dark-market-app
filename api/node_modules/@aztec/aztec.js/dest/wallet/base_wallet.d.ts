import { AccountFeePaymentMethodOptions } from '@aztec/entrypoints/account';
import type { ChainInfo } from '@aztec/entrypoints/interfaces';
import { ExecutionPayload } from '@aztec/entrypoints/payload';
import { Fr } from '@aztec/foundation/fields';
import type { ContractArtifact, EventMetadataDefinition } from '@aztec/stdlib/abi';
import type { AuthWitness } from '@aztec/stdlib/auth-witness';
import type { AztecAddress } from '@aztec/stdlib/aztec-address';
import { type ContractClassMetadata, type ContractInstanceWithAddress, type ContractInstantiationData, type ContractMetadata } from '@aztec/stdlib/contract';
import { GasSettings } from '@aztec/stdlib/gas';
import type { AztecNode } from '@aztec/stdlib/interfaces/client';
import type { TxExecutionRequest, TxHash, TxProfileResult, TxReceipt, TxSimulationResult, UtilitySimulationResult } from '@aztec/stdlib/tx';
import type { Account } from '../account/account.js';
import type { FeePaymentMethod } from '../fee/fee_payment_method.js';
import type { CallIntent, IntentInnerHash } from '../utils/authwit.js';
import type { Aliased, BatchResults, BatchableMethods, BatchedMethod, ContractInstanceAndArtifact, ProfileOptions, SendOptions, SimulateOptions, UserFeeOptions, Wallet } from './wallet.js';
/**
 * Options to configure fee payment for a transaction
 */
export type FeeOptions = {
    /**
     * A wallet-provided fallback fee payment method that is used only if the transaction that is being constructed
     * doesn't already include one
     */
    walletFeePaymentMethod?: FeePaymentMethod;
    /** Configuration options for the account to properly handle the selected fee payment method */
    accountFeePaymentMethodOptions: AccountFeePaymentMethodOptions;
    /** The gas settings to use for the transaction */
    gasSettings: GasSettings;
};
/**
 * A base class for Wallet implementations
 */
export declare abstract class BaseWallet implements Wallet {
    protected readonly pxe: any;
    protected readonly aztecNode: AztecNode;
    protected log: import("@aztec/foundation/log").Logger;
    protected baseFeePadding: number;
    protected cancellableTransactions: boolean;
    protected constructor(pxe: any, aztecNode: AztecNode);
    protected abstract getAccountFromAddress(address: AztecAddress): Promise<Account>;
    abstract getAccounts(): Promise<Aliased<AztecAddress>[]>;
    /**
     * Returns the list of aliased contacts associated with the wallet.
     * This base implementation directly returns PXE's senders, but note that in general contacts are a superset of senders.
     *  - Senders: Addresses we check during synching in case they sent us notes,
     *  - Contacts: more general concept akin to a phone's contact list.
     * @returns The aliased collection of AztecAddresses that form this wallet's address book
     */
    getAddressBook(): Promise<Aliased<AztecAddress>[]>;
    getChainInfo(): Promise<ChainInfo>;
    protected createTxExecutionRequestFromPayloadAndFee(executionPayload: ExecutionPayload, from: AztecAddress, feeOptions: FeeOptions): Promise<TxExecutionRequest>;
    createAuthWit(from: AztecAddress, messageHashOrIntent: Fr | Buffer | IntentInnerHash | CallIntent): Promise<AuthWitness>;
    batch<const T extends readonly BatchedMethod<keyof BatchableMethods>[]>(methods: T): Promise<BatchResults<T>>;
    /**
     * Returns default values for the transaction fee options
     * if they were omitted by the user.
     * @param from - The address where the transaction is being sent from
     * @param userFeeOptions - User-provided fee options, which might be incomplete
     * @returns - Populated fee options that can be used to create a transaction execution request
     */
    protected getDefaultFeeOptions(from: AztecAddress, userFeeOptions?: UserFeeOptions): Promise<FeeOptions>;
    /**
     * Returns unreasonably high gas limits in order to execute a simulation
     * with the goal of estimating its gas cost. It will otherwise try to respect
     * the user-specified fee options, filling the gaps with default values as needed.
     * @param from - The address where the transaction is being sent from
     * @param userFeeOptions - User-provided fee options to use as a basis for the fully populated `FeeOptions` type.
     */
    protected getFeeOptionsForGasEstimation(from: AztecAddress, userFeeOptions?: UserFeeOptions): Promise<{
        gasSettings: GasSettings;
        /**
         * A wallet-provided fallback fee payment method that is used only if the transaction that is being constructed
         * doesn't already include one
         */
        walletFeePaymentMethod?: FeePaymentMethod;
        /** Configuration options for the account to properly handle the selected fee payment method */
        accountFeePaymentMethodOptions: AccountFeePaymentMethodOptions;
    }>;
    registerSender(address: AztecAddress, _alias?: string): Promise<AztecAddress>;
    registerContract(instanceData: AztecAddress | ContractInstanceWithAddress | ContractInstantiationData | ContractInstanceAndArtifact, artifact?: ContractArtifact, secretKey?: Fr): Promise<ContractInstanceWithAddress>;
    simulateTx(executionPayload: ExecutionPayload, opts: SimulateOptions): Promise<TxSimulationResult>;
    profileTx(executionPayload: ExecutionPayload, opts: ProfileOptions): Promise<TxProfileResult>;
    sendTx(executionPayload: ExecutionPayload, opts: SendOptions): Promise<TxHash>;
    protected contextualizeError(err: Error, ...context: string[]): Error;
    simulateUtility(functionName: string, args: any[], to: AztecAddress, authwits?: AuthWitness[], from?: AztecAddress): Promise<UtilitySimulationResult>;
    getContractClassMetadata(id: Fr, includeArtifact?: boolean): Promise<ContractClassMetadata>;
    getContractMetadata(address: AztecAddress): Promise<ContractMetadata>;
    getTxReceipt(txHash: TxHash): Promise<TxReceipt>;
    getPrivateEvents<T>(contractAddress: AztecAddress, event: EventMetadataDefinition, from: number, limit: number, recipients?: AztecAddress[]): Promise<T[]>;
}
//# sourceMappingURL=base_wallet.d.ts.map