import { ExecutionPayload } from '@aztec/entrypoints/payload';
import { type FunctionAbi, FunctionSelector, FunctionType } from '@aztec/stdlib/abi';
import type { AuthWitness } from '@aztec/stdlib/auth-witness';
import { AztecAddress } from '@aztec/stdlib/aztec-address';
import { type Capsule, type HashedValues, type TxProfileResult } from '@aztec/stdlib/tx';
import type { Wallet } from '../wallet/wallet.js';
import { BaseContractInteraction } from './base_contract_interaction.js';
import { type ProfileInteractionOptions, type RequestInteractionOptions, type SimulateInteractionOptions, type SimulationReturn } from './interaction_options.js';
/**
 * This is the class that is returned when calling e.g. `contract.methods.myMethod(arg0, arg1)`.
 * It contains available interactions one can call on a method, including view.
 */
export declare class ContractFunctionInteraction extends BaseContractInteraction {
    protected contractAddress: AztecAddress;
    protected functionDao: FunctionAbi;
    protected args: any[];
    private extraHashedArgs;
    constructor(wallet: Wallet, contractAddress: AztecAddress, functionDao: FunctionAbi, args: any[], authWitnesses?: AuthWitness[], capsules?: Capsule[], extraHashedArgs?: HashedValues[]);
    /**
     * Returns the encoded function call wrapped by this interaction
     * Useful when generating authwits
     * @returns An encoded function call
     */
    getFunctionCall(): Promise<{
        name: string;
        args: import("@aztec/foundation/schemas").Fr[];
        selector: FunctionSelector;
        type: FunctionType;
        to: AztecAddress;
        isStatic: boolean;
        hideMsgSender: boolean; /** Only set to `true` for enqueued public function calls */
        returnTypes: import("@aztec/stdlib/abi").AbiType[];
    }>;
    /**
     * Returns the execution payload that allows this operation to happen on chain.
     * @param options - Configuration options.
     * @returns The execution payload for this operation
     */
    request(options?: RequestInteractionOptions): Promise<ExecutionPayload>;
    /**
     * Simulate a transaction and get information from its execution.
     * Differs from prove in a few important ways:
     * 1. It returns the values of the function execution, plus additional metadata if requested
     * 2. It supports `utility`, `private` and `public` functions
     *
     * @param options - An optional object containing additional configuration for the simulation.
     * @returns Depending on the simulation options, this method directly returns the result value of the executed
     * function or a rich object containing extra metadata, such as estimated gas costs (if requested via options),
     * execution statistics and emitted offchain effects
     */
    simulate<T extends SimulateInteractionOptions>(options: T): Promise<SimulationReturn<Exclude<T['fee'], undefined>['estimateGas']>>;
    simulate<T extends SimulateInteractionOptions>(options: T): Promise<SimulationReturn<T['includeMetadata']>>;
    /**
     * Simulate a transaction and profile the gate count for each function in the transaction.
     * @param options - Same options as `simulate`, plus profiling method
     *
     * @returns An object containing the function return value and profile result.
     */
    profile(options: ProfileInteractionOptions): Promise<TxProfileResult>;
    /**
     * Augments this ContractFunctionInteraction with additional metadata, such as authWitnesses, capsules, and extraHashedArgs.
     * This is useful when creating a "batteries included" interaction, such as registering a contract class with its associated
     * capsule instead of having the user provide them externally.
     * @param options - An object containing the metadata to add to the interaction
     * @returns A new ContractFunctionInteraction with the added metadata, but calling the same original function in the same manner
     */
    with({ authWitnesses, capsules, extraHashedArgs, }: {
        /** The authWitnesses to add to the interaction */
        authWitnesses?: AuthWitness[];
        /** The capsules to add to the interaction */
        capsules?: Capsule[];
        /** The extra hashed args to add to the interaction */
        extraHashedArgs?: HashedValues[];
    }): ContractFunctionInteraction;
}
//# sourceMappingURL=contract_function_interaction.d.ts.map