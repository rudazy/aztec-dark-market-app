import { ExecutionPayload } from '@aztec/entrypoints/payload';
import { Fr } from '@aztec/foundation/fields';
import { type ContractArtifact, type FunctionArtifact } from '@aztec/stdlib/abi';
import type { AuthWitness } from '@aztec/stdlib/auth-witness';
import { AztecAddress } from '@aztec/stdlib/aztec-address';
import { type ContractInstanceWithAddress } from '@aztec/stdlib/contract';
import type { PublicKeys } from '@aztec/stdlib/keys';
import { type Capsule, type TxProfileResult } from '@aztec/stdlib/tx';
import type { Wallet } from '../wallet/wallet.js';
import { BaseContractInteraction } from './base_contract_interaction.js';
import type { Contract } from './contract.js';
import type { ContractBase } from './contract_base.js';
import { DeploySentTx } from './deploy_sent_tx.js';
import { type ProfileInteractionOptions, type RequestInteractionOptions, type SendInteractionOptions, type SimulationInteractionFeeOptions, type SimulationReturn } from './interaction_options.js';
/**
 * Options for deploying a contract on the Aztec network.
 * Allows specifying a contract address salt and different options to tweak contract publication
 * and initialization
 */
export type RequestDeployOptions = RequestInteractionOptions & {
    /** An optional salt value used to deterministically calculate the contract address. */
    contractAddressSalt?: Fr;
    /**
     * Deployer address that will be used for the deployed contract's address computation.
     * If set to 0, the sender's address won't be mixed in
     */
    deployer?: AztecAddress;
    /** Skip contract class publication. */
    skipClassPublication?: boolean;
    /** Skip publication, instead just privately initialize the contract. */
    skipInstancePublication?: boolean;
    /** Skip contract initialization. */
    skipInitialization?: boolean;
};
/**
 * Extends the deployment options with the required parameters to send the transaction
 */
export type DeployOptions = Omit<RequestDeployOptions, 'deployer'> & {
    /**
     * Set to true to *not* include the sender in the address computation. This option
     * is mutually exclusive with "deployer"
     */
    universalDeploy?: boolean;
} & Pick<SendInteractionOptions, 'from' | 'fee'>;
/**
 * Options for simulating the deployment of a contract
 * Allows skipping certain validations and computing gas estimations
 */
export type SimulateDeployOptions = Omit<DeployOptions, 'fee'> & {
    /** The fee options for the transaction. */
    fee?: SimulationInteractionFeeOptions;
    /** Simulate without checking for the validity of the resulting transaction,
     * e.g. whether it emits any existing nullifiers. */
    skipTxValidation?: boolean;
    /** Whether to ensure the fee payer is not empty and has enough balance to pay for the fee. */
    skipFeeEnforcement?: boolean;
    /** Whether to include metadata such as offchain effects and performance statistics
     * (e.g. timing information of the different circuits and oracles) in
     * the simulation result, instead of just the return value of the function */
    includeMetadata?: boolean;
};
/**
 * Contract interaction for deployment.
 * Handles class publication, instance publication, and initialization of the contract.
 *
 * Note that for some contracts, a tx is not required as part of its "creation":
 * If there are no public functions, and if there are no initialization functions,
 * then technically the contract has already been "created", and all of the contract's
 * functions (private and utility) can be interacted-with immediately, without any
 * "deployment tx".
 *
 * Extends the BaseContractInteraction class.
 */
export declare class DeployMethod<TContract extends ContractBase = Contract> extends BaseContractInteraction {
    private publicKeys;
    protected artifact: ContractArtifact;
    protected postDeployCtor: (address: AztecAddress, wallet: Wallet) => Promise<TContract>;
    private args;
    /** The contract instance to be deployed. */
    private instance?;
    /** Constructor function to call. */
    private constructorArtifact;
    constructor(publicKeys: PublicKeys, wallet: Wallet, artifact: ContractArtifact, postDeployCtor: (address: AztecAddress, wallet: Wallet) => Promise<TContract>, args?: any[], constructorNameOrArtifact?: string | FunctionArtifact, authWitnesses?: AuthWitness[], capsules?: Capsule[]);
    /**
     * Returns the execution payload that allows this operation to happen on chain.
     * @param options - Configuration options.
     * @returns The execution payload for this operation
     */
    request(options?: RequestDeployOptions): Promise<ExecutionPayload>;
    convertDeployOptionsToRequestOptions(options: DeployOptions): RequestDeployOptions;
    /**
     * Adds this contract to the wallet and returns the Contract object.
     * @param options - Deployment options.
     */
    register(options?: RequestDeployOptions): Promise<TContract>;
    /**
     * Returns an execution payload for:
     * - publication of the contract class and
     * - publication of the contract instance to enable public execution
     * depending on the provided options.
     * @param options - Contract creation options.
     * @returns An execution payload with potentially calls (and bytecode capsule) to the class registry and instance registry.
     */
    protected getPublicationExecutionPayload(options?: RequestDeployOptions): Promise<ExecutionPayload>;
    /**
     * Returns the calls necessary to initialize the contract.
     * @param options - Deployment options.
     * @returns - An array of function calls.
     */
    protected getInitializationExecutionPayload(options?: RequestDeployOptions): Promise<ExecutionPayload>;
    /**
     * Send a contract deployment transaction (initialize and/or publish) using the provided options.
     * This function extends the 'send' method from the ContractFunctionInteraction class,
     * allowing us to send a transaction specifically for contract deployment.
     *
     * @param options - An object containing various deployment options such as contractAddressSalt and from.
     * @returns A SentTx object that returns the receipt and the deployed contract instance.
     */
    send(options: DeployOptions): DeploySentTx<TContract>;
    /**
     * Builds the contract instance and returns it.
     *
     * @param options - An object containing various initialization and publication options.
     * @returns An instance object.
     */
    getInstance(options?: RequestDeployOptions): Promise<ContractInstanceWithAddress>;
    /**
     * Simulate the deployment
     *
     * @param options - An optional object containing additional configuration for the simulation.
     * @returns A simulation result object containing metadata of the execution, including gas
     * estimations (if requested via options), execution statistics and emitted offchain effects
     */
    simulate(options: SimulateDeployOptions): Promise<SimulationReturn<true>>;
    /**
     * Simulate a deployment and profile the gate count for each function in the transaction.
     * @param options - Same options as `send`, plus extra profiling options.
     *
     * @returns An object containing the function return value and profile result.
     */
    profile(options: DeployOptions & ProfileInteractionOptions): Promise<TxProfileResult>;
    /** Return this deployment address. */
    get address(): AztecAddress | undefined;
    /** Returns the partial address for this deployment. */
    get partialAddress(): Promise<Fr> | undefined;
    /**
     * Augments this DeployMethod with additional metadata, such as authWitnesses and capsules.
     * @param options - An object containing the metadata to add to the interaction
     * @returns A new DeployMethod with the added metadata, but calling the same original function in the same manner
     */
    with({ authWitnesses, capsules, }: {
        /** The authWitnesses to add to the deployment */
        authWitnesses?: AuthWitness[];
        /** The capsules to add to the deployment */
        capsules?: Capsule[];
    }): DeployMethod;
}
//# sourceMappingURL=deploy_method.d.ts.map