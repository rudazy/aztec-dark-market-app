import { FIELDS_PER_BLOB } from '@aztec/constants';
import { BLS12Fr, Fr } from '@aztec/foundation/fields';
import { BufferReader } from '@aztec/foundation/serialize';
import type { BlobJson } from './interface.js';
export { FIELDS_PER_BLOB };
/**
 * A class to create, manage, and prove EVM blobs.
 *
 * @dev Note: All methods in this class do not check the encoding of the given data. It's the responsibility of other
 * components to ensure that the blob data (which might spread across multiple blobs) was created following the protocol
 * and is correctly encoded.
 */
export declare class Blob {
    /**
     * The data to be broadcast on L1 in bytes form.
     */
    readonly data: Uint8Array;
    /**
     * Commitment to the blob data. Used in compressed BLS12 point format (48 bytes).
     */
    readonly commitment: Buffer;
    constructor(
    /**
     * The data to be broadcast on L1 in bytes form.
     */
    data: Uint8Array, 
    /**
     * Commitment to the blob data. Used in compressed BLS12 point format (48 bytes).
     */
    commitment: Buffer);
    /**
     * Create a Blob from a buffer.
     * @param data - The buffer of the Blob.
     * @returns A Blob created from the buffer.
     *
     * @throws If data does not match the expected length (BYTES_PER_BLOB).
     */
    static fromBlobBuffer(data: Uint8Array): Blob;
    /**
     * Create a Blob from an array of fields.
     *
     * @dev This method pads 0s to the data, extending it to the size of a full blob.
     *
     * @param fields - The array of fields to create the Blob from.
     * @returns A Blob created from the array of fields.
     */
    static fromFields(fields: Fr[]): Blob;
    /**
     * Get the fields from the blob data.
     *
     * @dev WARNING: this method returns all fields
     *
     * @returns The fields from the blob.
     */
    toFields(): Fr[];
    /**
     * Create a Blob from a JSON object.
     *
     * Blobs will be in this form when requested from the blob sink, or from
     * the beacon chain via `getBlobSidecars`
     * https://ethereum.github.io/beacon-APIs/?urls.primaryName=dev#/Beacon/getBlobSidecars
     *
     * @param json - The JSON object to create the Blob from.
     * @returns A Blob created from the JSON object.
     */
    static fromJson(json: BlobJson): Blob;
    /**
     * Get the JSON representation of the blob.
     *
     * @param index - optional - The index of the blob in the block.
     * @returns The JSON representation of the blob.
     */
    toJson(index: number): BlobJson;
    getEthVersionedBlobHash(): Buffer;
    /**
     * Challenge point z (= H(H(tx_effects), kzgCommitment)).
     * Used such that p(z) = y for a single blob, used as z_i in batching (see ./blob_batching.ts).
     */
    computeChallengeZ(blobFieldsHash: Fr): Promise<Fr>;
    /**
     * Evaluate the blob at a given challenge and return the evaluation and KZG proof.
     *
     * @param challengeZ - The challenge z at which to evaluate the blob.
     * @param verifyProof - Whether to verify the KZG proof.
     *
     * @returns
     *  y: BLS12Fr -  Evaluation y = p(z), where p() is the blob polynomial. BLS12 field element, rep. as BigNum in nr, bigint in ts.
     *  proof: Buffer - KZG opening proof for y = p(z). The commitment to quotient polynomial Q, used in compressed BLS12 point format (48 bytes).
     */
    evaluate(challengeZ: Fr, verifyProof?: boolean): {
        y: BLS12Fr;
        proof: Buffer<ArrayBuffer>;
    };
    /**
     * Get the buffer representation of the ENTIRE blob.
     *
     * @dev WARNING: this buffer contains all metadata as well as the data itself.
     *
     * @returns The buffer representation of the blob.
     */
    toBuffer(): Buffer;
    /**
     * Create a Blob from a buffer.
     *
     * @dev WARNING: this method contains all metadata as well as the data itself.
     *
     * @param buf - The buffer to create the Blob from.
     * @returns A Blob created from the buffer.
     */
    static fromBuffer(buf: Buffer | BufferReader): Blob;
    /**
     * Get the size of the blob in bytes
     */
    getSize(): number;
    static getViemKzgInstance(): {
        blobToKzgCommitment: (blob: Uint8Array) => Uint8Array;
        computeBlobKzgProof: (blob: Uint8Array, commitment: Uint8Array) => Uint8Array;
        computeCellsAndKzgProofs: (b: Uint8Array) => [Uint8Array[], Uint8Array[]];
    };
}
//# sourceMappingURL=blob.d.ts.map