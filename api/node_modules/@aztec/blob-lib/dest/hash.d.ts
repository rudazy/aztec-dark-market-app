import { BLS12Fr, Fr } from '@aztec/foundation/fields';
/**
 * Returns ethereum's versioned blob hash, following kzg_to_versioned_hash: https://eips.ethereum.org/EIPS/eip-4844#helpers
 */
export declare function computeEthVersionedBlobHash(commitment: Buffer): Buffer;
export declare function computeBlobsHash(evmVersionedBlobHashes: Buffer[]): Fr;
/**
 * The hash of the fields added throughout the checkpoint. The exact number of fields is specified by the checkpoint
 * prefix (the first field). It's verified in the circuit against the fields absorbed into the sponge blob.
 * This hash is used in generating the challenge z for all blobs in the same checkpoint.
 */
export declare function computeBlobFieldsHash(fields: Fr[]): Promise<Fr>;
export declare function computeBlobCommitment(data: Uint8Array): Buffer;
/**
 * Get the commitment fields of the blob, to compute the challenge z.
 *
 * The 48-byte commitment is encoded into two field elements:
 * +-------------------+------------------------+
 * |      31 bytes     |         17 bytes       |
 * +-------------------+------------------------+
 * |  Field Element 1  |     Field Element 2    |
 * |  [0][bytes 0-30]  |  [0...0][bytes 31-47]  |
 * +-------------------+------------------------+
 *
 * @param commitment - The commitment to convert to fields. Computed from `computeBlobCommitment`.
 * @returns The fields representing the commitment buffer.
 */
export declare function commitmentToFields(commitment: Buffer): [Fr, Fr];
export declare function computeChallengeZ(blobFieldsHash: Fr, commitment: Buffer): Promise<Fr>;
/**
 * Hash each u128 limb of the noir bignum struct representing the BLS field, to mimic the hash accumulation in the
 * rollup circuits.
 */
export declare function hashNoirBigNumLimbs(field: BLS12Fr): Promise<Fr>;
//# sourceMappingURL=hash.d.ts.map